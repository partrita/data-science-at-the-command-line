# 시작하기 {#chapter-2-getting-started}

이 장에서는 명령줄에서 데이터 과학을 수행하기 위한 모든 전제 조건이 갖추어졌는지 확인합니다. 전제 조건은 두 부분으로 나뉩니다. (1) 이 책에서 사용하는 모든 명령줄 도구가 설치된 적절한 환경을 갖추는 것, (2) 명령줄을 사용할 때 필요한 필수 개념을 이해하는 것입니다.

먼저, 필요한 모든 명령줄 도구가 포함된 Linux 기반 가상 환경인 Docker 이미지를 설치하는 방법을 설명합니다. 그런 다음 예제를 통해 필수적인 명령줄 개념을 설명합니다.

이 장이 끝나면 데이터 과학의 첫 번째 단계인 데이터 획득을 계속하는 데 필요한 모든 것을 갖추게 됩니다.

## 개요

이 장에서는 다음을 배웁니다.

- Docker 이미지를 설치하는 방법.
- 명령줄에서 데이터 과학을 수행하는 데 필요한 필수 개념 및 도구.

## Docker 이미지 설치 {#docker-image}

```{block2, type="rmdnote"}
이 섹션은 이전에 *데이터 과학 도구 상자 설정*이라고 불렸으며 모든 명령줄 도구가 포함된 Vagrant 상자를 설치하는 방법을 설명했습니다. 이 Vagrant 상자는 2014년에 만들어졌으며 가상화 및 컨테이너화 관련 기술이 발전함에 따라 업데이트할 때가 되었습니다. 따라서 이제 Vagrant 상자 대신 Docker 이미지를 사용합니다.
```


이 책에서는 다양한 명령줄 도구를 사용합니다. Linux에는 종종 많은 명령줄 도구가 사전 설치되어 제공됩니다. 또한 Linux는 다른 관련 도구가 포함된 많은 패키지를 제공합니다. 이러한 패키지를 직접 설치하는 것은 그리 어렵지 않습니다. 그러나 패키지로 제공되지 않고 더 수동적이고 복잡한 설치가 필요한 도구도 사용합니다. 각 도구의 복잡한 설치 프로세스를 거치지 않고 필요한 명령줄 도구를 얻으려면 이 책을 위해 특별히 만들어진 Docker 이미지를 설치하는 것이 좋습니다.

```{block2, type="rmdtip"}
Docker 이미지 내부가 아닌 기본적으로 명령줄 도구를 실행하는 것을 선호한다면 물론 명령줄 도구를 직접 개별적으로 설치할 수 있습니다. 이는 매우 시간이 많이 걸리는 프로세스라는 점에 유의하십시오. 부록에는 이 책에서 사용된 모든 명령줄 도구가 나열되어 있습니다. 설치 지침은 Ubuntu 전용입니다. 이 책에서 사용된 스크립트와 데이터 세트는 이 책의 [GitHub 저장소](https://github.com/jeroenjanssens/data-science-at-the-command-line)를 복제하여 얻을 수 있습니다.
```

Docker 이미지를 설치하려면 먼저 [Docker 웹사이트](https://www.docker.com/products/docker)에서 Docker 자체를 다운로드하여 설치해야 합니다.
Docker가 설치되면 터미널이나 명령 프롬프트에서 다음 명령을 호출하여 Docker 이미지를 다운로드합니다(달러 기호는 입력하지 마십시오).

```{bash, eval=FALSE}
$ docker pull datascienceworkshops/data-science-at-the-command-line
```

다음과 같이 Docker 이미지를 실행할 수 있습니다.

```{bash eval=FALSE}
$ docker run --rm -it datascienceworkshops/data-science-at-the-command-line
```

이제 필요한 모든 명령줄 도구가 설치된 격리된 Linux 환경( *Docker 컨테이너*라고 함) 내부에 있습니다. 다음 명령이 열정적인 소를 생성하면 모든 것이 올바르게 작동하는 것입니다.

```{bash eval=FALSE}
$ cowsay "가자!"
 ___________
< 가자! >
 -----------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
```

컨테이너를 종료하려면 `exit`를 실행합니다. 컨테이너 안팎으로 데이터를 가져오려면 볼륨을 추가할 수 있습니다. 즉, 로컬 디렉터리가 컨테이너 내부의 디렉터리에 매핑됩니다. 새 디렉터리를 만들고 이 새 디렉터리로 이동한 다음 macOS 또는 Linux에서 다음을 실행하는 것이 좋습니다.

```{bash eval=FALSE}
$ docker run --rm -it -v`pwd`:/data datascienceworkshops/data-science-at-the-command-line
```

또는 Windows에서 명령줄을 사용하는 경우 다음을 실행합니다.

```{bash eval=FALSE}
$ docker run --rm -it -v %cd%:/data datascienceworkshops/data-science-at-the-command-line
```

또는 Windows PowerShell을 사용하는 경우 다음을 실행합니다.

```{bash eval=FALSE}
$ docker run --rm -it -v ${PWD}:/data datascienceworkshops/data-science-at-the-command-line
```

위 명령에서 `-v` 옵션은 `docker`에게 현재 디렉터리를 컨테이너 내부의 */data* 디렉터리에 매핑하도록 지시하므로 Docker 컨테이너 안팎으로 데이터를 가져오는 곳입니다.


```{block2, type="rmdnote"}
Docker 이미지에 대해 자세히 알아보려면 [Docker Hub에서 방문](https://hub.docker.com/r/datascienceworkshops/data-science-at-the-command-line/)하십시오.
```


## 필수 GNU/Linux 개념

[1장](#chapter-1-introduction)에서는 명령줄이 무엇인지 간략하게 보여주었습니다. 이제 [Docker 이미지](#docker-image)를 실행하고 있으므로 실제로 시작할 수 있습니다. 이 섹션에서는 명령줄에서 데이터 과학을 편안하게 수행하기 위해 알아야 할 몇 가지 개념과 도구에 대해 설명합니다. 지금까지 주로 그래픽 사용자 인터페이스로 작업했다면 이것은 상당한 변화일 수 있습니다. 하지만 걱정하지 마십시오. 처음부터 시작하여 점차 고급 주제로 넘어갈 것입니다.

```{block2, type="rmdnote"}

이 섹션은 GNU/Linux에 대한 완전한 과정이 아닙니다. 데이터 과학 수행과 관련된 개념과 도구만 설명합니다. [Docker 이미지](#docker-image)의 장점 중 하나는 이미 많은 것이 설정되어 있다는 것입니다. GNU/Linux에 대해 더 자세히 알고 싶다면 이 장의 끝에 있는 추가 읽을거리 섹션을 참조하십시오.
```

### 환경

새로운 환경에 방금 로그인했습니다. 무엇이든 하기 전에 이 환경에 대한 높은 수준의 이해를 얻는 것이 좋습니다. 환경은 대략 네 가지 계층으로 정의되며, 위에서부터 간략하게 설명합니다.

명령줄 도구

:   무엇보다도 작업하는 명령줄 도구가 있습니다. 해당 명령을 입력하여 사용합니다. 다음 섹션에서 설명할 다양한 유형의 명령줄 도구가 있습니다. 도구의 예로는 `ls` [@ls], `cat` [@cat], `jq` [@jq]가 있습니다.

터미널

:   두 번째 계층인 터미널은 명령을 입력하는 응용 프로그램입니다. 다음 텍스트가 표시되면 다음과 같습니다.

    ```{bash, eval=FALSE}
    $ seq 3
    1
    2
    3
    ```

    그러면 터미널에 `seq 3`을 입력하고 `<Enter>` 키를 누릅니다. (명령줄 도구 `seq` [@seq]는 숫자 시퀀스를 생성합니다.) 달러 기호는 입력하지 않습니다. 이것은 터미널에 입력할 수 있는 명령임을 알려주기 위한 것입니다. 이 달러 기호는 프롬프트라고 합니다. `seq 3` 아래의 텍스트는 명령의 출력입니다. [1장](#chapter-1-introduction)에서는 macOS 및 Ubuntu에서 다양한 명령과 해당 출력이 있는 기본 터미널의 모양을 보여주는 두 개의 스크린샷을 보여주었습니다.

셸

:   세 번째 계층은 셸입니다. 명령을 입력하고 `<Enter>` 키를 누르면 터미널이 해당 명령을 셸로 보냅니다. 셸은 명령을 해석하는 프로그램입니다. [Docker 이미지](#docker-image)는 Bash를 셸로 사용하지만 사용 가능한 다른 많은 셸이 있습니다. 명령줄에 좀 더 능숙해지면 Z 셸이라는 셸을 살펴보고 싶을 수 있습니다. 명령줄에서 생산성을 높일 수 있는 많은 추가 기능을 제공합니다.

운영 체제

:   네 번째 계층은 운영 체제이며, 이 경우 GNU/Linux입니다. Linux는 운영 체제의 핵심인 커널의 이름입니다. 커널은 CPU, 디스크 및 기타 하드웨어와 직접 접촉합니다. 커널은 또한 명령줄 도구를 실행합니다. GNU는 GNU's not UNIX의 약자로 기본 도구 세트를 나타냅니다. [Docker 이미지](#docker-image)는 Alpine Linux라는 특정 Linux 배포판을 기반으로 합니다.

### 명령줄 도구 실행

이제 환경에 대한 기본적인 이해가 되었으므로 몇 가지 명령을 시도해 볼 차례입니다. 터미널에 다음을 입력하고(달러 기호 제외) `<Enter>` 키를 누릅니다.

```{bash, eval=FALSE}
$ pwd
/home/vagrant
```

때때로 페이지에 맞지 않는 너무 긴 명령과 파이프라인을 사용하고 있습니다. 이 경우 다음과 같은 내용이 표시됩니다.

```{bash, eval=FALSE}
$ echo '안녕하세요'\
> ' 세상' |
> wc
```

보다 큼 기호는 연속 프롬프트이며, 이 줄이 이전 줄의 연속임을 나타냅니다. 긴 명령은 백슬래시나 파이프 기호로 나눌 수 있습니다. 먼저 따옴표를 일치시키십시오. 다음 명령은 정확히 동일합니다.

```{bash, eval=FALSE}
$ echo '안녕하세요 세상' | wc
```

이것이 가장 간단한 방법입니다. 단일 명령줄 도구가 포함된 명령을 방금 실행했습니다. 명령줄 도구 `pwd` [@pwd]는 현재 있는 디렉터리의 이름을 인쇄합니다. 기본적으로 로그인하면 홈 디렉터리입니다. `ls` [@ls]를 사용하여 이 디렉터리의 내용을 볼 수 있습니다.

```{bash, eval=FALSE}
$ ls
book
```

Bash 내장 명령인 명령줄 도구 `cd`를 사용하면 다른 디렉터리로 이동할 수 있습니다.

```{bash, eval=FALSE}
$ cd book/ch02/
$ cd data
$ pwd
/home/vagrant/book/ch02/data
$ cd ..
$ pwd
/home/vagrant/book/ch02/
```

`cd` 뒤의 부분은 이동하려는 디렉터리를 지정합니다. 명령 뒤에 오는 값은 명령줄 인수 또는 옵션이라고 합니다. 두 개의 점은 상위 디렉터리를 나타냅니다. 다른 명령을 시도해 보겠습니다.

```{bash, eval=FALSE}
$ head -n 3 data/movies.txt
매트릭스
스타워즈
나 홀로 집에
```

여기서는 `head` [@head]에 세 개의 명령줄 인수를 전달합니다. 첫 번째는 옵션입니다. 두 번째는 옵션에 속하는 값입니다. 세 번째는 파일 이름입니다. 이 특정 명령은 *book/ch02/data/movies.txt* 파일의 처음 세 줄을 출력합니다.

### 다섯 가지 유형의 명령줄 도구

명령줄 도구라는 용어를 많이 사용하지만 지금까지 실제로 무엇을 의미하는지 설명하지 않았습니다. 명령줄에서 실행할 수 있는 *모든 것*에 대한 포괄적인 용어로 사용합니다. 내부적으로 각 명령줄 도구는 다음 다섯 가지 유형 중 하나입니다.

- 바이너리 실행 파일.
- 셸 내장 명령.
- 해석된 스크립트.
- 셸 함수.
- 별칭.

유형 간의 차이점을 아는 것이 좋습니다. [Docker 이미지](#docker-image)와 함께 사전 설치된 명령줄 도구는 대부분 처음 두 가지 유형(바이너리 실행 파일 및 셸 내장 명령)으로 구성됩니다. 다른 세 가지 유형(해석된 스크립트, 셸 함수 및 별칭)을 사용하면 데이터 과학 도구 상자를 더욱 구축하고 더 효율적이고 생산적인 데이터 과학자가 될 수 있습니다.

바이너리 실행 파일

:   바이너리 실행 파일은 고전적인 의미의 프로그램입니다. 바이너리 실행 파일은 소스 코드를 기계 코드로 컴파일하여 만들어집니다. 즉, 텍스트 편집기에서 파일을 열면 읽을 수 없습니다.

셸 내장 명령

:   셸 내장 명령은 이 경우 Bash인 셸에서 제공하는 명령줄 도구입니다. 예로는 `cd`와 `help`가 있습니다. 이러한 명령은 변경할 수 없습니다. 셸 내장 명령은 셸마다 다를 수 있습니다. 바이너리 실행 파일과 마찬가지로 쉽게 검사하거나 변경할 수 없습니다.

해석된 스크립트

:   해석된 스크립트는 바이너리 실행 파일에 의해 실행되는 텍스트 파일입니다. 예로는 Python, R 및 Bash 스크립트가 있습니다. 해석된 스크립트의 한 가지 큰 장점은 읽고 변경할 수 있다는 것입니다. 예제 \@ref(exm:script-fac)는 *\~/book/ch02/fac.py*라는 스크립트를 보여줍니다. 이 스크립트는 파일 확장자 *.py* 때문이 아니라 스크립트의 첫 번째 줄이 실행해야 하는 바이너리를 정의하기 때문에 Python에 의해 해석됩니다.

    ```{example script-fac, name="정수의 계승을 계산하는 Python 스크립트"}
    ```
    ```{python, eval=FALSE}
    ##!/usr/bin/env python

    def factorial(x):
        result = 1
        for i in xrange(2, x + 1):
            result *= i
        return result

    if __name__ == "__main__":
        import sys
        x = int(sys.argv[1])
        print factorial(x)
    ```

    이 스크립트는 매개변수로 전달하는 정수의 계승을 계산합니다. 다음과 같이 명령줄에서 호출할 수 있습니다.

    ```{bash, eval=FALSE}
    $ book/ch02/fac.py 5
    120
    ```

    [4장](#chapter-4-creating-reusable-command-line-tools)에서는 해석된 스크립트를 사용하여 재사용 가능한 명령줄 도구를 만드는 방법에 대해 자세히 설명합니다.

셸 함수

:   셸 함수는 이 경우 Bash에 의해 실행되는 함수입니다. Bash 스크립트와 유사한 기능을 제공하지만 일반적으로 스크립트보다 작습니다(반드시 그런 것은 아님). 또한 더 개인적인 경향이 있습니다. 다음 명령은 위에서 해석된 Python 스크립트와 마찬가지로 전달하는 정수의 계승을 계산하는 `fac`라는 함수를 정의합니다. `seq`를 사용하여 숫자 목록을 생성하고, `paste` [@paste]를 사용하여 해당 숫자를 구분 기호로 `*`를 사용하여 한 줄에 넣고, 이 방정식을 `bc` [@bc]에 전달하여 평가하고 결과를 출력합니다.

    ```{bash, eval=FALSE}
    $ fac() { (echo 1; seq $1) | paste -s -d\* - | bc; }
    $ fac 5
    120
    ```

    Bash의 구성 파일인 *.bashrc* 파일은 셸 함수를 정의하기에 좋은 위치이므로 항상 사용할 수 있습니다.

별칭

:   별칭은 매크로와 같습니다. 특정 명령을 동일한 매개변수(또는 그 일부)로 자주 실행하는 경우 이에 대한 별칭을 정의할 수 있습니다. 별칭은 특정 명령을 계속해서 잘못 입력하는 경우에도 매우 유용합니다(유용한 별칭의 긴 목록은 <https://github.com/chrishwiggins/mise/blob/master/sh/aliases-public.sh> 참조). 다음 명령은 이러한 별칭을 정의합니다.

    ```{bash, eval=FALSE}
    $ alias l='ls -1 --group-directories-first'
    $ alias moer=more
    ```

    이제 명령줄에 다음을 입력하면 셸이 발견하는 각 별칭을 해당 값으로 바꿉니다.

    ```{bash, eval=FALSE}
    $ cd ~
    $ l
    book
    ```

    별칭은 매개변수를 허용하지 않으므로 셸 함수보다 간단합니다. 함수 `fac`는 매개변수 때문에 별칭을 사용하여 정의할 수 없었습니다. 그래도 별칭을 사용하면 많은 키 입력을 절약할 수 있습니다. 셸 함수와 마찬가지로 별칭은 홈 디렉터리에 있는 *.bashrc* 또는 *.bash\_aliases* 구성 파일에 자주 정의됩니다. 현재 정의된 모든 별칭을 보려면 인수 없이 `alias`를 실행하기만 하면 됩니다. 시도해 보십시오. 무엇이 보입니까?

이 책에서는 해석된 스크립트, 셸 함수 및 별칭과 같이 마지막 세 가지 유형의 명령줄 도구에 주로 초점을 맞출 것입니다. 이는 쉽게 변경할 수 있기 때문입니다. 명령줄 도구의 목적은 명령줄에서의 생활을 더 쉽게 만들고 더 생산적이고 효율적인 데이터 과학자로 만드는 것입니다. `type`(자체적으로 셸 내장 명령임)을 사용하여 명령줄 도구의 유형을 알아낼 수 있습니다.

```{bash, eval=FALSE}
$ type -a pwd
pwd는 셸 내장 명령입니다
pwd는 /bin/pwd입니다
$ type -a cd
cd는 셸 내장 명령입니다
$ type -a fac
fac는 함수입니다
fac ()
{
    ( echo 1;
    seq $1 ) | paste -s -d\* - | bc
}
$ type -a l
l은 `ls -1 --group-directories-first'의 별칭입니다
```

`type`은 `pwd`에 대해 두 개의 명령줄 도구를 반환합니다. 이 경우 `pwd`를 입력하면 보고된 첫 번째 명령줄 도구가 사용됩니다. 다음 섹션에서는 명령줄 도구를 결합하는 방법을 살펴보겠습니다.

### 명령줄 도구 결합

대부분의 명령줄 도구는 UNIX 철학을 따르므로 한 가지 작업만 수행하고 매우 잘 수행하도록 설계되었습니다. 예를 들어 명령줄 도구 `grep` [@grep]은 줄을 필터링할 수 있고, `wc` [@wc]는 줄 수를 셀 수 있으며, `sort` [@sort]는 줄을 정렬할 수 있습니다. 명령줄의 강력함은 이러한 작지만 강력한 명령줄 도구를 결합하는 능력에서 비롯됩니다. 명령줄 도구를 결합하는 가장 중요한 방법은 소위 파이프를 사용하는 것입니다. 첫 번째 도구의 출력이 두 번째 도구로 전달됩니다. 여기에는 사실상 제한이 없습니다.

예를 들어 숫자 시퀀스를 생성하는 명령줄 도구 `seq`를 생각해 보겠습니다. 다섯 개의 숫자 시퀀스를 생성해 보겠습니다.

```{bash, eval=FALSE}
$ seq 5
1
2
3
4
5
```

명령줄 도구의 출력은 기본적으로 터미널로 전달되어 화면에 표시됩니다. `seq`의 출력을 두 번째 도구인 `grep`으로 *파이프*할 수 있으며, 이는 줄을 필터링하는 데 사용할 수 있습니다. "3"을 포함하는 숫자만 보고 싶다고 상상해 보십시오. 다음과 같이 `seq`와 `grep`을 결합할 수 있습니다.

```{bash, eval=FALSE}
$ seq 30 | grep 3
3
13
23
30
```

그리고 1에서 100 사이의 숫자 중 3을 포함하는 숫자가 *몇 개*인지 알고 싶다면 계산에 매우 능숙한 `wc`를 사용할 수 있습니다.

```{bash, eval=FALSE}
$ seq 100 | grep 3 | wc -l
19
```

`-l` 옵션은 `wc`가 전달된 줄 수만 출력하도록 지정합니다. 기본적으로 문자 수와 단어 수도 반환합니다.

명령줄 도구를 결합하는 것이 매우 강력한 개념이라는 것을 알기 시작할 수 있습니다. 이 책의 나머지 부분에서는 더 많은 도구와 이를 결합할 때 제공하는 기능에 대해 소개합니다.

### 입력 및 출력 리디렉션

파이프라인의 마지막 명령줄 도구의 출력은 기본적으로 터미널로 출력된다고 언급했습니다. 이 출력을 파일에 저장할 수도 있습니다. 이것을 출력 리디렉션이라고 하며 다음과 같이 작동합니다.

```{bash, eval=FALSE}
$ seq 10 > data/ten-numbers
```

여기서는 `seq` 도구의 출력을 *\~/book/ch02/data* 디렉터리의 *ten-numbers*라는 파일에 저장합니다. 이 파일이 아직 존재하지 않으면 생성됩니다. 이 파일이 이미 존재했다면 내용이 덮어쓰여졌을 것입니다. `>>`를 사용하여 파일에 출력을 추가할 수도 있습니다. 즉, 출력이 원래 내용 뒤에 추가됩니다.

```{bash, eval=FALSE}
$ echo -n "안녕하세요" > hello-world
$ echo " 세상" >> hello-world
```

echo 도구는 지정한 값을 출력합니다. `-n` 옵션은 `echo`가 후행 줄 바꿈을 출력하지 않도록 지정합니다.

출력을 파일에 저장하는 것은 예를 들어 나중에 분석을 계속하기 위해 중간 결과를 저장해야 하는 경우에 유용합니다. *hello-world* 파일의 내용을 다시 사용하려면 파일을 읽고 인쇄하는 `cat` [@cat]을 사용할 수 있습니다.

```{bash, eval=FALSE}
$ cat hello-world | wc -w
2
```

(`-w` 옵션은 `wc`가 단어만 계산하도록 나타냅니다.) 동일한 결과를 다음 표기법으로 얻을 수 있습니다.

```{bash, eval=FALSE}
$ < hello-world wc -w
2
```

이렇게 하면 추가 프로세스를 실행하지 않고 파일을 `wc`의 표준 입력으로 직접 전달합니다. 명령줄 도구가 파일을 명령줄 인수로 지정하는 것도 허용하는 경우(많은 도구가 그렇습니다) `wc`에 대해 다음을 수행할 수도 있습니다.

```{bash, eval=FALSE}
$ wc -w hello-world
2 hello-world
```

### 파일 작업

데이터 과학자로서 우리는 많은 데이터를 다룹니다. 이 데이터는 종종 파일에 저장됩니다. 명령줄에서 파일(및 해당 파일이 있는 디렉터리)로 작업하는 방법을 아는 것이 중요합니다. 그래픽 사용자 인터페이스를 사용하여 수행할 수 있는 모든 작업은 명령줄 도구로 수행할 수 있습니다(그리고 훨씬 더 많은 작업). 이 섹션에서는 파일 및 디렉터리를 만들고, 이동하고, 복사하고, 이름을 바꾸고, 삭제하는 가장 중요한 도구를 소개합니다.

`>` 또는 `>>`를 사용하여 출력을 리디렉션하여 새 파일을 만드는 방법을 이미 보았습니다. 파일을 다른 디렉터리로 이동해야 하는 경우 `mv` [@mv]를 사용할 수 있습니다.

```{bash, eval=FALSE}
$ mv hello.txt ~/book/ch02/data/
```

`mv`를 사용하여 파일 이름을 바꿀 수도 있습니다.

```{bash, eval=FALSE}
$ cd data
$ mv hello.txt bye.txt
```

전체 디렉터리의 이름을 바꾸거나 이동할 수도 있습니다. 파일이 더 이상 필요하지 않은 경우 `rm` [@rm]을 사용하여 삭제(또는 제거)합니다.

```{bash, eval=FALSE}
$ rm bye.txt
```

모든 내용이 포함된 전체 디렉터리를 제거하려면 재귀를 의미하는 `-r` 옵션을 지정합니다.

```{bash, eval=FALSE}
$ rm -r book/ch02/data/old
```

파일을 복사하려면 `cp` [@cp]를 사용합니다. 이는 백업을 만드는 데 유용합니다.

```{bash, eval=FALSE}
$ cp server.log server.log.bak
```

`mkdir` [@mkdir]를 사용하여 디렉터리를 만들 수 있습니다.

```{bash, eval=FALSE}
$ cd data
$ mkdir logs
```

명령줄 도구를 사용하여 파일을 관리하는 것은 처음에는 무서울 수 있습니다. 왜냐하면 즉각적인 피드백을 제공하는 파일 시스템의 그래픽 개요가 없기 때문입니다.

위의 모든 명령줄 도구는 자세한 정보를 의미하는 `-v` 옵션을 허용하므로 진행 상황을 출력합니다. `mkdir`를 제외한 모든 도구는 대화형을 의미하는 `-i` 옵션을 허용하며 도구가 확인을 요청하도록 합니다.

### 도움말!

명령줄을 사용하는 방법을 익히는 동안 도움이 필요할 수 있습니다. 가장 노련한 Linux 사용자도 어느 시점에는 도움이 필요합니다. 모든 다른 명령줄 도구와 가능한 인수를 모두 기억하는 것은 불가능합니다. 다행히 명령줄은 도움을 받을 수 있는 여러 가지 방법을 제공합니다.

도움을 받는 가장 중요한 명령은 아마도 *manual*의 약자인 `man` [@man]일 것입니다. 대부분의 명령줄 도구에 대한 정보가 포함되어 있습니다. `cat` 도구의 다른 옵션을 잊어버렸다고 상상해 보십시오. 다음을 사용하여 해당 man 페이지에 액세스할 수 있습니다.

```{bash, eval=FALSE}
$ man cat | head -n 20
CAT(1) 사용자 명령어 CAT(1)



이름
       cat - 파일들을 연결하고 표준 출력으로 인쇄합니다

개요
       cat [옵션]... [파일]...

설명
       파일(들) 또는 표준 입력을 표준 출력으로 연결합니다.

       -A, --show-all
              -vET와 동일합니다

       -b, --number-nonblank
              비어 있지 않은 출력 줄에 번호를 매기고 -n을 재정의합니다

       -e     -vE와 동일합니다
```

```{block2, type="rmdtip"}

때때로 명령 끝에 `head`, `fold` 또는 `cut`을 사용하는 것을 볼 수 있습니다. 이것은 명령 출력이 페이지에 맞도록 하기 위한 것이며 입력할 필요는 없습니다. 예를 들어 `head -n 5`는 처음 다섯 줄만 인쇄하고, `fold`는 긴 줄을 80자로 줄 바꿈하며, `cut -c1-80`은 80자보다 긴 줄을 자릅니다.
```

모든 명령줄 도구에 man 페이지가 있는 것은 아닙니다. `cd`와 같은 셸 내장 명령의 경우 `help` 명령줄 도구를 사용해야 합니다.

```{bash, eval=FALSE}
$ help cd | head -n 20
cd: cd [-L|[-P [-e]] [-@]] [dir]
    셸 작업 디렉터리를 변경합니다.

    현재 디렉터리를 DIR로 변경합니다. 기본 DIR은
    HOME 셸 변수의 값입니다.

    CDPATH 변수는 DIR을 포함하는 디렉터리의 검색 경로를 정의합니다.
    CDPATH의 대체 디렉터리 이름은 콜론(:)으로 구분됩니다.
    null 디렉터리 이름은 현재 디렉터리와 동일합니다. DIR이
    슬래시(/)로 시작하면 CDPATH는 사용되지 않습니다.

    디렉터리를 찾을 수 없고 셸 옵션 `cdable_vars`가 설정된 경우
    단어는 변수 이름으로 간주됩니다. 해당 변수에 값이 있으면
    해당 값이 DIR에 사용됩니다.

    옵션:
        -L      심볼릭 링크를 강제로 따르도록 합니다: `..' 인스턴스를 처리한 후
                DIR의 심볼릭 링크를 확인합니다.
        -P      심볼릭 링크를 따르지 않고 물리적 디렉터리 구조를 사용합니다:
                인스턴스를 처리하기 전에 DIR의 심볼릭 링크를 확인합니다.
```

이 도움말은 관심 있는 경우 Bash의 다른 주제도 다룹니다(주제 목록을 보려면 명령줄 인수 없이 `help`를 시도하십시오). 특정 명령줄 도구의 종류를 알아내려면 `type`을 사용할 수 있다는 것을 기억하십시오.

명령줄에서 사용할 수 있는 최신 도구에도 man 페이지가 없는 경우가 많습니다. 이 경우 가장 좋은 방법은 `--help` 옵션(때로는 `-h` 옵션)으로 도구를 호출하는 것입니다. 예를 들어 다음과 같습니다.

```{bash, eval=FALSE}
jq --help

jq - 명령줄 JSON 프로세서 [버전 1.4]
사용법: jq [옵션] <jq 필터> [파일...]

명령줄 옵션에 대한 설명과
jq 필터를 작성하는 방법(그리고 왜 원하는지)은
jq man 페이지 또는 다음 온라인 설명서를 참조하십시오.
http://stedolan.github.com/jq
```

`--help` 옵션을 지정하는 것은 `cat`과 같은 GNU 명령줄 도구에서도 작동합니다. 그러나 해당 man 페이지는 종종 더 많은 정보를 제공합니다. 이 세 가지 방법을 시도한 후에도 여전히 막히면 인터넷을 참조하는 것이 완벽하게 허용됩니다. 부록에는 이 책에서 사용된 모든 명령줄 도구 목록이 있습니다. 각 명령줄 도구를 설치하는 방법 외에도 도움을 받는 방법도 보여줍니다.

## 추가 읽을거리

* Heddings, Lowell. 2006. “Bash용 키보드 단축키.” <a href="http://www.howtogeek.com/howto/ubuntu/keyboard-shortcuts-for-bash-command-shell-for-ubuntu-debian-suse-redhat-linux-etc" class="uri">http://www.howtogeek.com/howto/ubuntu/keyboard-shortcuts-for-bash-command-shell-for-ubuntu-debian-suse-redhat-linux-etc</a>.
* Peek, Jerry, Shelley Powers, Tim O’Reilly, and Mike Loukides. 2002. <em>Unix Power Tools</em>. 3rd Ed. O’Reilly Media.
