# 데이터 워크플로 관리 {#chapter-6-managing-your-data-workflow}

이제까지 명령줄이 탐색적 데이터 분석에 매우 편리한 환경이라는 점을 이해하셨기를 바랍니다. 명령줄로 작업한 결과 다음과 같은 점을 눈치채셨을 것입니다.

- 다양한 명령을 호출합니다.
- 사용자 지정 명령줄 도구를 만듭니다.
- 많은 (중간) 파일을 얻고 생성합니다.

이 프로세스는 탐색적 성격을 띠므로 워크플로가 다소 혼란스러워져 수행한 작업을 추적하기 어려워집니다. 우리가 수행한 단계는 우리 자신이나 다른 사람이 재현할 수 있어야 한다는 것이 매우 중요합니다. 예를 들어 몇 주 전에 진행했던 프로젝트를 계속 진행할 때 어떤 명령을 어떤 파일에서 어떤 순서로 어떤 매개변수를 사용하여 실행했는지 잊어버렸을 가능성이 있습니다. 분석 결과를 공동 작업자에게 전달하는 것이 얼마나 어려운지 상상해 보십시오.

Bash 기록을 뒤져 일부 손실된 명령을 복구할 수 있지만 물론 이것은 좋은 방법이 아닙니다. 더 나은 방법은 명령을 셸 스크립트 *run.sh*에 저장하는 것입니다. 이렇게 하면 귀하와 귀하의 공동 작업자가 최소한 분석을 재현할 수 있습니다. 그러나 셸 스크립트는 다음과 같은 이유로 최적이 아닌 방법입니다.

- 읽고 유지 관리하기 어렵습니다.
- 단계 간의 종속성이 불분명합니다.
- 매번 모든 단계가 실행되므로 비효율적이고 때로는 바람직하지 않습니다.

이것이 Drake [@drake]가 유용한 이유입니다. Drake는 Factual에서 만든 명령줄 도구로 다음을 수행할 수 있습니다.

- 입력 및 출력 종속성 측면에서 데이터 워크플로 단계를 공식화합니다.
- 명령줄에서 워크플로의 특정 단계를 실행합니다.
- 인라인 코드를 사용합니다.
- 외부 소스에서 데이터를 저장하고 검색합니다.

## 개요

Drake로 데이터 워크플로를 관리하는 것이 이 장의 주요 주제입니다. 따라서 다음에 대해 배우게 됩니다.

- 소위 Drakefile로 워크플로를 정의합니다.
- 입력 및 출력 종속성 측면에서 워크플로에 대해 생각합니다.
- 특정 대상을 빌드합니다.

## Drake 소개

Drake는 데이터와 해당 종속성을 중심으로 명령 실행을 구성합니다. 데이터 처리 단계는 별도의 텍스트 파일(워크플로)로 공식화됩니다. 각 단계에는 일반적으로 하나 이상의 입력과 출력이 있습니다. Drake는 자동으로 해당 종속성을 해결하고 실행해야 하는 명령과 순서를 결정합니다.

즉, 예를 들어 10분이 걸리는 SQL 쿼리가 있는 경우 결과가 없거나 쿼리가 나중에 변경된 경우에만 실행하면 됩니다. 또한 특정 단계를 (재)실행하려는 경우 Drake는 해당 단계가 의존하는 단계만 (재)실행하도록 고려합니다. 이렇게 하면 많은 시간을 절약할 수 있습니다.

공식화된 워크플로를 사용하면 몇 주 후에 프로젝트를 쉽게 다시 시작하고 다른 사람들과 공동 작업할 수 있다는 이점이 있습니다. 이것이 일회성 프로젝트라고 생각하더라도 특정 단계를 다시 실행해야 하거나 다른 프로젝트에서 특정 단계를 재사용하고 싶을 때를 알 수 없으므로 이 작업을 수행하는 것이 좋습니다.

## Drake 설치

Drake에는 몇 가지 종속성이 있어 설치 과정이 다소 복잡합니다. 다음 지침에서는 Ubuntu를 사용한다고 가정합니다.

```{block2, type="rmdtip"}

데이터 과학 도구 상자를 사용하는 경우 이미 Drake가 설치되어 있으므로 이 섹션을 안전하게 건너뛸 수 있습니다.
```

Drake는 Clojure 프로그래밍 언어로 작성되었으므로 Java 가상 머신(JVM)에서 실행됩니다. 미리 빌드된 jar를 사용할 수 있지만 Drake가 활발하게 개발 중이므로 소스에서 빌드합니다. 이를 위해서는 Leiningen을 설치해야 합니다.

```{bash, eval=FALSE}
$ sudo apt-get install openjdk-6-jdk
$ sudo apt-get install leiningen
```

그런 다음 Factual에서 Drake 저장소를 복제합니다.

```{bash, eval=FALSE}
$ git clone https://github.com/Factual/drake.git
```

그리고 Leiningen을 사용하여 uberjar를 빌드합니다.

```{bash, eval=FALSE}
$ cd drake
$ lein uberjar
```

이렇게 하면 *drake.jar*가 생성됩니다. 이 파일을 *\$PATH*에 있는 디렉터리(예: *\~/bin*)로 복사합니다.

```{bash, eval=FALSE}
$ mv drake.jar ~/bin/
```

이 시점에서 이미 Drake를 실행할 수 있어야 합니다.

```{bash, eval=FALSE}
$ cd ~/bin/
$ java -jar drake.jar
```

이는 두 가지 이유로 그다지 편리하지 않습니다. (1) JVM(Java 가상 머신)이 시작하는 데 시간이 오래 걸리고 (2) 해당 디렉터리에서만 실행할 수 있습니다. `java` 명령보다 훨씬 빠른 시작 시간을 제공하는 JVM용 시작 프로그램인 Drip을 설치하는 것이 좋습니다. 먼저 Flatland에서 Drip 저장소를 복제합니다.

```{bash, eval=FALSE}
$ git clone https://github.com/flatland/drip.git
$ cd drip
$ make prefix=~/bin install
```

그런 다음 어디에서나 Drake를 실행할 수 있는 Bash 스크립트를 만듭니다.

```{bash, eval=FALSE}
$ cd ~/bin
$ cat << 'EOF' > drake
> #!/bin/bash
> drip -cp $(dirname $0)/drake.jar drake.core "$@"
> EOF
$ chmod +x drake
```

Drake와 Drip이 모두 올바르게 설치되었는지 확인하려면 가급적 다른 디렉터리에서 다음 명령을 실행합니다.

```{bash, eval=FALSE}
$ drake --version
Drake 버전 0.1.6
```

```{block2, type="rmdnote"}

Drip은 한 번 실행된 후 JVM 인스턴스를 예약하므로 Java 속도를 높입니다. 이 때문에 두 번째 실행부터 속도 향상을 느낄 수 있습니다.
```

## 프로젝트 구텐베르크에서 인기 전자책 얻기

이 장의 나머지 부분에서는 다음 작업을 실행 예제로 사용합니다. 우리의 목표는 이 작업을 해결하는 데 사용하는 명령을 Drake 워크플로로 바꾸는 것입니다. 간단하게 시작하여 Drake의 다양한 개념과 구문을 설명하기 위해 고급 워크플로로 나아갈 것입니다.

프로젝트 구텐베르크는 1971년부터 42,000권 이상의 책을 보관하고 디지털화하여 무료 전자책으로 제공하는 야심 찬 프로젝트입니다. 웹사이트에서 가장 많이 다운로드된 상위 100권의 책을 찾을 수 있습니다. 프로젝트 구텐베르크의 상위 5개 다운로드에 관심이 있다고 가정해 보겠습니다. 이 목록은 HTML로 제공되므로 상위 5개 다운로드를 얻는 것은 간단합니다.

```{bash, eval=FALSE}
$ curl -s 'http://www.gutenberg.org/browse/scores/top' |
> grep -E '^<li>' |
> head -n 5 |
> sed -E "s/.*ebooks\/([0-9]+).*/\\1/" > data/top-5
```

이 명령은 다음을 수행합니다.

- HTML을 다운로드합니다.
- 목록 항목을 추출합니다.
- 상위 5개 항목만 유지합니다.
- 전자책 ID를 *data/top-5*에 저장합니다.

명령의 출력은 다음과 같습니다.

```{bash, eval=FALSE}
$ cat data/top-5
1342
76
11
1661
1952
```

나중에 다시 한 번 재현하고 싶다면 [4장](#chapter-4-creating-reusable-command-line-tools)에서 본 것처럼 이 명령을 스크립트에 넣는 것이 가장 쉬운 방법입니다. 이 스크립트를 다시 실행하면 HTML도 다시 다운로드됩니다. 특정 단계가 실행되는지 여부를 제어하고 싶을 수 있는 세 가지 일반적인 이유가 있습니다. 첫째, 이 단계가 매우 오래 걸릴 수 있기 때문입니다. 둘째, 동일한 데이터로 계속 진행하고 싶기 때문입니다. 셋째, 데이터가 특정 속도 제한이 있는 API에서 올 수 있기 때문입니다. 한 단계에서 데이터를 파일에 저장한 다음 후속 단계에서 해당 파일에 대해 작업하도록 하여 불필요한 계산이나 API 호출을 하지 않도록 하는 것이 좋습니다. 이제 첫 번째 이유는 HTML을 충분히 빠르게 다운로드할 수 있으므로 예제에서 큰 문제가 되지 않습니다. 그러나 경우에 따라 데이터가 다른 출처에서 올 수 있으며 기가바이트 단위의 데이터로 구성될 수 있습니다.

## 모든 워크플로는 단일 단계로 시작합니다

이 섹션에서는 위 명령을 Drake 워크플로로 변환합니다. 워크플로는 텍스트 파일일 뿐입니다. 명령줄에서 다른 파일이 지정되지 않은 경우 Drake가 해당 파일을 사용하므로 일반적으로 이 파일의 이름을 *Drakefile*로 지정합니다. 단일 단계만 있는 워크플로는 예제 \@ref(exm:drakefile)과 같습니다.

```{example drakefile, name="단일 단계만 있는 워크플로"}
```
```
top-5 <-
    curl -s 'http://www.gutenberg.org/browse/scores/top' |
    grep -E '^<li>' |
    head -n 5 |
    sed -E "s/.*ebooks\/([0-9]+).*/\\1/" > top-5
```

이 파일을 살펴보겠습니다. 왼쪽을 가리키는 화살표가 포함된 첫 번째 줄은 단계 정의입니다. 이 화살표의 왼쪽 부분인 *top-5*는 이 단계의 이름 또는 출력입니다. 이 단계에 대한 모든 입력은 이 화살표의 오른쪽에 표시되지만 이 단계에는 입력이 없으므로 비어 있습니다. 입력과 출력을 정의하면 Drake가 단계 간의 종속성을 인식하고 특정 출력을 충족하기 위해 어떤 단계를 언제 실행해야 하는지 파악할 수 있습니다. 이 출력은 대상이라고도 합니다. 보시다시피 이 단계의 본문은 이전 명령을 그대로 들여쓴 것입니다.

- 화살표(*←*)는 단계의 이름과 해당 종속성을 나타냅니다. 이에 대해서는 나중에 자세히 설명합니다.
- 본문은 들여쓰기됩니다.
- 목록 항목만 선택합니다.
- 처음 5개 항목을 가져옵니다.
- ID를 추출하고 파일 *top-5*에 저장합니다. *top-5*는 이미 단계 정의에 지정되었으며 *5*는 이제 세 번 사용되었습니다. 이에 대해서는 나중에 다룰 것입니다.

이 워크플로는 가능한 한 간단합니다. Bash 스크립트에 명령을 넣는 것보다 장점이 없습니다. 하지만 걱정하지 마십시오. 더 흥미로워질 것이라고 약속합니다. 지금은 Drake를 실행하고 첫 번째 워크플로로 무엇을 하는지 살펴보겠습니다.

```{bash, eval=FALSE}
$ drake
다음 단계가 순서대로 실행됩니다.
  1: top-5 <-  [출력 누락]
확인하시겠습니까? [y/n] y
동시성 1로 1단계 실행 중...

--- 0. 실행 중 (출력 누락): top-5 <-
--- 0: top-5 <-  -> 0.35초 만에 완료
완료 (1단계 실행됨).
```

특정 워크플로 파일을 지정하지 않으면 Drake는 *./Drakefile*을 사용합니다. Drake는 먼저 실행해야 하는 단계를 결정합니다. 이 경우 출력이 없으므로 유일한 단계가 실행됩니다. 즉, *data/top-5*라는 파일이 없습니다. Drake는 이러한 단계를 실행하기 전에 확인을 요청합니다. `y`를 누르면 곧 Drake가 완료된 것을 볼 수 있습니다. Drake는 단계에서 오류에 대해 불평하지 않았습니다. 출력 파일 *data/top-5*를 보고 상위 5권의 책이 있는지 확인해 보겠습니다.

```{bash, eval=FALSE}
$ cat data/top-5
1342
76
11
1661
1952
```

이제 출력 파일이 있습니다. Drake를 다시 실행해 보겠습니다.

```{bash, eval=FALSE}
$ drake
다음 단계가 순서대로 실행됩니다.
  1: top-5 <-  [입력 없는 단계]
확인하시겠습니까? [y/n] n
중단됨.
```

보시다시피 Drake는 단계를 다시 실행하려고 합니다! 그러나 이제 입력 단계가 없다는 다른 이유를 언급합니다(*\[no-input-step\]*). 기본 동작은 입력의 타임스탬프를 보고 입력이 변경되었는지 확인하는 것입니다. 그러나 입력을 지정하지 않았으므로 Drake는 이 단계를 다시 실행해야 하는지 여부를 알 수 없습니다. 다음과 같이 타임스탬프를 확인하는 이 기본 동작을 비활성화할 수 있습니다.

```
top-5 <- [-timecheck]
    curl -s 'http://www.gutenberg.org/browse/scores/top' |
    grep -E '^<li>' |
    head -n 5 |
    sed -E "s/.*ebooks\/([0-9]+)\">([^<]+)<.*/\\1,\\2/" > top-5
```

*\[-timecheck\]* 주위의 대괄호는 이것이 단계에 대한 옵션임을 나타냅니다. 마이너스(*-*)는 타임스탬프 확인을 비활성화하려고 함을 의미합니다. 이제 이 단계는 출력이 없는 경우에만 실행됩니다.

이전 버전을 유지하기 위해 다른 파일 이름을 사용할 것입니다. `-w` 옵션을 사용하여 다른 워크플로 이름( *Drakefile* 이외)을 지정할 수 있습니다. Drake를 한 번 더 실행해 보겠습니다.

```{bash, eval=FALSE}
$ mv Drakefile 01.drake
$ drake -w 01.drake
할 일이 없습니다.
```

Drake가 해당 단계가 다시 실행될 필요가 없음을 감지하므로 첫 번째 워크플로는 이미 시간을 절약하고 있습니다. 그러나 이보다 훨씬 더 잘할 수 있습니다. 이 워크플로에는 다음 섹션에서 다룰 세 가지 단점이 있습니다.

## 음, 그건 경우에 따라 다릅니다

우리의 워크플로에는 단일 단계만 포함되어 있으며, 이는 간단한 Bash 스크립트를 사용하는 것과 마찬가지로 모든 것이 항상 실행됨을 의미합니다. 따라서 가장 먼저 할 일은 이 단일 단계를 두 단계로 나누는 것입니다. 첫 번째 단계는 HTML을 다운로드하고 두 번째 단계는 이 HTML을 처리합니다. 두 번째 단계는 분명히 첫 번째 단계에 의존합니다. 워크플로에서 이 종속성을 정의할 수 있습니다.

숫자 5가 세 번 지정되었음을 눈치챘을 것입니다. 예를 들어 프로젝트 구텐베르크에서 상위 10개 전자책을 얻고 싶다면 워크플로를 세 군데 변경해야 합니다. 이것은 비효율적이며 해결해야 합니다. 다행히 Drake는 변수를 지원합니다.

워크플로에서 즉시 명확하지 않을 수 있지만 데이터는 스크립트와 동일한 위치에 있습니다. 데이터를 별도의 위치에 보관하고 이 데이터를 생성하는 모든 코드와 분리하는 것이 좋습니다. 프로젝트를 더 깔끔하게 유지할 뿐만 아니라 생성된 데이터 파일을 더 쉽게 삭제할 수 있으며 `git` [@git]과 같은 버전 관리 시스템에 데이터 파일을 포함하지 않도록 쉽게 지정할 수 있습니다. 살펴보겠습니다.

```
NUM:=5
BASE=data/

top.html <- [-timecheck]
    curl -s 'http://www.gutenberg.org/browse/scores/top' > $OUTPUT

top-$[NUM] <- top.html
    < $INPUT grep -E '^<li>' |
    head -n $[NUM] |
    sed -E "s/.*ebooks\/([0-9]+)\">([^<]+)<.*/\\1,\\2/" > $OUTPUT
```

- 변수 이름, 등호, 값을 차례로 지정하여 Drake에서 변수를 지정할 수 있으며, 가급적 파일 시작 부분에 지정합니다. 변수 이름은 모두 대문자일 필요는 없지만 눈에 잘 띄게 만듭니다. 보시다시피 변수 *NUM*에 대해 *=* 대신 *:=*를 사용했습니다. 즉, 변수 *NUM*이 이미 설정된 경우 덮어쓰지 않습니다. 이렇게 하면 Drake를 실행하기 전에 명령줄에서 *NUM* 값을 지정할 수 있습니다.
- *BASE* 변수는 특수 변수입니다. Drake는 워크플로에 지정된 모든 파일을 이 기본 디렉터리에 있는 것처럼 처리합니다.
- 이제 두 단계가 있습니다. 첫 번째 단계는 이전과 동일한 입력을 갖지만 이제 출력은 다른 파일, 즉 *top.html*입니다. 이 출력은 2단계의 입력으로 다시 정의됩니다. 이것이 Drake가 두 번째 단계가 첫 번째 단계에 의존한다는 것을 아는 방법입니다.
- 두 가지 특수 변수인 *INPUT*과 *OUTPUT*을 더 사용했습니다. 이 두 특수 변수의 값은 해당 단계의 입력 및 출력으로 정의한 값으로 설정됩니다. 이렇게 하면 특정 단계의 입력과 출력을 두 번 지정할 필요가 없습니다. 또한 향후 워크플로에서 특정 단계를 쉽게 재사용할 수 있습니다.

Drake를 사용하여 이 새 워크플로를 실행해 보겠습니다.

```{bash, eval=FALSE}
$ drake -w 02.drake
다음 단계가 순서대로 실행됩니다.
  1: ../../data/top.html <-  [출력 누락]
  2: ../../data/top-5 <- ../../data/top.html [예상 타임스탬프]
확인하시겠습니까? [y/n] y
동시성 1로 2단계 실행 중...

--- 0. 실행 중 (출력 누락): ../../data/top.html <-
--- 0: ../../data/top.html <-  -> 0.89초 만에 완료
--- 1. 실행 중 (출력 누락): ../../data/top-5 <- ../../data/top.html
--- 1: ../../data/top-5 <- ../../data/top.html -> 0.02초 만에 완료
완료 (2단계 실행됨).
```

이제 상위 5개 전자책 대신 상위 10개 전자책을 원한다고 가정해 보겠습니다. 명령줄에서 *NUM* 변수를 설정하고 Drake를 다시 실행할 수 있습니다.

```{bash, eval=FALSE}
$ NUM=10 drake -w 02.drake
다음 단계가 순서대로 실행됩니다.
  1: ../../data/top-10 <- ../../data/top.html [출력 누락]
확인하시겠습니까? [y/n] y
동시성 1로 1단계 실행 중...

--- 1. 실행 중 (출력 누락): ../../data/top-10 <- ../../data/top.html
--- 1: ../../data/top-10 <- ../../data/top.html -> 0.02초 만에 완료
완료 (1단계 실행됨).
```

보시다시피 첫 번째 단계의 출력이 이미 충족되었으므로 Drake는 이제 두 번째 단계만 실행하면 됩니다. 다시 말하지만 HTML 파일을 다운로드하는 것은 큰 문제가 아니지만 10GB 상당의 데이터를 처리하는 경우 어떤 의미가 있는지 상상할 수 있습니까?

## 특정 대상 다시 빌드

프로젝트 구텐베르크의 상위 100개 전자책 목록은 매일 변경됩니다. Drake 워크플로를 다시 실행하면 이 목록이 포함된 HTML이 다시 다운로드되지 않는 것을 확인했습니다. 다행히 Drake를 사용하면 특정 단계를 다시 실행하여 이 HTML 파일을 업데이트할 수 있습니다.

```{bash, eval=FALSE}
$ drake -w 02.drake '=top.html'
```

다시 실행할 단계를 지정하기 위해 출력 파일 이름을 사용하는 것보다 더 편리한 방법이 있습니다. 단계의 입력과 출력 모두에 소위 *태그*를 추가할 수 있습니다. 태그는 "%"로 시작합니다. 명령줄에서 쉽게 지정할 수 있도록 짧고 설명적인 태그 이름을 선택하는 것이 좋습니다. 첫 번째 단계에 *%html* 태그를 추가하고 두 번째 단계에 *%filter* 태그를 추가해 보겠습니다.

```
NUM:=5
BASE=data/

top.html, %html <- [-timecheck]
    curl -s 'http://www.gutenberg.org/browse/scores/top' > $OUTPUT

top-$[NUM], %filter <- top.html
    < $INPUT grep -E '^<li>' |
    head -n $[NUM] |
    sed -E "s/.*ebooks\/([0-9]+)\">([^<]+)<.*/\\1,\\2/" > $OUTPUT
```

이제 *%html* 태그를 지정하여 첫 번째 단계를 다시 빌드할 수 있습니다.

```{bash, eval=FALSE}
$ drake -w 03.drake '=%html'
```

## 논의

명령줄의 장점 중 하나는 데이터를 가지고 놀 수 있다는 것입니다. 다양한 명령을 쉽게 실행하고 다양한 데이터 파일을 처리할 수 있습니다. 매우 대화형이고 반복적인 프로세스입니다. 잠시 후 원하는 결과를 얻기 위해 어떤 단계를 거쳤는지 잊어버리기 쉽습니다. 따라서 가끔씩 단계를 문서화하는 것이 매우 중요합니다. 이렇게 하면 귀하 또는 동료 중 한 명이 잠시 후 프로젝트를 다시 시작할 때 동일한 단계를 실행하여 동일한 결과를 다시 생성할 수 있습니다.

모든 명령을 하나의 bash 스크립트에 넣는 것은 최적이 아니라는 것을 보여주었습니다. 데이터 워크플로를 관리하기 위한 명령줄 도구로 Drake를 사용할 것을 제안했습니다. 실행 예제를 사용하여 단계와 단계 간의 종속성을 정의하는 방법을 보여주었습니다. 변수와 태그를 사용하는 방법도 설명했습니다.

데이터를 가지고 놀고 다른 모든 것을 잊는 것보다 더 재미있는 것은 없습니다. 하지만 Drake 워크플로를 통해 수행한 작업을 기록하는 것이 가치가 있다는 것을 믿어야 합니다. 삶을 더 쉽게 만들 뿐만 아니라 데이터 워크플로를 단계별로 생각하기 시작할 것입니다. 시간이 지남에 따라 확장되는 명령줄 도구 상자와 마찬가지입니다. 시간이 지남에 따라 효율성이 향상되는 것처럼 Drake 워크플로도 마찬가지입니다. 정의한 단계가 많을수록 특정 단계를 자주 재사용할 수 있으므로 계속하기가 더 쉬워집니다. Drake에 익숙해지고 삶이 더 쉬워지기를 바랍니다.

Drake에 대해서는 겨우 표면만 긁었을 뿐입니다. 더 고급 기능 중 일부는 다음과 같습니다.

- 단계의 비동기 실행.
- 인라인 Python 및 R 코드 지원.
- HDFS S3에서 데이터 업로드 및 다운로드.

## 추가 자료

* Factual. 2014. “Drake.” <a href="https://github.com/Factual/drake" class="uri">https://github.com/Factual/drake</a>.
