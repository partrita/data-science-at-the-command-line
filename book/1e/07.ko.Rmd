# 데이터 탐색 {#chapter-7-exploring-data}

이제 데이터를 획득하고 정제했으므로 OSEMN 모델의 세 번째 단계인 데이터 탐색을 계속할 수 있습니다. 그 모든 힘든 작업 끝에 (이미 깨끗한 데이터가 주변에 있지 않았다면!) 이제 재미있는 시간입니다.

탐색은 데이터에 익숙해지는 단계입니다. 데이터에서 가치를 추출하려면 데이터에 익숙해지는 것이 필수적입니다. 예를 들어 데이터에 어떤 종류의 기능이 있는지 알면 어떤 기능을 더 탐색할 가치가 있고 어떤 기능을 사용하여 궁금한 점에 답할 수 있는지 알 수 있습니다.

데이터 탐색은 세 가지 관점에서 수행할 수 있습니다. 첫 번째 관점은 데이터와 해당 속성을 검사하는 것입니다. 여기서 우리는 예를 들어 원시 데이터가 어떻게 생겼는지, 데이터 세트에 데이터 포인트가 몇 개 있는지, 데이터 세트에 어떤 종류의 기능이 있는지 알고 싶습니다.

데이터를 탐색할 수 있는 두 번째 관점은 기술 통계를 계산하는 것입니다. 이 관점은 개별 기능에 대해 자세히 알아보는 데 유용합니다. 이 관점의 한 가지 장점은 출력이 종종 간결하고 텍스트로 되어 있어 명령줄에 인쇄할 수 있다는 것입니다.

세 번째 관점은 데이터 시각화를 만드는 것입니다. 이 관점에서 여러 기능이 상호 작용하는 방식에 대한 통찰력을 얻을 수 있습니다. 명령줄에 인쇄할 수 있는 시각화를 만드는 방법을 설명합니다. 그러나 시각화는 그래픽 사용자 인터페이스에 표시하는 데 가장 적합합니다. 기술 통계에 비해 시각화의 장점은 더 유연하고 훨씬 더 많은 정보를 전달할 수 있다는 것입니다.

## 개요

이 장에서는 다음을 수행하는 방법을 배웁니다.

- 데이터와 해당 속성을 검사합니다.
- 기술 통계를 계산합니다.
- 명령줄 내부 및 외부에서 데이터 시각화를 만듭니다.

## 데이터 및 해당 속성 검사

이 섹션에서는 데이터 세트와 해당 속성을 검사하는 방법을 보여줍니다. 곧 나올 시각화 및 모델링 기술은 데이터가 표 형식일 것으로 예상하므로 데이터가 CSV 형식이라고 가정합니다. 필요한 경우 [5장](#chapter-5-scrubbing-data)에서 설명한 기술을 사용하여 데이터를 CSV로 변환할 수 있습니다.

간단하게 하기 위해 데이터에 헤더가 있다고 가정합니다. 첫 번째 하위 섹션에서는 이것이 사실인지 여부를 결정합니다. 헤더가 있다는 것을 알게 되면 다음 질문에 계속 답할 수 있습니다.

- 데이터 세트에 데이터 포인트와 기능이 몇 개 있습니까?
- 원시 데이터는 어떻게 생겼습니까?
- 데이터 세트에 어떤 종류의 기능이 있습니까?
- 이러한 기능 중 일부를 범주형 또는 요인으로 처리할 수 있습니까?

### 헤더 여부, 여기 있습니다

파일에 헤더가 있는지 확인하려면 처음 몇 줄을 인쇄하면 됩니다.

    $ #? [echo]
    $ head file.csv | csvlook

그런 다음 첫 번째 줄이 실제로 헤더인지 아니면 이미 첫 번째 데이터 포인트인지 결정하는 것은 사용자에게 달려 있습니다. 데이터 세트에 헤더가 없거나 헤더에 줄 바꿈이 포함된 경우 [5장](#chapter-5-scrubbing-data)으로 돌아가서 수정하는 것이 가장 좋습니다.

### 모든 데이터 검사

원시 데이터를 검사하려면 `cat` 명령줄 도구를 사용하지 않는 것이 가장 좋습니다. `cat`은 모든 데이터를 한 번에 화면에 인쇄하기 때문입니다. 자신의 속도로 원시 데이터를 검사하려면 `-S` 명령줄 인수가 있는 `less` [@less]를 사용하는 것이 좋습니다.

    $ #? [echo]
    $ less -S file.csv

`-S` 명령줄 인수는 긴 줄이 터미널에 맞지 않을 때 줄 바꿈되지 않도록 합니다. 대신 `less`를 사용하면 가로로 스크롤하여 나머지 줄을 볼 수 있습니다. `less`의 장점은 전체 파일을 메모리에 로드하지 않아 큰 파일을 보는 데 좋다는 것입니다. `less`에 들어가면 `<Space>`를 눌러 전체 화면을 아래로 스크롤할 수 있습니다. 가로 스크롤은 `<Left>` 및 `<Right>`를 눌러 수행합니다. 파일의 시작과 끝으로 이동하려면 각각 `g`와 `G`를 누릅니다. `less`를 종료하려면 `q`를 누릅니다. 더 많은 키 바인딩은 man 페이지를 참조하십시오.

데이터 세트를 보기 좋게 서식 지정하려면 `csvlook`을 추가할 수 있습니다.

    $ #? [echo]
    $ < file.csv csvlook | less -S

안타깝게도 `csvlook`은 열 너비를 결정하기 위해 전체 파일을 메모리에 읽어야 합니다. 따라서 매우 큰 파일을 검사하려면 하위 집합을 가져오거나(예: `sample` 사용) 기다려야 할 수 있습니다.

### 기능 이름 및 데이터 유형

데이터 세트에 대한 통찰력을 얻으려면 기능 이름을 인쇄하고 연구하는 것이 유용합니다. 결국 기능 이름은 기능의 의미를 나타낼 수 있습니다. 이를 위해 다음 `sed` 표현식을 사용할 수 있습니다.

    $ < data/iris.csv sed -e 's/,/\n/g;q'

이 기본 명령은 파일이 쉼표로 구분된다고 가정합니다. 참고로 이 명령을 자주 사용하려는 경우 *.bashrc* 파일에 예를 들어 *names*라는 함수를 정의할 수 있습니다.

```{example, name=""}
```
```{bash, eval=FALSE}
names () { sed -e 's/,/\n/g;q'; }
```

그런 다음 다음과 같이 사용할 수 있습니다.

```{bash, eval=FALSE}
$ < data/investments.csv names
company_permalink
company_name
company_category_list
company_market
company_country_code
company_state_code
company_region
company_city
investor_permalink
investor_name
investor_category_list
investor_market
investor_country_code
investor_state_code
investor_region
investor_city
funding_round_permalink
funding_round_type
funding_round_code
funded_at
funded_month
funded_quarter
funded_year
raised_amount_usd
```

열 이름을 인쇄하는 것 이상으로 한 단계 더 나아갈 수 있습니다. 열 이름 외에도 각 열에 어떤 유형의 값이 포함되어 있는지 아는 것이 매우 유용합니다. 데이터 유형의 예로는 문자열, 숫자 값 또는 날짜가 있습니다. 다음과 같은 장난감 데이터 세트가 있다고 가정해 보겠습니다.

```{bash, eval=FALSE}
$ < data/datatypes.csv csvlook
|-----+--------+-------+----------+------------------+------------+----------|
|  a  | b      | c     | d        | e                | f          | g        |
|-----+--------+-------+----------+------------------+------------+----------|
|  2  | 0.0    | FALSE | "Yes!"   | 2011-11-11 11:00 | 2012-09-08 | 12:34    |
|  42 | 3.1415 | TRUE  | Oh, good | 2014-09-15       | 12/6/70    | 0:07 PM  |
|  66 |        | False | 2198     |                  |            |          |
|-----+--------+-------+----------+------------------+------------+----------|
```

[5장](#chapter-5-scrubbing-data)에서 CSV 데이터에서 직접 SQL 쿼리를 실행하기 위해 `csvsql`을 이미 사용했습니다. 명령줄 인수가 전달되지 않으면 이 데이터를 실제 데이터베이스에 삽입하는 데 필요한 SQL 문을 생성합니다. 유추된 열 유형이 무엇인지 검사하기 위해 출력을 사용할 수도 있습니다.

```{bash, eval=FALSE}
csvsql data/datatypes.csv
CREATE TABLE datatypes (
        a INTEGER NOT NULL,
        b FLOAT,
        c BOOLEAN NOT NULL,
        d VARCHAR(8) NOT NULL,
        e DATETIME,
        f DATE,
        g TIME,
        CHECK (c IN (0, 1))
);
```

다양한 SQL 데이터 유형이 무엇을 의미하는지에 대한 개요를 제공합니다. 열에 데이터 유형 뒤에 *NOT NULL* 문자열이 인쇄되어 있으면 해당 열에는 누락된 값이 없습니다.

+-----------------------+-----------------------+-----------------------+
| 유형                  | Python                | SQL                   |
+=======================+=======================+=======================+
| 문자열                | unicode               | VARCHAR               |
+-----------------------+-----------------------+-----------------------+
| 부울                  | bool                  | BOOLEAN               |
+-----------------------+-----------------------+-----------------------+
| 정수                  | int                   | INTEGER               |
+-----------------------+-----------------------+-----------------------+
| 실수                  | float                 | FLOAT                 |
+-----------------------+-----------------------+-----------------------+
| 날짜                  | datetime.date         | DATE                  |
+-----------------------+-----------------------+-----------------------+
| 시간                  | datetime.time         | TIME                  |
+-----------------------+-----------------------+-----------------------+
| 날짜 및 시간          | datetime.datetime     | DATETIME              |
+-----------------------+-----------------------+-----------------------+

: Python 대 SQL 데이터 유형

### 고유 식별자, 연속 변수 및 요인

각 기능의 데이터 유형을 아는 것만으로는 충분하지 않습니다. 각 기능이 무엇을 나타내는지 아는 것도 필수적입니다. 도메인에 대한 지식이 있으면 매우 유용하지만 데이터 자체에서 아이디어를 얻을 수도 있습니다.

문자열과 정수 모두 고유 식별자이거나 범주를 나타낼 수 있습니다. 후자의 경우 시각화에 색상을 할당하는 데 사용할 수 있습니다. 정수가 예를 들어 우편 번호를 나타내는 경우 평균을 계산하는 것은 의미가 없습니다.

기능을 고유 식별자 또는 범주형 변수(또는 R 용어로 요인)로 처리해야 하는지 확인하려면 특정 열의 고유 값 수를 계산할 수 있습니다.

```{bash, eval=FALSE}
$ cat data/iris.csv | csvcut -c species | body "sort | uniq | wc -l"
species
3
```

또는 `csvkit`의 일부인 `csvstat` [@csvstat]을 사용하여 각 열의 고유 값 수를 얻을 수 있습니다.

```{bash, eval=FALSE}
$ csvstat data/investments2.csv --unique
  1. company_permalink: 27342
  2. company_name: 27324
  3. company_category_list: 8759
  4. company_market: 443
  5. company_country_code: 150
  6. company_state_code: 147
  7. company_region: 1079
  8. company_city: 3305
  9. investor_permalink: 11176
 10. investor_name: 11135
 11. investor_category_list: 468
 12. investor_market: 134
 13. investor_country_code: 111
 14. investor_state_code: 80
 15. investor_region: 549
 16. investor_city: 1198
 17. funding_round_permalink: 41790
 18. funding_round_type: 13
 19. funding_round_code: 15
 20. funded_at: 3595
 21. funded_month: 295
 22. funded_quarter: 121
 23. funded_year: 34
 24. raised_amount_usd: 6143
```

고유 값 수가 행 수에 비해 적으면 해당 기능은 실제로 범주형 기능(예: *funding\_round\_type*)으로 처리될 수 있습니다. 숫자가 행 수와 같으면 고유 식별자(예: *company\_permalink*)일 수 있습니다.

## 기술 통계 계산

### csvstat

명령줄 도구 `csvstat`은 많은 정보를 제공합니다. 각 기능(열)에 대해 다음을 보여줍니다.

- Python 용어의 데이터 유형(Python과 SQL 데이터 유형 비교는 표 7-1 참조).
- 누락된 값(null)이 있는지 여부.
- 고유 값의 수.
- 해당 기능에 적합한 경우 다양한 기술 통계(최대값, 최소값, 합계, 평균, 표준 편차 및 중앙값).

다음과 같이 `csvstat`을 호출합니다.

```{bash, eval=FALSE}
$ csvstat data/datatypes.csv
  1. a
        <type 'int'>
        Nulls: False
        Values: 2, 66, 42
  2. b
        <type 'float'>
        Nulls: True
        Values: 0.0, 3.1415
  3. c
        <type 'bool'>
        Nulls: False
        Unique values: 2
        5 most frequent values:
                False:  2
                True:   1
  4. d
        <type 'unicode'>
        Nulls: False
        Values: 2198, "Yes!", Oh, good
  5. e
        <type 'datetime.datetime'>
        Nulls: True
        Values: 2011-11-11 11:00:00, 2014-09-15 00:00:00
  6. f
        <type 'datetime.date'>
        Nulls: True
        Values: 2012-09-08, 1970-12-06
  7. g
        <type 'datetime.time'>
        Nulls: True
        Values: 12:34:00, 12:07:00

Row count: 3
```

이것은 매우 장황한 출력을 제공합니다. 더 간결한 출력을 원하면 통계 인수 중 하나를 지정하십시오.

- `--max` (최대값)
- `--min` (최소값)
- `--sum` (합계)
- `--mean` (평균)
- `--median` (중앙값)
- `--stdev` (표준 편차)

- `--nulls` (열에 null이 포함되어 있는지 여부)
- `--unique` (고유 값)
- `--freq` (빈번한 값)
- `--len` (최대 값 길이)

예를 들면 다음과 같습니다.

```{bash, eval=FALSE}
$ csvstat data/datatypes.csv --null
  1. a: False
  2. b: True
  3. c: False
  4. d: False
  5. e: True
  6. f: True
  7. g: True
```

`-c` 명령줄 인수를 사용하여 기능의 하위 집합을 선택할 수 있습니다. 이것은 정수와 열 이름을 모두 허용합니다.

```{bash, eval=FALSE}
$ csvstat data/investments2.csv -c 2,13,19,24
  2. company_name
        <type 'unicode'>
        Nulls: True
        Unique values: 27324
        5 most frequent values:
                Aviir:  13
                Galectin Therapeutics:  12
                Rostima:        12
                Facebook:       11
                Lending Club:   11
        Max length: 66
 13. investor_country_code
        <type 'unicode'>
        Nulls: True
        Unique values: 111
        5 most frequent values:
                USA:    20806
                GBR:    2357
                DEU:    946
                CAN:    893
                FRA:    737
        Max length: 15
 19. funding_round_code
        <type 'unicode'>
        Nulls: True
        Unique values: 15
        5 most frequent values:
                a:      7529
                b:      4776
                c:      2452
                d:      1042
                e:      384
        Max length: 10
 24. raised_amount_usd
        <type 'int'>
        Nulls: True
        Min: 0
        Max: 3200000000
        Sum: 359891203117
        Mean: 10370010.1748
        Median: 3250000
        Standard Deviation: 38513119.1802
        Unique values: 6143
        5 most frequent values:
                10000000:       1159
                1000000:        1074
                5000000:        1066
                2000000:        875
                3000000:        820

Row count: 41799
```

`csvsql`과 마찬가지로 `csvstat`은 데이터 유형을 결정하기 위해 휴리스틱을 사용하므로 항상 올바르게 파악하지 못할 수 있습니다. 이전 하위 섹션에서 설명한 대로 항상 수동 검사를 수행하는 것이 좋습니다. 또한 유형은 문자열이나 정수일 수 있으며 사용 방법에 대해서는 아무것도 알려주지 않습니다.

좋은 추가 기능으로 `csvstat`은 맨 끝에 데이터 포인트(행) 수를 출력합니다. 값 내부의 줄 바꿈과 쉼표는 올바르게 처리됩니다. 관련 줄만 보려면 `tail`을 사용할 수 있습니다.

    $ csvstat data/iris.csv | tail -n 1

데이터 포인트의 실제 수만 보려면 예를 들어 다음 `sed` 표현식을 사용하여 숫자를 추출할 수 있습니다.

    $ csvstat data/iris.csv | sed -rne '${s/^([^:]+): ([0-9]+)$/\2/;p}'

### Rio를 사용하여 명령줄에서 R 사용

이 섹션에서는 통계 프로그래밍 환경 R을 중심으로 한 작고 편리한 래퍼인 `Rio`라는 명령줄 도구를 소개합니다. Rio가 무엇을 하고 왜 존재하는지 설명하기 전에 R 자체에 대해 약간 이야기해 보겠습니다.

R은 데이터를 분석하고 시각화를 만드는 매우 강력한 통계 소프트웨어 패키지입니다. 해석된 프로그래밍 언어이며 광범위한 패키지 모음이 있으며 명령줄과 유사하게 데이터를 가지고 놀 수 있는 자체 REPL(Read-Eval-Print-Loop)을 제공합니다. 안타깝게도 R은 명령줄과 상당히 분리되어 있습니다. 시작하면 별도의 환경에 있게 됩니다. R은 데이터를 파이프로 입력할 수 없고 지정할 수 있는 한 줄짜리도 지원하지 않으므로 명령줄과 잘 어울리지 않습니다.

예를 들어 *tips.csv*라는 CSV 파일이 있고 팁 비율을 계산하고 결과를 저장하고 싶다고 가정해 보겠습니다. R에서 이를 수행하려면 먼저 R을 시작합니다.

    $ #? [echo]
    $ R

그런 다음 다음 명령을 실행합니다.

```r
> tips <- read.csv('tips.csv', header = T, sep = ',', stringsAsFactors = F)
> tips.percent <- tips$tip / tips$bill * 100
> cat(tips.percent, sep = '\n', file = 'percent.csv')
> q("no")
```

그런 다음 명령줄에서 저장된 파일 *percent.csv*로 계속 진행할 수 있습니다. 특별히 달성하려는 것과 관련된 명령은 하나뿐이라는 점에 유의하십시오. 다른 명령은 필요한 상용구입니다. 간단한 작업을 수행하기 위해 이 상용구를 입력하는 것은 번거롭고 작업 흐름을 방해합니다. 때로는 데이터에 한두 가지만 수행하고 싶을 수 있습니다. R의 강력한 기능을 활용하고 명령줄에서 사용할 수 있다면 좋지 않을까요?

이것이 `Rio`가 등장하는 이유입니다. Rio라는 이름은 *R 입력/출력*을 의미하며, 명령줄에서 R을 필터로 사용할 수 있도록 하기 때문입니다. CSV 데이터를 `Rio`로 파이프하고 실행하려는 R 명령을 지정하기만 하면 됩니다. 이전과 동일한 작업을 수행하지만 이제 `Rio`를 사용합니다.

    $ < data/tips.csv Rio -e 'df$tip / df$bill * 100' | head -n 10

`Rio`는 세미콜론으로 구분된 여러 R 명령을 실행할 수 있습니다. 따라서 입력 데이터에 *percent*라는 열을 추가하려면 다음을 수행할 수 있습니다.

    $ < data/tips.csv Rio -e 'df$percent <- df$tip / df$bill * 100; df' | head

이러한 작은 한 줄짜리는 `Rio`가 모든 상용구를 처리하기 때문에 가능합니다. 이를 위해 명령줄을 사용하고 R의 강력한 기능을 한 줄짜리로 캡처할 수 있다는 것은 환상적입니다. 특히 명령줄에서 계속 작업하고 싶다면 더욱 그렇습니다. `Rio`는 입력 데이터가 헤더가 있는 CSV 형식이라고 가정합니다. (`-n` 명령줄 인수를 지정하면 `Rio`는 첫 번째 행을 헤더로 간주하지 않고 기본 열 이름을 만듭니다.) 내부적으로 `Rio`는 파이프된 데이터를 임시 CSV 파일에 쓰고 다음을 수행하는 스크립트를 만듭니다.

- 필요한 라이브러리를 가져옵니다.
- CSV 파일을 데이터 프레임으로 로드합니다.
- 필요한 경우 `ggplot2` 객체를 생성합니다(이에 대한 자세한 내용은 다음 섹션 참조).
- 지정된 명령을 실행합니다.

- 마지막 명령의 결과를 표준 출력으로 인쇄합니다.

따라서 이제 R로 데이터 세트에 한두 가지 작업을 수행하려면 한 줄짜리로 지정하고 명령줄에서 계속 작업할 수 있습니다. R에 대해 이미 가지고 있는 모든 지식을 이제 명령줄에서 사용할 수 있습니다. `Rio`를 사용하면 이 장의 뒷부분에서 볼 수 있듯이 정교한 시각화도 만들 수 있습니다.

Rio는 필터로 사용할 필요가 없으므로 출력이 반드시 CSV 형식일 필요는 없습니다. 다음을 계산할 수 있습니다.

    $ < data/iris.csv Rio -e 'mean(df$sepal_length)'
    $ < data/iris.csv Rio -e 'sd(df$sepal_length)'
    $ < data/iris.csv Rio -e 'sum(df$sepal_length)'

5개의 요약 통계를 계산하려면 다음을 수행합니다.

```{bash, eval=FALSE}
$ < iris.csv Rio -e 'summary(df$sepal_length)'
   최소값. 1사분위수.  중앙값    평균 3사분위수.    최대값.
  4.300   5.100   5.800   5.843   6.400   7.900
```

분포의 대칭성을 나타내는 왜도와 분포의 뾰족함을 나타내는 첨도를 계산할 수도 있지만, 이 경우 `moments` 패키지가 설치되어 있어야 합니다.

    $ #? [echo]
    $ < data/iris.csv Rio -e 'skewness(df$sepal_length)'
    $ < data/iris.csv Rio -e 'kurtosis(df$petal_width)'

두 기능 간의 상관 관계:

```{bash, eval=FALSE}
$ < tips.csv Rio -e 'cor(df$bill, df$tip)'
0.6757341
```

또는 상관 행렬:

```{bash, eval=FALSE}
$ < data/tips.csv csvcut -c bill,tip | Rio -f cor | csvlook
|--------------------+--------------------|
|  bill              | tip                |
|--------------------+--------------------|
|  1                 | 0.675734109211365  |
|  0.675734109211365 | 1                  |
|--------------------+--------------------|
```

명령줄 인수 `-f`를 사용하면 데이터 프레임 `df`에 적용할 함수를 지정할 수 있습니다. 이 경우 `-e cor(df)`와 동일합니다.

`Rio`를 사용하여 줄기 그림 [@Tukey1977]을 만들 수도 있습니다.

    $ < data/iris.csv Rio -e 'stem(df$sepal_length)'

## 시각화 만들기

이 섹션에서는 명령줄에서 시각화를 만드는 방법을 설명합니다. Gnuplot과 ggplot이라는 두 가지 다른 소프트웨어 패키지를 살펴볼 것입니다. 먼저 두 패키지를 모두 소개합니다. 그런 다음 두 가지를 모두 사용하여 여러 가지 다른 유형의 시각화를 만드는 방법을 보여줍니다.

### Gnuplot 및 Feedgnuplot 소개

이 장에서 설명하는 첫 번째 시각화 생성 소프트웨어 패키지는 Gnuplot입니다. Gnuplot은 1986년부터 사용되었습니다. 다소 오래되었음에도 불구하고 시각화 기능은 상당히 광범위합니다. 따라서 제대로 설명하기는 불가능합니다. @Janert2009의 *Gnuplot in Action*을 포함하여 다른 좋은 자료가 있습니다.

유연성(및 고풍스러운 표기법)을 보여주기 위해 Gnuplot 웹사이트(<http://gnuplot.sourceforge.net/demo/histograms.6.gnu>)에서 복사한 예제 \@ref(exm:script-gnuplot)를 고려하십시오.

```{example script-gnuplot, name="Gnuplot을 사용하여 히스토그램 만들기"}
```
```
# set terminal pngcairo  transparent enhanced font "arial,10" fontscale 1.0 size
# set output 'histograms.6.png'
set border 3 front linetype -1 linewidth 1.000
set boxwidth 0.75 absolute
set style fill   solid 1.00 border lt -1
set grid nopolar
set grid noxtics nomxtics ytics nomytics noztics nomztics \
 nox2tics nomx2tics noy2tics nomy2tics nocbtics nomcbtics
set grid layerdefault   linetype 0 linewidth 1.000,  linetype 0 linewidth 1.000
set key outside right top vertical Left reverse noenhanced autotitles columnhead
set style histogram columnstacked title  offset character 0, 0, 0
set datafile missing '-'
set style data histograms
set xtics border in scale 1,0.5 nomirror norotate  offset character 0, 0, 0 auto
set xtics  norangelimit
set xtics   ()
set ytics border in scale 0,0 mirror norotate  offset character 0, 0, 0 autojust
set ztics border in scale 0,0 nomirror norotate  offset character 0, 0, 0 autoju
set cbtics border in scale 0,0 mirror norotate  offset character 0, 0, 0 autojus
set rtics axis in scale 0,0 nomirror norotate  offset character 0, 0, 0 autojust
set title "북유럽으로부터의 이민\n(누적 막대 히스토그램)"
set xlabel "출신 국가"
set ylabel "10년 단위 이민자 수"
set yrange [ 0.00000 : * ] noreverse nowriteback
i = 23
plot 'immigration.dat' using 6 ti col, '' using 12 ti col,      '' using 13 ti c
```

이것은 80자로 잘렸습니다. 위 스크립트는 다음 이미지를 생성합니다.

```{r, echo=FALSE, fig.cap="Gnuplot으로 그린 이민 도표", fig.align="center"}
knitr::include_graphics("images/histograms.6.png")
```

Gnuplot은 두 가지 이유로 우리가 사용해 온 대부분의 명령줄 도구와 다릅니다. 첫째, 명령줄 인수 대신 스크립트를 사용합니다. 둘째, 출력은 항상 파일에 기록되고 표준 출력으로 인쇄되지 않습니다.

Gnuplot이 오랫동안 사용되어 온 한 가지 큰 장점과 이 책에 포함시킨 주된 이유는 명령줄 **용** 시각화를 생성할 수 있다는 것입니다. 즉, 그래픽 사용자 인터페이스(GUI) 없이도 터미널에 출력을 인쇄할 수 있습니다. 그렇더라도 스크립트를 설정해야 합니다.

다행히 Gnuplot용 스크립트를 설정하는 데 도움이 되는 `feedgnuplot` [@feedgnuplot]이라는 명령줄 도구가 있습니다. `feedgnuplot`은 명령줄 인수를 통해 완전히 구성할 수 있습니다. 또한 표준 입력에서 읽습니다. `ggplot2`를 소개한 후 `feedgnuplot`을 사용하여 몇 가지 시각화를 만들 것입니다.

여기서 언급하고 싶은 `feedgnuplot`의 한 가지 훌륭한 기능은 스트리밍 데이터를 플로팅할 수 있다는 것입니다. 다음은 임의의 입력 데이터를 기반으로 지속적으로 업데이트되는 플롯의 스냅샷입니다.

```{bash, eval=FALSE}
$ while true; do echo $RANDOM; done | sample -d 10 | feedgnuplot --stream \
> --terminal 'dumb 80,25' --lines --xlen 10

  30000 ++-----+------------+-------------+-------------+------------+-----++
        |      +            *             +             +            +      |
        |      :            **            :             *******      :      *
  25000 ++.................*.*..........................*.....*............+*
        |      :           *: *           :            *:      *     :     *|
        |      :           *: *           :            *:      *     :     *|
        |      :          * :  *          :           * :       *    :    * |
  20000 ++................*....*......................*.........*.........*++
        |      :          * :   *         :          *  :       *    :    * |
        |      :         *  :   *         :          *  :        *   :   *  |
  15000 ++....**.........*.......*..................*............*.......*.++
        | **** :*        *  :    *        :         *   :         *  :   *  |
        **     :*        *  :     *      ****      *    :         *  :  *   |
  10000 ++.......*......*.........*....**....*.....*..............*.....*..++
        |      :  *     *   :      * **   :   *   *     :          * : *    |
        |      :   *    *   :      **     :    ** *     :          * : *    |
        |      :   *   *    :             :      *      :          * : *    |
   5000 ++..........*..*.........................*..................*.*....++
        |      :     * *    :             :             :           *:*     |
        |      +     **     +             +             +            *      |
      0 ++-----+------*-----+-------------+-------------+------------*-----++
              2350         2352          2354          2356         2358
```

### ggplot2 소개

시각화를 만드는 더 현대적인 소프트웨어 패키지는 R의 그래픽 문법 구현인 ggplot입니다 [@Wickham2009].

그래픽 문법과 합리적인 기본값 덕분에 `ggplot2` 명령은 매우 짧고 표현력이 풍부한 경향이 있습니다. `Rio`를 통해 사용하면 명령줄에서 시각화를 만드는 매우 편리한 방법입니다.

표현력을 보여주기 위해 `Rio`의 도움을 받아 위에서 gnuplot으로 생성된 히스토그램 플롯을 다시 만들 것입니다. `Rio`는 데이터 세트가 쉼표로 구분되기를 기대하고 `ggplot2`는 데이터가 *긴* 형식으로 되어 있기를 기대하므로 먼저 데이터를 약간 정제하고 변환해야 합니다.

```{bash, eval=FALSE}
$ < data/immigration.dat sed -re '/^#/d;s/\t/,/g;s/,-,/,0,/g;s/Region/'\
> 'Period/' | tee data/immigration.csv | head | cut -c1-80
Period,Austria,Hungary,Belgium,Czechoslovakia,Denmark,France,Germany,Greece,Irel
1891-1900,234081,181288,18167,0,50231,30770,505152,15979,388416,651893,26758,950
1901-1910,668209,808511,41635,0,65285,73379,341498,167519,339065,2045877,48262,1
1911-1920,453649,442693,33746,3426,41983,61897,143945,184201,146181,1109524,4371
1921-1930,32868,30680,15846,102194,32430,49610,412202,51084,211234,455315,26948,
1931-1940,3563,7861,4817,14393,2559,12623,144058,9119,10973,68028,7150,4740,3960
1941-1950,24860,3469,12189,8347,5393,38809,226578,8973,19789,57661,14860,10100,1
1951-1960,67106,36637,18575,918,10984,51121,477765,47608,43362,185491,52277,2293
1961-1970,20621,5401,9192,3273,9201,45237,190796,85969,32966,214111,30606,15484,
```

`sed` 표현식은 세미콜론으로 구분된 네 부분으로 구성됩니다.

1.  *\#*로 시작하는 줄을 제거합니다.

2.  탭을 쉼표로 변환합니다.

3.  대시(누락된 값)를 0으로 변경합니다.

4.  기능 이름 *Region*을 *Period*로 변경합니다.

그런 다음 `csvcut`을 사용하여 중요한 열만 선택하고 R 패키지 `reshape2`의 일부인 `melt` 함수와 `Rio`를 사용하여 데이터를 넓은 형식에서 긴 형식으로 변환합니다.

```{bash, eval=FALSE}
$ < data/immigration.csv csvcut -c Period,Denmark,Netherlands,Norway,\
> Sweden | Rio -re 'melt(df, id="Period", variable.name="Country", '\
> 'value.name="Count")' | tee data/immigration-long.csv | head | csvlook
|------------+-------------+--------|
|  기간      | 국가        | 횟수   |
|------------+-------------+--------|
|  1891-1900 | Denmark     | 50231  |
|  1901-1910 | Denmark     | 65285  |
|  1911-1920 | Denmark     | 41983  |
|  1921-1930 | Denmark     | 32430  |
|  1931-1940 | Denmark     | 2559   |
|  1941-1950 | Denmark     | 5393   |
|  1951-1960 | Denmark     | 10984  |
|  1961-1970 | Denmark     | 9201   |
|  1891-1900 | Netherlands | 26758  |
|------------+-------------+--------|
```

이제 `Rio`를 다시 사용할 수 있지만 `ggplot2` 시각화를 만드는 표현식을 사용합니다.

```{bash, eval=FALSE}
$ < data/immigration-long.csv Rio -ge 'g + geom_bar(aes(Country, Count,'\
> ' fill=Period), stat="identity") + scale_fill_brewer(palette="Set1") '\
> '+ labs(x="출신 국가", y="10년 단위 이민자 수", title='\
> '"북유럽으로부터의 이민\n(누적 막대 히스토그램)")' | display
```

```{r, echo=FALSE, fig.cap="Rio와 ggplot2로 그린 이민 도표", fig.align="center"}
knitr::include_graphics("images/rio-immigration.png")
```

`-g` 명령줄 인수는 Rio가 `ggplot2` 패키지를 로드해야 함을 나타냅니다. 출력은 PNG 형식의 이미지입니다. ImageMagick [@display]의 일부인 `display`를 통해 PNG 이미지를 보거나 출력을 PNG 파일로 리디렉션할 수 있습니다. 원격 터미널에 있는 경우 그래픽을 볼 수 없을 것입니다. 이에 대한 해결 방법은 특정 디렉터리에서 웹 서버를 시작하는 것입니다.

```{bash, eval=FALSE}
$ python -m SimpleHTTPServer 8000
```

포트(이 경우 8000)에 액세스할 수 있는지 확인하십시오. 웹 서버가 시작된 디렉터리에 PNG 이미지를 저장하면 브라우저에서 <http://localhost:8000/file.png>로 이미지에 액세스할 수 있습니다.

### 히스토그램

`Rio` 사용:

```{bash, eval=FALSE}
$ < data/tips.csv Rio -ge 'g+geom_histogram(aes(bill))' | display
```

```{r, echo=FALSE, fig.cap="히스토그램", fig.align="center"}
knitr::include_graphics("images/rio-histogram.png")
```

`feedgnuplot` 사용:

```{bash, eval=FALSE}
< data/tips.csv csvcut -c bill | feedgnuplot --terminal 'dumb 80,25' \
--histogram 0 --with boxes --ymin 0 --binwidth 1.5 --unset grid --exit



  25 ++----+------+-----+--***-+-----+------+-----+------+-----+------+----++
     +     +      +     +*** * +     +      +     +      +     +      +     +
     |                   * * *                                              |
     |               *** * * *                                              |
  20 ++              * * * * *                                             ++
     |            **** * * * *                                              |
     |            * ** *** * * ***                                          |
     |            * ** * * * * * *                                          |
  15 ++           * ** * * * * * *                                         ++
     |            * ** * * * * * *                                          |
     |            * ** * * * * * *                                          |
     |            * ** * * * * * * ***                                      |
  10 ++           * ** * * * *** *** *                                     ++
     |            * ** * * * * * * * *                                      |
     |          *** ** * * * * * * * ***** ***                              |
     |          * * ** * * * * * * * * * *** *                              |
   5 ++       *** * ** * * * * * * * * * * * *   ***                       ++
     |        * * * ** * * * * * * * * * * * * *** *                        |
     |        * * * ** * * * * * * * * * * * *** * ********   *** ***       |
     +  ***+*** * * ** *+* * * * * * * * * *+* * *+** * *+* ***+* * * ***   +
   0 ++-***+***********************************************-*****-***-***--++
     0     5      10    15     20    25     30    35     40    45     50    55
```

### 막대 그래프

`Rio` 사용:

```{bash, eval=FALSE}
$ < data/tips.csv Rio -ge 'g+geom_bar(aes(factor(size)))' | display
```

```{r, echo=FALSE, fig.cap="막대 그래프", fig.align="center"}
knitr::include_graphics("images/rio-barplot.png")
```

`feedgnuplot` 사용:

```{bash, eval=FALSE}
$ < data/tips.csv | csvcut -c size | header -d | feedgnuplot --terminal \
> 'dumb 80,25' --histogram 0  --with boxes --unset grid --exit



  160 ++--------+----***********----+---------+---------+---------+--------++
      +         +    *    +    *    +         +         +         +         +
  140 ++             *         *                                           ++
      |              *         *                                            |
      |              *         *                                            |
  120 ++             *         *                                           ++
      |              *         *                                            |
  100 ++             *         *                                           ++
      |              *         *                                            |
      |              *         *                                            |
   80 ++             *         *                                           ++
      |              *         *                                            |
   60 ++             *         *                                           ++
      |              *         *                                            |
      |              *         *                                            |
   40 ++             *         *********************                       ++
      |              *         *         *         *                        |
   20 ++             *         *         *         *                       ++
      |              *         *         *         *                        |
      +    ***********    +    *    +    *    +    *********************    +
    0 ++---*************************************************************---++
      0         1         2         3         4         5         6         7
```

### 밀도 플롯

`Rio` 사용:

```{bash, eval=FALSE}
$ < data/tips.csv Rio -ge 'g+geom_density(aes(tip / bill * 100, fill=sex), '\
> 'alpha=0.3) + xlab("percent")' | display
```

```{r, echo=FALSE, fig.cap="밀도 플롯", fig.align="center"}
knitr::include_graphics("images/rio-densityplot.png")
```

`feedgnuplot`은 밀도 플롯을 생성할 수 없으므로 히스토그램을 생성하는 것이 가장 좋습니다.

### 상자 그림

`Rio` 사용:

```{bash, eval=FALSE}
$ < data/tips.csv Rio -ge 'g+geom_boxplot(aes(time, bill))' | display
```

```{r, echo=FALSE, fig.cap="상자 그림", fig.align="center"}
knitr::include_graphics("images/rio-boxplot.png")
```

안타깝게도 `feedgnuplot`으로는 상자 그림을 그릴 수 없습니다.

### 산점도

`Rio` 사용:

```{bash, eval=FALSE}
$ < data/tips.csv Rio -ge 'g+geom_point(aes(bill, tip, color=time))' | display
```

```{r, echo=FALSE, fig.cap="산점도", fig.align="center"}
knitr::include_graphics("images/rio-scatterplot.png")
```

`feedgnuplot` 사용:

```{bash, eval=FALSE}
< data/tips.csv csvcut -c bill,tip | tr , ' ' | header -d | feedgnuplot \
--terminal 'dumb 80,25' --points --domain --unset grid --exit --style 'pt' '14'



  10 ++----+------+-----+------+-----+------+-----+------+-----+------+A---++
     +     +      +     +      +     +      +     +      +     +      +     +
   9 ++                                                            A       ++
     |                                                                      |
   8 ++                                                                    ++
     |                                                  A                   |
     |                                                                      |
   7 ++                                          A                 A       ++
     |                             A     A                                  |
   6 ++                              A    A    A                           ++
     |                             A        A                               |
   5 ++       A                 A A   A A   AA A  AA      A  A     A       ++
     |                                A       A    A     A                  |
   4 ++          A     A  AAAA AAA A  A A  A          A                    ++
     |                A   AAAAA AAA AA            A             A           |
     |              A  AAAAAAA AA A A  AA   A AA                            |
   3 ++           A   AAAAAAAAAAA A A    AA           AA A                 ++
     |              AAAAAAA AA  A A A     A                   A             |
   2 ++        AA AAAAAAAAA A  A  A AA  A A A                              ++
     +     +   AAAAAAAA +A   AA+     + A    +     +      +     +      +     +
   1 ++--A-+A-A---+--AA-+--A---+-----+------+--A--+------+-----+------+----++
     0     5      10    15     20    25     30    35     40    45     50    55
```

### 선 그래프

```{bash, eval=FALSE}
$ < data/immigration-long.csv Rio -ge 'g+geom_line(aes(x=Period, '\
> 'y=Count, group=Country, color=Country)) + theme(axis.text.x = '\
> 'element_text(angle = -45, hjust = 0))' | display
```

```{r, echo=FALSE, fig.cap="선 그래프", fig.align="center"}
knitr::include_graphics("images/rio-linegraph.png")
```

```{bash, eval=FALSE}
$ < data/immigration.csv | csvcut -c Period,Denmark,Netherlands,Norway,Sweden |
> header -d | tr , ' ' | feedgnuplot --terminal 'dumb 80,25' --lines \
> --autolegend --domain --legend 0 "Denmark" --legend 1 "Netherlands" \
> --legend 2 "Norway" --legend 3 "Sweden" --xlabel "기간" --unset grid --exit



  250000 ++-----%%%-------+-------+--------+-------+-------+--------+------++
         +  %%%% + %      +       +        +       +       + 덴마크+****** +
         |%%        %                                    네덜란드 ###### |
         |          %                                         노르웨이 $$$$$$ |
  200000 ++          %                                        스웨덴 %%%%%%++
         |        $   %                                                     |
         |       $ $   %                                                    |
         |      $   $  %                                                    |
  150000 ++   $$     $  %                                                  ++
         |   $        $  %                                                  |
         |  $          $  %                                                 |
  100000 ++$            $ %                                                ++
         |$              $ %%%%%%%%%%                                       |
         |                $          %                                      |
         |    ***********  $$$$$$$$$$$%                                     |
   50000 +****  #########**           $%%                  #######         ++
         |  ####           ********    $$%              ###       ##        |
         |##                       ******##           ##$$$$$$$$$$$$#       |
         +       +        +       +      **###########$$*************       +
       0 ++------+--------+-------+--------*************---+--------+------++
        1890    1900     1910    1920     1930    1940    1950     1960    1970
                                       기간
```

### 요약

`Rio`와 `ggplot2`, `feedgnuplot`과 Gnuplot 모두 장점이 있습니다. `Rio`로 생성된 플롯은 분명히 훨씬 더 품질이 좋습니다. 명령줄에 적합한 일관된 구문을 제공합니다. 유일한 단점은 출력을 명령줄에서 볼 수 없다는 것입니다. 이것이 `feedgnuplot`이 유용할 수 있는 부분입니다. 각 플롯은 대략 동일한 명령줄 인수를 갖습니다. 따라서 명령줄에서 플롯을 생성하는 것을 훨씬 더 쉽게 만드는 작은 Bash 스크립트를 만드는 것은 간단할 것입니다. 결국 명령줄은 해상도가 매우 낮으므로 많은 유연성이 필요하지 않습니다.

## 추가 자료

* Wickham, Hadley. 2009. <em>ggplot2: 데이터 분석을 위한 우아한 그래픽</em>. Springer.
* Janert, Philipp K. 2009. <em>Gnuplot in Action</em>. Manning Publications.
* Tukey, John W. 1977. <em>탐색적 데이터 분석</em>. Pearson.
