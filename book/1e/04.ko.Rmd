# 재사용 가능한 명령줄 도구 만들기 {#chapter-4-creating-reusable-command-line-tools}

이 책 전체에서 우리는 기본적으로 한 줄에 맞는 많은 명령과 파이프라인을 사용합니다. 그것들을 한 줄짜리라고 부릅시다. 한 줄짜리로 복잡한 작업을 수행할 수 있다는 것이 명령줄을 강력하게 만드는 것입니다. 전통적인 프로그램을 작성하는 것과는 매우 다른 경험입니다.

어떤 작업은 한 번만 수행하고 어떤 작업은 더 자주 수행합니다. 어떤 작업은 매우 구체적이고 다른 작업은 일반화될 수 있습니다. 특정 한 줄짜리를 정기적으로 반복해야 할 것으로 예상되거나 알아차리면 자체 명령줄 도구로 만드는 것이 좋습니다. 따라서 한 줄짜리와 명령줄 도구 모두 용도가 있습니다. 기회를 인식하려면 연습과 기술이 필요합니다. 명령줄 도구의 장점은 전체 한 줄짜리를 기억할 필요가 없고 다른 파이프라인에 포함하면 가독성이 향상된다는 것입니다.

그러나 프로그래밍 언어로 작업하는 것의 이점은 코드가 파일에 있다는 것입니다. 즉, 해당 코드를 쉽게 재사용할 수 있습니다. 코드에 매개변수가 있으면 유사한 패턴을 따르는 문제에도 적용할 수 있습니다.

명령줄 도구는 두 가지 장점을 모두 가지고 있습니다. 명령줄에서 사용할 수 있고, 매개변수를 허용하며, 한 번만 만들면 됩니다. 이 장에서는 두 가지 방법으로 재사용 가능한 명령줄 도구를 만드는 데 익숙해질 것입니다. 첫째, 이러한 한 줄짜리를 재사용 가능한 명령줄 도구로 바꾸는 방법을 설명합니다. 명령에 매개변수를 추가하여 프로그래밍 언어가 제공하는 것과 동일한 유연성을 추가할 수 있습니다. 그런 다음 프로그래밍 언어로 작성한 코드에서 재사용 가능한 명령줄 도구를 만드는 방법을 보여줍니다. UNIX 철학을 따르면 코드를 완전히 다른 언어로 작성되었을 수 있는 다른 명령줄 도구와 결합할 수 있습니다. Python, R, Java라는 세 가지 프로그래밍 언어에 중점을 둘 것입니다.

재사용 가능한 명령줄 도구를 만들면 장기적으로 더 효율적이고 생산적인 데이터 과학자가 될 수 있다고 생각합니다. 이전에 발생했던 문제에 적용할 수 있는 기존 도구를 가져올 수 있는 자신만의 데이터 과학 도구 상자를 점차적으로 구축합니다. 한 줄짜리 또는 기존 코드를 명령줄 도구로 바꿀 기회를 인식하려면 연습이 필요합니다.

한 줄짜리를 셸 스크립트로 바꾸려면 일부 셸 스크립팅을 사용해야 합니다. 셸 스크립팅의 개념 중 작은 하위 집합의 유용성만 보여줄 것입니다. 이 하위 집합에는 변수, 조건문, 루프가 포함됩니다. 셸 스크립팅에 대한 완전한 과정은 자체 책이 필요하므로 이 책의 범위를 벗어납니다. 셸 스크립팅에 대해 더 자세히 알고 싶다면 @Robbins2005의 *Classic Shell Scripting*을 권장합니다.

## 개요

이 장에서는 다음을 수행하는 방법을 배웁니다.

- 한 줄짜리를 셸 스크립트로 변환합니다.
- 기존 Python, R, Java 코드를 명령줄의 일부로 만듭니다.

## 한 줄짜리를 셸 스크립트로 변환

이 섹션에서는 한 줄짜리를 재사용 가능한 명령줄 도구로 바꾸는 방법을 설명합니다. 다음과 같은 한 줄짜리가 있다고 가정해 보겠습니다.

```{bash, eval=FALSE}
$ curl -s http://www.gutenberg.org/files/76/76-0.txt |
> tr '[:upper:]' '[:lower:]' |
> grep -oE '\w+' |
> sort |
> uniq -c |
> sort -nr |
> head -n 10
   6441 and
   5082 the
   3666 i
   3258 a
   3022 to
   2567 it
   2086 t
   2044 was
   1847 he
   1778 of
```

요컨대, 출력에서 짐작할 수 있듯이 이 한 줄짜리는 *허클베리 핀의 모험* 전자책 버전의 상위 10개 단어를 반환합니다. 다음과 같이 이를 수행합니다.

- `curl`을 사용하여 전자책 다운로드.
- `tr` [@tr]을 사용하여 전체 텍스트를 소문자로 변환.
- `grep` [@grep]을 사용하여 모든 단어를 추출하고 각 단어를 별도의 줄에 배치.
- `sort` [@sort]를 사용하여 이러한 단어를 알파벳순으로 정렬.

- `uniq` [@uniq]를 사용하여 모든 중복 항목을 제거하고 각 단어가 목록에 나타나는 횟수를 계산합니다.
- `sort`를 사용하여 이 고유한 단어 목록을 개수별로 내림차순으로 정렬합니다.
- `head`를 사용하여 상위 10개 줄(즉, 단어)만 유지합니다.

```{block2, type="rmdtip"}

이 한 줄짜리에 사용된 각 명령줄 도구는 man 페이지를 제공합니다. 따라서 예를 들어 `grep`에 대해 더 자세히 알고 싶다면 명령줄에서 `man grep`을 실행할 수 있습니다. 명령줄 도구 `tr`, `grep`, `uniq`, `sort`는 다음 장에서 더 자세히 설명합니다.
```

이 한 줄짜리를 한 번만 실행하는 데는 아무런 문제가 없습니다. 그러나 프로젝트 구텐베르크의 모든 전자책의 상위 10개 단어를 원한다고 상상해 보십시오. 또는 뉴스 웹사이트의 상위 10개 단어를 시간 단위로 원한다고 상상해 보십시오. 이러한 경우 이 한 줄짜리를 더 큰 것의 일부가 될 수 있는 별도의 빌딩 블록으로 사용하는 것이 가장 좋습니다. 이 한 줄짜리에 매개변수 측면에서 약간의 유연성을 추가하고 싶기 때문에 셸 스크립트로 바꿀 것입니다.

Bash를 셸로 사용하므로 스크립트는 프로그래밍 언어 Bash로 작성됩니다. 이를 통해 한 줄짜리를 시작점으로 삼고 점차 개선할 수 있습니다. 이 한 줄짜리를 재사용 가능한 명령줄 도구로 바꾸려면 다음 6단계를 안내합니다.

1.  한 줄짜리를 파일에 복사하여 붙여넣습니다.

2.  실행 권한을 추가합니다.

3.  소위 쉬뱅을 정의합니다.

4.  고정된 입력 부분을 제거합니다.

5.  매개변수를 추가합니다.

6.  선택적으로 PATH를 확장합니다.

### 1단계: 복사 및 붙여넣기

첫 번째 단계는 새 파일을 만드는 것입니다. 즐겨 사용하는 텍스트 편집기를 열고 한 줄짜리를 복사하여 붙여넣습니다. 파일 이름을 *top-words-1.sh*로 지정하고( *1*은 새 명령줄 도구를 향한 첫 번째 단계를 의미) *\~/book/ch04* 디렉터리에 넣지만 다른 이름과 위치를 선택할 수 있습니다. 파일 내용은 예제 \@ref(exm:top-words-1)과 유사해야 합니다.

```{example top-words-1, name="~/book/ch04/top-words-1.sh"}
```
```{bash, eval=FALSE}
curl -s http://www.gutenberg.org/files/76/76-0.txt |
tr '[:upper:]' '[:lower:]' | grep -oE '\w+' | sort |
uniq -c | sort -nr | head -n 10
```

셸 스크립트를 만들고 있음을 명확히 하기 위해 파일 확장자 *.sh*를 사용하고 있습니다. 그러나 명령줄 도구에는 확장자가 필요하지 않습니다. 실제로 명령줄 도구에는 거의 확장자가 없습니다.

```{block2, type="rmdtip"}

다음은 멋진 작은 명령줄 트릭입니다. 명령줄에서 `!!`는 이전 명령으로 대체됩니다. 따라서 이전 명령에 슈퍼유저 권한이 필요하다는 것을 알게 되면 `sudo !!` [@sudo]를 실행할 수 있습니다. 그리고 이전 명령을 복사하여 붙여넣지 않고 파일에 저장하려면 `echo "!!" > scriptname`을 실행할 수 있습니다. 명령에 따옴표가 있으면 항상 작동하지 않을 수 있으므로 실행하기 전에 *scriptname* 파일의 내용을 확인하여 정확성을 확인하십시오.
```

이제 `bash` [@bash]를 사용하여 파일의 명령을 해석하고 실행할 수 있습니다.

```{bash, eval=FALSE}
$ bash book/ch04/top-words-1.sh
   6441 and
   5082 the
   3666 i
   3258 a
   3022 to
   2567 it
   2086 t
   2044 was
   1847 he
   1778 of
```

이렇게 하면 이미 한 줄짜리를 입력하는 수고를 덜 수 있습니다. 파일 자체를 실행할 수 없으므로 아직 진정한 명령줄 도구가 아닙니다. 다음 단계에서 변경해 보겠습니다.

### 2단계: 실행 권한 추가

파일을 직접 실행할 수 없는 이유는 올바른 액세스 권한이 없기 때문입니다. 특히 사용자로서 파일을 실행할 수 있는 권한이 있어야 합니다. 이 섹션에서는 파일의 액세스 권한을 변경합니다.

```{block2, type="rmdnote"}

단계 간의 차이점을 비교하기 위해 `cp top-words-{1,2}.sh`를 사용하여 파일을 *top-words-2.sh*로 복사합니다. 원하는 경우 동일한 파일로 계속 작업할 수 있습니다.
```

파일의 액세스 권한을 변경하려면 *change mode*를 의미하는 `chmod` [@chmod]라는 명령줄 도구를 사용해야 합니다. 특정 파일의 파일 모드 비트를 변경합니다. 다음 명령은 사용자인 귀하에게 *top-words-2.sh*를 실행할 수 있는 권한을 부여합니다.

```{bash, eval=FALSE}
$ cd ~/book/ch04/
$ chmod u+x top-words-2.sh
```

명령줄 인수 `u+x`는 세 글자로 구성됩니다. (1) `u`는 파일을 소유한 사용자(파일을 만들었으므로 귀하)에 대한 권한을 변경하려고 함을 나타냅니다. (2) `+`는 권한을 추가하려고 함을 나타냅니다. (3) `x`는 실행 권한을 나타냅니다. 이제 두 파일의 액세스 권한을 살펴보겠습니다.

```{bash, eval=FALSE}
$ ls -l top-words-{1,2}.sh
-rw-rw-r-- 1 vagrant vagrant 145 7월 20일 23:33 top-words-1.sh
-rwxrw-r-- 1 vagrant vagrant 143 7월 20일 23:34 top-words-2.sh
```

첫 번째 열은 각 파일의 액세스 권한을 보여줍니다. *top-words-2.sh*의 경우 `-rwxrw-r--`입니다. 첫 번째 문자 `-`는 파일 유형을 나타냅니다. `-`는 일반 파일을 의미하고 `d`는 디렉터리를 의미합니다. 다음 세 문자 `rwx`는 파일을 소유한 사용자에 대한 액세스 권한을 나타냅니다. `r`과 `w`는 각각 읽기와 쓰기를 의미합니다. (보시다시피 *top-words-1.sh*에는 `x` 대신 `-`가 있으며 이는 해당 파일을 실행할 수 없음을 의미합니다.) 다음 세 문자 `rw-`는 파일을 소유한 그룹의 모든 구성원에 대한 액세스 권한을 나타냅니다. 마지막으로 열의 마지막 세 문자 `r--`는 다른 모든 사용자에 대한 액세스 권한을 나타냅니다.

이제 다음과 같이 파일을 실행할 수 있습니다.

```{bash, eval=FALSE}
$ book/ch04/top-words-2.sh
   6441 and
   5082 the
   3666 i
   3258 a
   3022 to
   2567 it
   2086 t
   2044 was
   1847 he
   1778 of
```

실행 파일과 동일한 디렉터리에 있는 경우 다음과 같이 실행해야 합니다.

```{bash, eval=FALSE}
$ cd ~/book/ch04
$ ./top-words-2.sh
```

*top-words-1.sh*와 같이 올바른 액세스 권한이 없는 파일을 실행하려고 하면 다음과 같은 오류 메시지가 표시됩니다.

```{bash, eval=FALSE}
$ ./top-words-1.sh
bash: ./top-words-1.sh: 권한 거부됨
```

### 3단계: 쉬뱅 정의

이미 파일을 자체적으로 실행할 수 있지만 파일에 소위 *쉬뱅*을 추가해야 합니다. 쉬뱅은 스크립트의 특수 줄로, 명령을 해석하는 데 사용할 실행 파일을 시스템에 지시합니다.

이 경우 명령을 해석하는 데 `bash`를 사용하려고 합니다. 예제 \@ref(exm:top-words-3)은 쉬뱅이 있는 *top-words-3.sh* 파일의 모양을 보여줍니다.

```{example top-words-3, name="~/book/ch04/top-words-3.sh"}
```
```{bash, eval=FALSE}
#!/usr/bin/env bash
curl -s http://www.gutenberg.org/files/76/76-0.txt |
tr '[:upper:]' '[:lower:]' | grep -oE '\w+' | sort |
uniq -c | sort -nr | head -n 10
```

쉬뱅이라는 이름은 처음 두 문자, 즉 해시(쉬)와 느낌표(뱅)에서 유래했습니다. 이전 단계에서처럼 생략하는 것은 좋지 않습니다. 그러면 스크립트의 동작이 정의되지 않기 때문입니다. 우리가 사용하고 있는 Bash 셸은 기본적으로 실행 파일 */bin/sh*를 사용합니다. 다른 셸에는 다른 기본값이 있을 수 있습니다.

때로는 *!/usr/bin/bash* 또는 *!/usr/bin/python*(다음 섹션에서 볼 수 있듯이 Python의 경우) 형식의 쉬뱅이 있는 스크립트를 접하게 될 것입니다. 일반적으로 작동하지만 `bash` 또는 `python` [@python] 실행 파일이 */usr/bin*과 다른 위치에 설치된 경우 스크립트가 더 이상 작동하지 않습니다. 여기에 제시된 형식, 즉 *!/usr/bin/env bash* 및 *!/usr/bin/env python*을 사용하는 것이 좋습니다. `env` [@env] 실행 파일은 `bash`와 `python`이 설치된 위치를 알고 있기 때문입니다. 요컨대 `env`를 사용하면 스크립트의 이식성이 향상됩니다.

### 4단계: 고정 입력 제거

이제 명령줄에서 실행할 수 있는 유효한 명령줄 도구가 있습니다. 하지만 이보다 더 잘할 수 있습니다. 명령줄 도구를 더 재사용 가능하게 만들 수 있습니다. 파일의 첫 번째 명령은 `curl`이며, 가장 많이 사용되는 상위 10개 단어를 얻으려는 텍스트를 다운로드합니다. 따라서 데이터와 작업이 하나로 결합됩니다.

다른 전자책이나 다른 텍스트에서 가장 많이 사용되는 상위 10개 단어를 얻으려면 어떻게 해야 할까요? 입력 데이터는 도구 자체 내에 고정되어 있습니다. 데이터를 명령줄 도구와 분리하는 것이 좋습니다.

명령줄 도구 사용자가 텍스트를 제공한다고 가정하면 일반적으로 적용 가능해집니다. 따라서 해결책은 스크립트에서 `curl` 명령을 단순히 제거하는 것입니다. *top-words-4.sh*라는 업데이트된 스크립트는 예제 \@ref(exm:top-words-4)를 참조하십시오.

```{example top-words-4, name="~/book/ch04/top-words-4.sh"}
```
```{bash, eval=FALSE}
#!/usr/bin/env bash
tr '[:upper:]' '[:lower:]' | grep -oE '\w+' | sort |
uniq -c | sort -nr | head -n 10
```

스크립트가 `tr`과 같이 표준 입력에서 데이터가 필요한 명령으로 시작하면 명령줄 도구에 제공된 입력을 사용하기 때문에 이것이 작동합니다. 예를 들면 다음과 같습니다.

    $ cat data/finn.txt | top-words-4.sh

```{block2, type="rmdtip"}

스크립트에서는 그렇게 하지 않았지만 데이터 저장에도 동일한 원칙이 적용됩니다. 일반적으로 사용자가 처리하도록 하는 것이 좋습니다. 물론 명령줄 도구를 자신의 프로젝트에만 사용하려는 경우 특정할 수 있는 한계는 없습니다.
```

### 5단계: 매개변수화

명령줄 도구를 더욱 재사용 가능하게 만들기 위해 수행할 수 있는 단계가 하나 더 있습니다. 바로 매개변수입니다. 명령줄 도구에는 `sort`의 `-nr` 및 `head`의 `-n 10`과 같이 여러 고정 명령줄 인수가 있습니다. 이전 인수는 고정된 상태로 유지하는 것이 가장 좋습니다. 그러나 `head` 명령에 다른 값을 허용하면 매우 유용할 것입니다. 이렇게 하면 최종 사용자가 출력할 가장 자주 사용되는 단어 수를 설정할 수 있습니다. 예제 \@ref(exm:top-words-5)는 `head`를 매개변수화한 경우 *top-words-5.sh* 파일의 모양을 보여줍니다.

```{example top-words-5, name="~/book/ch04/top-words-5.sh"}
```
```{bash, eval=FALSE}
#!/usr/bin/env bash
NUM_WORDS="$1"
tr '[:upper:]' '[:lower:]' | grep -oE '\w+' | sort |
uniq -c | sort -nr | head -n $NUM_WORDS
```

* 변수 *NUM\_WORDS*는 Bash의 특수 변수인 *\$1*의 값으로 설정됩니다. 이 변수는 명령줄 도구에 전달된 첫 번째 명령줄 인수의 값을 보유합니다. 아래 표에는 Bash가 제공하는 다른 특수 변수가 나열되어 있습니다.
* *\$NUM\_WORDS* 변수의 값을 사용하려면 그 앞에 달러 기호를 넣어야 합니다. 설정할 때는 달러 기호를 쓰지 않습니다.

```{block2, type="rmdtip"}

`head`의 인수로 *\$1*을 직접 사용하고 *NUM\_WORDS*와 같은 추가 변수를 만들지 않아도 됩니다. 그러나 스크립트가 더 크고 *\$2* 및 *\$3*과 같은 몇 가지 명령줄 인수가 더 있는 경우 명명된 변수를 사용하면 코드를 더 읽기 쉽게 만들 수 있습니다.
```

이제 텍스트에서 가장 많이 사용되는 상위 5개 단어를 보려면 다음과 같이 명령줄 도구를 호출합니다.

    $ cat data/finn.txt | top-words-5 5

사용자가 인수를 제공하지 않으면 *\$1*의 값, 따라서 *\$NUM\_WORDS*가 빈 문자열이 되므로 `head`가 오류 메시지를 반환합니다.

```{bash, eval=FALSE}
$ cat data/finn.txt | top-words-5
head: 옵션에 인수가 필요합니다 -- 'n'
자세한 내용은 'head --help'를 참조하십시오.
```

### 6단계: PATH 확장

이전 5단계를 거쳐 재사용 가능한 명령줄 도구 만들기를 마쳤습니다. 그러나 매우 유용할 수 있는 단계가 하나 더 있습니다. 이 선택적 단계에서는 어디에서나 명령줄 도구를 실행할 수 있도록 합니다.

현재 명령줄 도구를 실행하려면 해당 도구가 있는 디렉터리로 이동하거나 2단계에서 설명한 대로 전체 경로 이름을 포함해야 합니다. 명령줄 도구가 특정 프로젝트용으로 특별히 빌드된 경우에는 괜찮습니다. 그러나 명령줄 도구를 여러 상황에 적용할 수 있는 경우 Ubuntu와 함께 제공되는 명령줄 도구처럼 어디에서나 실행할 수 있으면 유용합니다.

이를 위해 Bash는 명령줄 도구를 찾을 위치를 알아야 합니다. *PATH*라는 환경 변수에 저장된 디렉터리 목록을 순회하여 이 작업을 수행합니다. 새로운 데이터 과학 도구 상자에서 *PATH*는 다음과 같습니다.

    $ echo $PATH | fold

디렉터리는 콜론으로 구분됩니다. 다음은 디렉터리 목록입니다.

    $ echo $PATH | tr ':' '\n'

*PATH*를 영구적으로 변경하려면 홈 디렉터리에 있는 *.bashrc* 또는 *.profile* 파일을 편집해야 합니다. 모든 사용자 지정 명령줄 도구를 하나의 디렉터리(예: *\~/tools*)에 넣으면 *PATH*를 한 번만 변경하면 됩니다. 보시다시피 데이터 과학 도구 상자에는 이미 */home/vagrant/.bin*이 *PATH*에 있습니다. 이제 더 이상 *./*를 추가할 필요 없이 파일 이름만 사용하면 됩니다. 또한 명령줄 도구가 어디에 있는지 더 이상 기억할 필요가 없습니다.

## Python 및 R로 명령줄 도구 만들기

이전 섹션에서 만든 명령줄 도구는 Bash로 작성되었습니다. (물론 Bash 언어의 모든 기능이 사용된 것은 아니지만 인터프리터는 여전히 `bash`였습니다.) 이제 아시다시피 명령줄은 언어에 구애받지 않으므로 명령줄 도구를 만드는 데 반드시 Bash를 사용할 필요는 없습니다.

이 섹션에서는 다른 프로그래밍 언어로도 명령줄 도구를 만들 수 있음을 보여줄 것입니다. 현재 데이터 과학 커뮤니티에서 가장 인기 있는 두 프로그래밍 언어인 Python과 R에 중점을 둘 것입니다. 두 언어에 대한 완전한 소개를 제공할 수 없으므로 Python 및/또는 R에 대한 어느 정도의 친숙도가 있다고 가정합니다. Java, Go, Julia와 같은 프로그래밍 언어는 명령줄 도구를 만들 때 유사한 패턴을 따릅니다.

Bash 대신 프로그래밍 언어로 명령줄 도구를 만드는 세 가지 주요 이유가 있습니다. 첫째, 명령줄에서 사용하고 싶은 기존 코드가 있을 수 있습니다. 둘째, 명령줄 도구가 100줄 이상의 코드를 포함하게 될 수 있습니다. 셋째, 명령줄 도구가 매우 빨라야 합니다.

이전 섹션에서 설명한 6단계는 다른 프로그래밍 언어로 명령줄 도구를 만드는 데에도 대략적으로 적용됩니다. 그러나 첫 번째 단계는 명령줄에서 복사하여 붙여넣는 것이 아니라 관련 코드를 새 파일에 복사하여 붙여넣는 것입니다. Python 및 R의 명령줄 도구는 쉬뱅 뒤에 인터프리터로 각각 `python` [@python] 및 `Rscript` [@R]를 지정해야 합니다.

Python과 R을 사용하여 명령줄 도구를 만들 때 특별한 주의가 필요한 두 가지 측면이 더 있으며 아래에서 설명합니다. 첫째, 셸 스크립트에는 자연스러운 표준 입력 처리를 Python과 R에서는 명시적으로 처리해야 합니다. 둘째, Python과 R로 작성된 명령줄 도구는 더 복잡한 경향이 있으므로 사용자에게 더 복잡한 명령줄 인수를 지정할 수 있는 기능도 제공하고 싶을 수 있습니다.

### 셸 스크립트 포팅

시작점으로 이전 셸 스크립트를 Python과 R 모두로 포팅하는 방법을 살펴보겠습니다. 즉, 표준 입력에서 가장 자주 사용되는 상위 단어를 제공하는 Python 및 R 코드는 무엇일까요? 이 작업을 셸 프로그래밍 언어가 아닌 다른 언어로 구현하는 것이 좋은 생각인지 여부는 중요하지 않습니다. 중요한 것은 Bash와 Python 및 R을 비교할 수 있는 좋은 기회를 제공한다는 것입니다.

먼저 두 파일 *top-words.py*와 *top-words.R*을 보여준 다음 셸 코드와의 차이점을 설명합니다. Python에서 코드는 예제 \@ref(exm:top-words-py)와 유사할 것입니다.

```{example top-words-py, name="~/book/ch04/top-words.py"}
```
```{python, eval=FALSE, python.reticulate = FALSE}
#!/usr/bin/env python
import re
import sys
from collections import Counter
num_words = int(sys.argv[1])
text = sys.stdin.read().lower()
words = re.split('\W+', text)
cnt = Counter(words)
for word, count in cnt.most_common(num_words):
    print "%7d %s" % (count, word)
```

```{block2, type="rmdnote"}

예제
\@ref(exm:top-words-py)
는 순수 Python을 사용합니다. 고급 텍스트 처리를 원하면 NLTK 패키지 [@Perkins2010]를 확인하는 것이 좋습니다. 많은 수치 데이터를 다룰 예정이라면 Pandas 패키지 [@McKinney2012]를 사용하는 것이 좋습니다.
```

그리고 R에서 코드는 예제 \@ref(exm:top-words-5)와 유사할 것입니다(Hadley Wickham 덕분입니다).

```{example top-words-5, name="~/book/ch04/top-words.R"}
```
```{r, eval=FALSE}
#!/usr/bin/env Rscript
n <- as.integer(commandArgs(trailingOnly = TRUE))
f <- file("stdin")
lines <- readLines(f)
words <- tolower(unlist(strsplit(lines, "\\W+")))
counts <- sort(table(words), decreasing = TRUE)
counts_n <- counts[1:n]
cat(sprintf("%7d %s\n", counts_n, names(counts_n)), sep = "")
close(f)
```

세 가지 구현(즉, Bash, Python, R) 모두 동일한 개수로 동일한 상위 5개 단어를 반환하는지 확인해 보겠습니다.

```{bash, eval=FALSE}
$ < data/76.txt top-words.sh 5
   6441 and
   5082 the
   3666 i
   3258 a
   3022 to
$ < data/76.txt top-words.py 5
   6441 and
   5082 the
   3666 i
   3258 a
   3022 to
$ < data/76.txt top-words.R 5
   6441 and
   5082 the
   3666 i
   3258 a
   3022 to
```

훌륭합니다! 물론 출력 자체는 그다지 흥미롭지 않습니다. 흥미로운 점은 여러 가지 접근 방식으로 동일한 작업을 수행할 수 있다는 관찰입니다. 접근 방식 간의 차이점을 살펴보겠습니다.

첫째, 코드 양의 차이가 즉시 분명합니다. 이 특정 작업의 경우 Python과 R 모두 Bash보다 훨씬 많은 코드가 필요합니다. 이는 일부 작업의 경우 명령줄을 사용하는 것이 더 낫다는 것을 보여줍니다. 다른 작업의 경우 프로그래밍 언어를 사용하는 것이 더 나을 수 있습니다. 명령줄 경험이 많아질수록 어떤 접근 방식을 언제 사용해야 하는지 인식하기 시작할 것입니다. 모든 것이 명령줄 도구인 경우 작업을 하위 작업으로 나누고 Bash 명령줄 도구를 예를 들어 Python 명령줄 도구와 결합할 수도 있습니다. 당면한 작업에 가장 적합한 접근 방식을 사용하십시오.

### 표준 입력에서 스트리밍 데이터 처리

이전 두 코드 조각에서 Python과 R 모두 전체 표준 입력을 한 번에 읽었습니다. 명령줄에서 대부분의 명령줄 도구는 데이터를 스트리밍 방식으로 다음 명령줄 도구로 파이프합니다. (`sort` 및 `awk` [@awk]와 같이 표준 출력에 데이터를 쓰기 전에 전체 데이터가 필요한 몇 가지 명령줄 도구가 있습니다.) 즉, 이러한 명령줄 도구에 의해 파이프라인이 차단됩니다. 입력 데이터가 파일과 같이 유한한 경우에는 문제가 되지 않을 수 있습니다. 그러나 입력 데이터가 논스톱 스트림인 경우 이러한 차단 명령줄 도구는 쓸모가 없습니다.

다행히 Python과 R은 스트리밍 데이터 처리를 지원합니다. 예를 들어 줄 단위로 함수를 적용할 수 있습니다. 예제 \@ref(exm:stream-py)와 예제 \@ref(exm:stream-r)은 각각 Python과 R에서 이것이 어떻게 작동하는지 보여주는 두 가지 최소한의 예입니다.

```{example stream-py, name="~/book/ch04/stream.py"}
```
```{python, eval=FALSE, python.reticulate = FALSE}
#!/usr/bin/env python
from sys import stdin, stdout
while True:
    line = stdin.readline()
    if not line:
        break
    stdout.write("%d\n" % int(line)**2)
    stdout.flush()
```

```{example stream-r, name="~/book/ch04/stream.R"}
```
```{r, eval=FALSE}
#!/usr/bin/env Rscript
f <- file("stdin")
open(f)
while(length(line <- readLines(f, n = 1)) > 0) {
        write(as.integer(line)^2, stdout())
}
close(f)
```

## 추가 자료

* Docopt. 2014. “명령줄 인터페이스 설명 언어.” <a href="http://docopt.org" class="uri">http://docopt.org</a>.
* Robbins, Arnold, and Nelson H. F. Beebe. 2005. <em>클래식 셸 스크립팅</em>. O’Reilly Media.
* Peek, Jerry, Shelley Powers, Tim O’Reilly, and Mike Loukides. 2002. <em>유닉스 파워 툴</em>. 3rd Ed. O’Reilly Media.
* Perkins, Jacob. 2010. <em>Nltk 2.0을 사용한 Python 텍스트 처리 Cookbook</em>. Packt Publishing.
* McKinney, Wes. 2012. <em>데이터 분석을 위한 Python</em>. O’Reilly Media.
* Rossant, Cyrille. 2013. <em>대화형 컴퓨팅 및 데이터 시각화를 위한 Ipython 학습</em>. Packt Publishing.
* Wirzenius, Lars. 2013. “매뉴얼 페이지 작성.” <a href="http://liw.fi/manpages/" class="uri">http://liw.fi/manpages/</a>.
* Raymond, Eric Steven. 2014. “유닉스 철학의 기초.” <a href="http://www.faqs.org/docs/artu/ch01s06.html" class="uri">http://www.faqs.org/docs/artu/ch01s06.html</a>.
