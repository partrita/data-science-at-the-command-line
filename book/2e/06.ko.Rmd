---
suppress-bibliography: true
---

```{r console_start, include=FALSE}
console_start()
```

```{console setup_history, include=FALSE}
 export CHAPTER="06"
 export HISTFILE=/history/history_${CHAPTER}
 rm -f $HISTFILE
```


# Make를 사용한 프로젝트 관리 {#chapter-6-project-management-with-make}

이제까지 명령줄이 데이터 작업에 매우 편리한 환경이라는 점을 이해하셨기를 바랍니다.
명령줄로 작업한 결과 다음과 같은 점을 눈치채셨을 것입니다.

- 다양한 명령을 호출합니다.
- 다양한 디렉터리에서 작업합니다.
- 자신만의 명령줄 도구를 개발합니다.
- 많은 (중간) 파일을 얻고 생성합니다.

이것은 탐색적인 프로세스이므로 워크플로가 다소 혼란스러워져 수행한 작업을 추적하기 어려워집니다.
우리가 수행한 단계는 우리 자신이나 다른 사람이 재현할 수 있어야 한다는 것이 중요합니다.
얼마 전에 진행했던 프로젝트를 계속 진행할 때 어떤 명령을 어떤 디렉터리에서 어떤 파일에 대해 어떤 매개변수를 사용하여 어떤 순서로 실행했는지 잊어버렸을 가능성이 있습니다.
프로젝트를 공동 작업자와 공유하는 것이 얼마나 어려운지 상상해 보십시오.

`history` 명령의 출력을 뒤져 일부 명령을 복구할 수 있지만 물론 이것은 신뢰할 수 있는 방법이 아닙니다.
다소 나은 방법은 명령을 셸 스크립트에 저장하는 것입니다.
최소한 이렇게 하면 귀하와 귀하의 공동 작업자가 프로젝트를 재현할 수 있습니다.
그러나 셸 스크립트도 다음과 같은 이유로 최적이 아닌 방법입니다.

- 읽고 유지 관리하기 어렵습니다.
- 단계 간의 종속성이 불분명합니다.
- 매번 모든 단계가 실행되므로 비효율적이고 때로는 바람직하지 않습니다.

이것이 `make`가 정말 빛을 발하는 부분입니다 [@make]. `make`는 다음을 수행할 수 있는 명령줄 도구입니다.

- 입력 및 출력 종속성 측면에서 데이터 워크플로 단계를 공식화합니다.
- 워크플로의 특정 단계를 실행합니다.
- 인라인 코드를 사용합니다.
- 외부 소스에서 데이터를 저장하고 검색합니다.

```{block2, type="rmdnote"}
1판에서는 이 장에서 `make` 대신 `drake` [@drake]를 사용했습니다.
Drake는 데이터 작업에 대한 추가 기능이 있는 `make`의 후속 제품이 될 예정이었습니다.
안타깝게도 Drake는 2016년에 너무 많은 미해결 버그로 인해 제작자에 의해 포기되었습니다.
그래서 대신 `make`를 사용하기로 결정했습니다.
```

중요한 관련 주제는 *버전 관리*로, 프로젝트 변경 사항을 추적하고, 프로젝트를 서버에 백업하고, 다른 사람과 공동 작업하고, 문제가 발생했을 때 이전 버전을 검색할 수 있습니다.
버전 관리를 수행하는 인기 있는 명령줄 도구는 `git`[@git]입니다.
분산 버전 관리를 위한 온라인 서비스인 GitHub와 함께 자주 사용됩니다.
[이 책](https://github.com/jeroenjanssens/data-science-at-the-command-line)을 포함한 많은 오픈 소스 프로젝트가 GitHub에서 호스팅됩니다.
버전 관리 주제는 이 책의 범위를 벗어나지만, 특히 다른 사람과 공동 작업을 시작하면 이 주제를 살펴보는 것이 좋습니다.
이 장의 끝에서는 자세히 알아볼 수 있는 몇 가지 자료를 추천합니다.


## 개요

`make`로 데이터 워크플로를 관리하는 것이 이 장의 주요 주제입니다.
따라서 다음에 대해 배우게 됩니다.

- *Makefile*로 워크플로를 정의합니다.
- 입력 및 출력 종속성 측면에서 워크플로에 대해 생각합니다.
- 작업을 실행하고 대상을 빌드합니다.

```{console ls}
cd /data/ch06
l
```

이러한 파일을 가져오는 지침은 [2장](#chapter-2-getting-started)에 있습니다.
다른 모든 파일은 명령줄 도구를 사용하여 다운로드하거나 생성됩니다.


## Make 소개

`make`는 데이터와 해당 종속성을 중심으로 명령 실행을 구성합니다.
데이터 처리 단계는 별도의 텍스트 파일(워크플로)로 공식화됩니다.
각 단계에는 입력과 출력이 있을 수 있습니다.
`make`는 자동으로 해당 종속성을 해결하고 실행해야 하는 명령과 순서를 결정합니다.

즉, 예를 들어 10분이 걸리는 SQL 쿼리가 있는 경우 결과가 없거나 쿼리가 나중에 변경된 경우에만 실행하면 됩니다.
또한 특정 단계를 (재)실행하려는 경우 `make`는 해당 단계가 의존하는 단계만 다시 실행합니다.
이렇게 하면 많은 시간을 절약할 수 있습니다.

공식화된 워크플로를 사용하면 몇 주 후에 프로젝트를 쉽게 다시 시작하고 다른 사람들과 공동 작업할 수 있다는 이점이 있습니다. 특정 단계를 다시 실행해야 하거나 다른 프로젝트에서 재사용하고 싶을 때를 알 수 없으므로 이것이 일회성 프로젝트라고 생각하더라도 이 작업을 수행하는 것이 좋습니다.


## 작업 실행

기본적으로 `make`는 현재 디렉터리에서 *Makefile*이라는 구성 파일을 검색합니다.
*makefile*(소문자)로 이름을 지정할 수도 있지만, 더 일반적이고 디렉터리 목록의 맨 위에 표시되므로 파일을 *Makefile*로 지정하는 것이 좋습니다.
일반적으로 프로젝트당 하나의 구성 파일만 있습니다.
이 장에서는 다양한 구성 파일을 다루므로 각 파일에 *.make* 확장자를 가진 다른 파일 이름을 지정했습니다.
다음 *Makefile*로 시작하겠습니다.

```{console cp_numbers}
bat -A numbers.make
```

이 *Makefile*에는 *`numbers`*라는 *대상*이 하나 포함되어 있습니다.
*대상*은 작업과 같습니다.
일반적으로 만들려는 파일의 이름이지만 그보다 더 일반적일 수도 있습니다.
아래 줄인 *`seq 7`*은 *규칙*이라고 합니다.
규칙을 레시피로 생각하십시오. 대상을 빌드하는 방법을 지정하는 하나 이상의 명령입니다.

규칙 앞의 공백은 단일 탭 문자입니다.
`make`는 공백에 민감합니다.
일부 편집기는 **`TAB`** 키를 누를 때 공백을 삽입하며, 이를 소프트 탭이라고 하며 `make`가 오류를 생성하게 합니다.
다음 코드는 탭을 8개의 공백으로 확장하여 이를 보여줍니다.

```{console expand, callouts=c("-f", "top.")}
< numbers.make expand > spaces.make
bat -A spaces.make
make -f spaces.make
rm spaces.make
```
<1> 구성 파일 이름이 기본값인 *Makefile*이 아니므로 `-f` 옵션( `--makefile` 옵션의 약자)을 추가해야 합니다.
<2> 명령줄에서 찾을 수 있는 더 유용한 오류 메시지 중 하나입니다!

이제부터는 실제 사용과 더 일치하도록 적절한 파일 이름을 *Makefile*로 바꿀 것입니다.
따라서 `make`만 실행하면 다음과 같습니다.

```{console make_numbers}
cp numbers.make Makefile
make
```

그러면 `make`가 먼저 규칙 자체(*`seq 7`*)를 인쇄한 다음 규칙에서 생성된 출력을 인쇄하는 것을 볼 수 있습니다.
이 프로세스를 대상 *빌드*라고 합니다.
대상 이름을 지정하지 않으면 `make`가 *Makefile*에 지정된 첫 번째 대상을 빌드합니다.
그러나 실제로는 빌드하려는 대상을 가장 자주 지정하게 됩니다.

```{console make_numbers_again}
make numbers
```

```{block2, type="rmdnote"}
`make`는 원래 소스 코드 컴파일을 용이하게 하기 위해 만들어졌으며, 이는 *대상*, *규칙*, *빌드*와 같은 일부 용어를 설명합니다.
```

이 경우 실제로 아무것도 빌드하지 않습니다. 즉, 새 파일을 만들지 않습니다.
`make`는 *numbers*라는 파일을 찾지 못하므로 대상 `numbers`를 다시 *빌드*합니다.
다음 섹션에서 이에 대해 자세히 설명하겠습니다.

때로는 동일한 이름의 파일이 있는지 여부에 관계없이 빌드되는 대상이 유용할 수 있습니다.
프로젝트의 일부로 수행해야 하는 작업을 생각해 보십시오.
*Makefile*의 맨 위에 `.PHONY`라는 특수 대상을 사용하고 그 뒤에 가짜 대상의 이름을 사용하여 해당 대상을 가짜로 선언하는 것이 좋습니다.
다음은 가짜 대상 사용을 보여주는 *Makefile* 예제입니다.

```{console bat_tasks, callouts="latest"}
bat tasks.make
```
<1> *`$(pwd)`* 앞에 추가 달러 기호가 있습니다. 이는 `make`가 나중에 설명할 다양한 특수 변수를 참조하기 위해 단일 달러 기호를 사용하기 때문에 필요합니다.

위는 이 책을 작업하는 동안 사용하는 *Makefile*에서 가져온 것입니다.
`make`를 영광스러운 작업 실행기로 사용한다고 말할 수 있습니다.
이것이 `make`의 주요 목적은 아니지만 사용한 명령을 기억하거나 찾을 필요가 없으므로 여전히 많은 가치를 제공합니다.
대신 `make publish`를 입력하면 책의 최신 버전이 게시됩니다.
*Makefile*에 오래 실행되는 명령을 넣는 것은 완벽하게 괜찮습니다.

그리고 `make`는 우리를 위해 훨씬 더 많은 일을 할 수 있습니다!


## 실제 빌드

규칙의 출력이 *numbers*라는 파일에 기록되도록 *Makefile*을 수정해 보겠습니다.

```{console}
cp numbers-write.make Makefile
bat Makefile
make numbers
bat numbers
```

이제 `make`가 실제로 무언가를 빌드한다고 말할 수 있습니다.
또한 다시 실행하면 `make`가 대상 *`numbers`*가 최신이라고 보고하는 것을 볼 수 있습니다.

```{console}
make numbers
```

파일 *numbers*가 이미 존재하므로 대상 *`numbers`*를 다시 빌드할 필요가 없습니다.
`make`가 작업을 반복하지 않아 시간을 절약해 주므로 좋습니다.

`make`에서는 모든 것이 파일에 관한 것입니다.
그러나 `make`는 대상의 *이름*만 신경 쓴다는 점을 기억하십시오.
동일한 이름의 파일이 규칙에 의해 실제로 생성되는지 확인하지 않습니다.
네덜란드어로 "numbers"를 의미하는 *nummers*라는 파일에 쓰고 대상이 여전히 *`numbers`*라고 불린다면 `make`는 항상 이 대상을 빌드합니다. 반대로 파일 *numbers*가 자동화되었든 수동이든 다른 프로세스에 의해 생성된 경우 `make`는 여전히 해당 대상을 최신으로 간주합니다.

대상 이름을 확장하는 자동 변수 `$@`를 사용하여 일부 반복을 피할 수 있습니다.

```{console make_numbers_write_var}
cp numbers-write-var.make Makefile
bat Makefile
```

*numbers* 파일을 제거하고 `make`를 다시 호출하여 이것이 작동하는지 확인해 보겠습니다.

```{console bat_numbers}
rm numbers
make numbers
bat numbers
```

`make`가 대상을 다시 빌드하는 또 다른 이유는 해당 종속성이므로 다음에 이에 대해 논의하겠습니다.


## 종속성 추가

지금까지 격리된 상태로 존재하는 대상에 대해 살펴보았습니다.
일반적인 데이터 과학 워크플로에서는 많은 단계가 다른 단계에 의존합니다.
*Makefile*에서 종속성에 대해 제대로 이야기하려면 스타워즈 캐릭터에 대한 데이터 세트로 작업하는 두 가지 작업을 고려해 보겠습니다.

다음은 해당 데이터 세트의 발췌문입니다.

```{console}
curl -sL 'https://raw.githubusercontent.com/tidyverse/dplyr/master/data-raw/starwars.csv' |
xsv select name,height,mass,homeworld,species |
csvlook
```

첫 번째 작업은 가장 키가 큰 인간 10명을 계산합니다.

```{console, callouts=c("grep", "cut", "sort", "head")}
curl -sL 'https://raw.githubusercontent.com/tidyverse/dplyr/master/data-raw/starwars.csv' |
grep Human |
cut -d, -f 1,2 |
sort -t, -k2 -nr |
head
```
<1> *`Human`* 패턴을 포함하는 줄만 유지합니다.
<2> 처음 두 열을 추출합니다.
<3> 두 번째 열을 기준으로 줄을 역숫자 순서로 정렬합니다.
<4> 기본적으로 `head`는 처음 10줄을 인쇄합니다. `-n` 옵션으로 이를 재정의할 수 있습니다.

두 번째 작업은 종별 키 분포를 보여주는 상자 그림을 만듭니다(\@ref(fig:starwars-image) 참조).

```{console}
curl -sL 'https://raw.githubusercontent.com/tidyverse/dplyr/master/data-raw/starwars.csv' |
rush plot --x height --y species --geom boxplot > heights.png
display heights.png
```
```{r starwars-image, echo=FALSE, fig.cap="스타워즈 종별 키 분포", fig.align="center", out.width="90%"}
knitr::include_graphics("images/heights.png")
```

이 두 작업을 *Makefile*에 넣어 보겠습니다.
점진적으로 수행하는 대신 먼저 완전한 *Makefile*이 어떻게 생겼는지 보여준 다음 모든 구문을 단계별로 설명하겠습니다.

```{console}
cp starwars.make Makefile
bat Makefile
```

이 *Makefile*을 단계별로 살펴보겠습니다.
처음 세 줄은 `make` 자체와 관련된 일부 기본 설정을 변경하기 위한 것입니다.

1. 모든 규칙은 셸에서 실행되며 기본적으로 `sh`입니다. *`SHELL`* 변수를 사용하여 이를 `bash`와 같은 다른 셸로 변경할 수 있습니다. 이렇게 하면 for 루프와 같이 Bash가 제공하는 모든 것을 사용할 수 있습니다.
2. 기본적으로 규칙의 모든 줄은 셸로 개별적으로 전송됩니다. 특수 대상 *`.ONESHELL`*을 사용하면 이를 재정의하여 대상 *`top10`*에 대한 규칙이 작동하도록 할 수 있습니다.
3. *`.SHELLFLAGS`* 줄은 Bash를 더 엄격하게 만들며, 이는 [모범 사례](http://redsymbol.net/articles/unofficial-bash-strict-mode/)로 간주됩니다. 예를 들어 이 때문에 대상 *`top10`*에 대한 규칙의 파이프라인은 이제 오류가 발생하자마자 중지됩니다.

*`URL`*이라는 사용자 지정 변수를 정의합니다.
이것은 한 번만 사용되지만 이러한 종류의 설정을 쉽게 변경할 수 있도록 파일 시작 부분 근처에 이러한 정보를 넣는 것이 도움이 된다고 생각합니다.

특수 대상 *`.PHONY`*를 사용하면 파일로 표시되지 않는 대상을 나타낼 수 있습니다. 이 경우 대상 *`all`*과 *`top10`*이 해당됩니다. 이러한 대상은 이제 디렉터리에 동일한 이름의 파일이 있는지 여부에 관계없이 실행됩니다.

대상은 *`all`*, *`data`*, *`data/starwars.csv`*, *`top10`*, *`heights.png`* 다섯 가지입니다.
\@ref(fig:starwars-image)는 이러한 대상과 대상 간의 종속성에 대한 개요를 제공합니다.

```{r dependencies, echo=FALSE, fig.cap="대상 간 종속성", fig.align="center"}
knitr::include_graphics("images/dscl_0602.png")
```

각 대상을 차례로 논의해 보겠습니다.

1. 대상 *`all`*에는 두 가지 종속성이 있지만 규칙은 없습니다. 이것은 지정된 순서대로 하나 이상의 대상을 실행하는 바로 가기와 같습니다. 이 경우 *`top10`*과 *`heights.png`*입니다. 대상 *`all`*은 *Makefile*의 첫 번째 대상으로 표시되므로 `make`를 실행하면 이 대상이 빌드됩니다.
2. 대상 *`data`*는 디렉터리 *data*를 만듭니다. 이전에 `make`는 파일에 관한 것이라고 말했습니다. 음, 디렉터리에도 해당됩니다. 이 대상은 디렉터리 *data*가 아직 존재하지 않는 경우에만 실행됩니다.
3. 대상 *`data/starwars.csv`*는 대상 *`data`*에 의존합니다. *`data`* 디렉터리가 없으면 먼저 생성됩니다. 모든 종속성이 충족되면 규칙이 실행되어 파일을 다운로드하고 대상과 동일한 이름의 파일에 저장합니다.
4. 대상 *`top10`*은 가짜로 표시되므로 지정된 경우 항상 빌드됩니다. *`data/starwars.csv`* 대상에 의존합니다. 첫 번째 필수 조건의 이름(즉, *data/starwars.csv*)으로 확장되는 특수 변수 *`$<`*를 사용합니다.
5. 대상 *`heights.png`*는 대상 *`top10`*과 마찬가지로 *`data/starwars.csv`*에 의존하며 이 장에서 본 두 가지 자동 변수를 모두 사용합니다. 다른 자동 변수에 대해 자세히 알아보려면 [온라인 설명서](https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html)를 참조하십시오.

마지막으로 이 *Makefile*이 작동하는지 확인해 보겠습니다.

```{console}
make
```

여기에는 놀라운 점이 없습니다. 대상을 지정하지 않았으므로 *`all`* 대상이 빌드되고, 그러면 *`top10`*과 *`heights.png`* 대상이 모두 빌드됩니다. 전자의 출력은 표준 출력으로 인쇄되고 후자는 *heights.png* 파일을 만듭니다. *data* 디렉터리는 한 번만 생성되고 CSV 파일도 한 번만 다운로드됩니다.

데이터를 가지고 놀고 다른 모든 것을 잊는 것보다 더 재미있는 것은 없습니다.
하지만 *Makefile*을 사용하여 수행한 작업을 기록하는 것이 가치가 있다는 것을 믿어야 합니다.
삶을 더 쉽게 만들 뿐만 아니라(말장난 의도) 데이터 워크플로를 단계별로 생각하기 시작할 것입니다.
시간이 지남에 따라 확장되는 자신만의 명령줄 도구 상자와 마찬가지로 `make` 워크플로도 마찬가지입니다.
정의한 단계가 많을수록 특정 단계를 자주 재사용할 수 있으므로 계속하기가 더 쉬워집니다.
`make`에 익숙해지고 삶이 더 쉬워지기를 바랍니다.


## 요약

명령줄의 장점 중 하나는 데이터를 가지고 놀 수 있다는 것입니다.
다양한 명령을 쉽게 실행하고 다양한 데이터 파일을 처리할 수 있습니다.
매우 대화형이고 반복적인 프로세스입니다.
잠시 후 원하는 결과를 얻기 위해 어떤 단계를 거쳤는지 잊어버리기 쉽습니다.
따라서 가끔씩 단계를 문서화하는 것이 매우 중요합니다.
이렇게 하면 귀하 또는 동료 중 한 명이 잠시 후 프로젝트를 다시 시작할 때 동일한 단계를 실행하여 동일한 결과를 다시 생성할 수 있습니다.

이 장에서는 모든 명령을 하나의 Bash 스크립트에 넣는 것은 최적이 아니라는 것을 보여주었습니다.
대신 `make`를 명령줄 도구로 사용하여 데이터 워크플로를 관리할 것을 제안했습니다.
다음 장에서는 데이터 과학을 위한 OSEMN 모델의 세 번째 단계인 데이터 탐색을 다룹니다.


## 추가 탐색을 위해

- Robert Mecklenburg의 책 *Managing Projects with GNU Make*와 온라인 *GNU Make Manual*은 `make`에 대한 포괄적이고 고급 개요를 제공합니다.
- `make` 외에도 다양한 워크플로 관리자가 있습니다. 구문과 기능은 다르지만 대상, 규칙, 종속성과 같은 개념도 사용합니다. 예로는 [Luigi](https://luigi.readthedocs.io), [Apache Airflow](https://airflow.apache.org), [Nextflow](https://www.nextflow.io)가 있습니다.
- 버전 관리, 특히 `git`과 GitHub에 대해 자세히 알아보려면 Scott Chacon과 Ben Straub의 책 *Pro Git*을 권장합니다. [무료로 제공](https://git-scm.com/book/en/v2)됩니다. [온라인 GitHub 설명서](https://docs.github.com/en/get-started)도 훌륭한 시작점입니다.
