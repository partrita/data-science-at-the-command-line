---
suppress-bibliography: true
---

```{r console_start, include=FALSE}
console_start()
```

```{console setup_history, include=FALSE}
 export CHAPTER="04"
 export HISTFILE=/history/history_${CHAPTER}
 rm -f $HISTFILE
```

<!-- TODO: Remove dashes from filenames top-words.sh etc. -->


# 명령줄 도구 만들기 {#chapter-4-creating-command-line-tools}

이 책 전체에서 기본적으로 한 줄에 맞는 많은 명령과 파이프라인을 소개합니다.
이것들은 한 줄짜리 또는 파이프라인으로 알려져 있습니다.
한 줄짜리로 복잡한 작업을 수행할 수 있다는 것이 명령줄을 강력하게 만드는 것입니다.
전통적인 프로그램을 작성하고 사용하는 것과는 매우 다른 경험입니다.

어떤 작업은 한 번만 수행하고 어떤 작업은 더 자주 수행합니다.
어떤 작업은 매우 구체적이고 다른 작업은 일반화될 수 있습니다.
특정 한 줄짜리를 정기적으로 반복해야 하는 경우 자체 명령줄 도구로 만드는 것이 좋습니다.
따라서 한 줄짜리와 명령줄 도구 모두 용도가 있습니다.
기회를 인식하려면 연습과 기술이 필요합니다.
명령줄 도구의 장점은 전체 한 줄짜리를 기억할 필요가 없고 다른 파이프라인에 포함하면 가독성이 향상된다는 것입니다.
그런 의미에서 명령줄 도구를 프로그래밍 언어의 함수와 유사하게 생각할 수 있습니다.

그러나 프로그래밍 언어로 작업하는 것의 이점은 코드가 하나 이상의 파일에 있다는 것입니다.
즉, 해당 코드를 쉽게 편집하고 재사용할 수 있습니다.
코드에 매개변수가 있으면 유사한 패턴을 따르는 문제에도 일반화하고 다시 적용할 수 있습니다.

명령줄 도구는 두 가지 장점을 모두 가지고 있습니다. 명령줄에서 사용할 수 있고, 매개변수를 허용하며, 한 번만 만들면 됩니다.
이 장에서는 두 가지 방법으로 명령줄 도구를 만드는 데 익숙해질 것입니다.
첫째, 이러한 한 줄짜리를 재사용 가능한 명령줄 도구로 바꾸는 방법을 설명합니다.
명령에 매개변수를 추가하여 프로그래밍 언어가 제공하는 것과 동일한 유연성을 추가할 수 있습니다.
그런 다음 프로그래밍 언어로 작성된 코드에서 재사용 가능한 명령줄 도구를 만드는 방법을 보여줍니다.
Unix 철학을 따르면 코드를 완전히 다른 언어로 작성되었을 수 있는 다른 명령줄 도구와 결합할 수 있습니다.
이 장에서는 Bash, Python, R이라는 세 가지 프로그래밍 언어에 중점을 둘 것입니다.

재사용 가능한 명령줄 도구를 만들면 장기적으로 더 효율적이고 생산적인 데이터 과학자가 될 수 있다고 생각합니다.
이전에 발생했던 문제에 적용할 수 있는 기존 도구를 가져올 수 있는 자신만의 데이터 과학 도구 상자를 점차적으로 구축하게 될 것입니다.
한 줄짜리 또는 기존 코드를 명령줄 도구로 바꿀 기회를 인식하려면 연습이 필요합니다.

```{block2, type="rmdtip"}
한 줄짜리를 셸 스크립트로 바꾸기 위해 약간의 셸 스크립팅을 사용할 것입니다.
이 책은 변수, 조건문, 루프를 포함한 셸 스크립팅의 개념 중 작은 하위 집합만 보여줍니다.
셸 스크립팅에 대한 완전한 과정은 자체 책이 필요하므로 이 책의 범위를 벗어납니다.
셸 스크립팅에 대해 더 자세히 알고 싶다면 @Robbins2005의 *Classic Shell Scripting* 책을 권장합니다.
```

## 개요

이 장에서는 다음을 수행하는 방법을 배웁니다.

- 한 줄짜리를 매개변수화된 셸 스크립트로 변환
- 기존 Python 및 R 코드를 재사용 가능한 명령줄 도구로 전환

이 장은 다음 파일로 시작합니다.

```{console list_files}
cd /data/ch04
l
```

이러한 파일을 가져오는 지침은 [2장](#chapter-2-getting-started)에 있습니다.
다른 모든 파일은 명령줄 도구를 사용하여 다운로드하거나 생성됩니다.

## 한 줄짜리를 셸 스크립트로 변환

이 섹션에서는 한 줄짜리를 재사용 가능한 명령줄 도구로 바꾸는 방법을 설명합니다.
텍스트 조각에서 가장 자주 사용되는 단어를 가져오고 싶다고 가정해 보겠습니다.
Lewis Carroll의 책 *이상한 나라의 앨리스*를 예로 들어 보겠습니다. 이 책은 다른 많은 훌륭한 책과 마찬가지로 프로젝트 구텐베르크에서 무료로 제공됩니다.

```{console alice_txt}
curl -sL "https://www.gutenberg.org/files/11/11-0.txt" | trim
```

다음 도구 시퀀스 또는 *파이프라인*이 작업을 수행해야 합니다.

```{console one_liner}
curl -sL "https://www.gutenberg.org/files/11/11-0.txt" | # <1>
tr '[:upper:]' '[:lower:]' | # <2>
grep -oE "[a-z\']{2,}" | # <3>
sort | # <4>
uniq -c | # <5>
sort -nr | # <6>
head -n 10 # <7>
```
<1> `curl`을 사용하여 전자책 다운로드.
<2> `tr` [@tr]을 사용하여 전체 텍스트를 소문자로 변환.
<3> `grep` [@grep]을 사용하여 모든 단어를 추출하고 각 단어를 별도의 줄에 배치.
<4> `sort` [@sort]를 사용하여 이러한 단어를 알파벳순으로 정렬.
<5> `uniq` [@uniq]를 사용하여 모든 중복 항목을 제거하고 각 단어가 목록에 나타나는 횟수를 계산합니다.
<6> `sort`를 사용하여 이 고유한 단어 목록을 개수별로 내림차순으로 정렬합니다.
<7> `head`를 사용하여 상위 10개 줄(즉, 단어)만 유지합니다.

이러한 단어는 실제로 텍스트에서 가장 자주 나타납니다.
이러한 단어("alice"라는 단어 제외)는 많은 영어 텍스트에서 매우 자주 나타나므로 의미가 거의 없습니다.
사실, 이것들은 *불용어*로 알려져 있습니다.
이것들을 제거하면 이 텍스트와 관련된 가장 빈번한 단어만 남게 됩니다.

다음은 제가 찾은 불용어 목록입니다.

```{console download_stopwords}
curl -sL "https://raw.githubusercontent.com/stopwords-iso/stopwords-en/master/stopwords-en.txt" |
sort | tee stopwords | trim 20
```

`grep`을 사용하면 계산을 시작하기 직전에 불용어를 필터링할 수 있습니다.

```{console one_liner_with_stopwords, callouts=list("stopwords")}
curl -sL "https://www.gutenberg.org/files/11/11-0.txt" |
tr '[:upper:]' '[:lower:]' |
grep -oE "[a-z\']{2,}" |
sort |
grep -Fvwf stopwords |
uniq -c |
sort -nr |
head -n 10
```
<1> `-f`를 사용하여 한 줄에 하나씩 파일(이 경우 *stopwords*)에서 패턴을 가져옵니다. `-F`를 사용하여 해당 패턴을 고정 문자열로 해석합니다. `-w`를 사용하여 전체 단어를 형성하는 일치 항목만 포함하는 줄을 선택합니다. `-v`를 사용하여 일치하지 않는 줄을 선택합니다.

```{block2, type="rmdtip"}
이 한 줄짜리에 사용된 각 명령줄 도구는 man 페이지를 제공합니다.
따라서 예를 들어 `grep`에 대해 더 자세히 알고 싶다면 명령줄에서 `man grep`을 실행할 수 있습니다.
명령줄 도구 `tr`, `grep`, `uniq`, `sort`는 다음 장에서 더 자세히 설명합니다.
```

이 한 줄짜리를 한 번만 실행하는 데는 아무런 문제가 없습니다.
그러나 프로젝트 구텐베르크의 모든 전자책의 상위 10개 단어를 원한다고 상상해 보십시오.
또는 뉴스 웹사이트의 상위 10개 단어를 시간 단위로 원한다고 상상해 보십시오.
이러한 경우 이 한 줄짜리를 더 큰 것의 일부가 될 수 있는 별도의 빌딩 블록으로 사용하는 것이 가장 좋습니다.
이 한 줄짜리에 매개변수 측면에서 약간의 유연성을 추가하기 위해 셸 스크립트로 바꿀 것입니다.

이를 통해 한 줄짜리를 시작점으로 삼고 점차 개선할 수 있습니다.
이 한 줄짜리를 재사용 가능한 명령줄 도구로 바꾸려면 다음 6단계를 안내합니다.

1.  한 줄짜리를 파일에 복사하여 붙여넣습니다.
2.  실행 권한을 추가합니다.
3.  소위 쉬뱅을 정의합니다.
4.  고정된 입력 부분을 제거합니다.
5.  매개변수를 추가합니다.
6.  선택적으로 PATH를 확장합니다.


### 1단계: 파일 만들기

첫 번째 단계는 새 파일을 만드는 것입니다.
즐겨 사용하는 텍스트 편집기를 열고 한 줄짜리를 복사하여 붙여넣을 수 있습니다.
새 명령줄 도구를 향한 첫 번째 단계임을 나타내기 위해 파일 이름을 *top-words-1.sh*로 지정하겠습니다. 명령줄에 머무르고 싶다면 *fix command*를 의미하는 내장 `fc`를 사용할 수 있으며, 이를 통해 마지막으로 실행된 명령을 수정하거나 *편집*할 수 있습니다.

```{console fc}
fc #! enter=FALSE
```

`fc`를 실행하면 환경 변수 *EDITOR*에 저장된 기본 텍스트 편집기가 호출됩니다.
Docker 컨테이너에서는 간단한 텍스트 편집기인 `nano`로 설정되어 있습니다.
보시다시피 이 파일에는 한 줄짜리가 포함되어 있습니다.

```{console fc_enter, fullscreen=TRUE}
Enter #! literal=FALSE, hold=0.2, wait=0.2
```

**`Ctrl-O`**를 누르고 임시 파일 이름을 제거한 다음 `top-words-1.sh`를 입력하여 이 임시 파일에 적절한 이름을 지정합니다.

```{console fc_save, fullscreen=TRUE}
C-O BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace #! literal=FALSE
top-words-1.sh#! enter=FALSE
```

**`Enter`** 키를 누릅니다.

```{console fc_confirm, fullscreen=TRUE}
Enter #! literal=FALSE
```

다른 파일 이름으로 저장할 것인지 확인하려면 **`Y`**를 누릅니다.

```{console fc_confirm_yes, fullscreen=TRUE}
Y #! literal=FALSE
```

**`Ctrl-X`**를 눌러 `nano`를 종료하고 원래 위치로 돌아갑니다.

```{console fc_exit, include=FALSE}
C-X #! literal=FALSE, expect_prompt=TRUE

```

셸 스크립트를 만들고 있음을 명확히 하기 위해 파일 확장자 *.sh*를 사용하고 있습니다.
그러나 명령줄 도구에는 확장자가 필요하지 않습니다.
실제로 명령줄 도구에는 거의 확장자가 없습니다.

파일 내용을 확인합니다.

```{console bat_top_words_1}
pwd
l
bat top-words-1.sh
```

이제 `bash` [@bash]를 사용하여 파일의 명령을 해석하고 실행할 수 있습니다.

```{console bash_top_words_1}
bash top-words-1.sh
```

이렇게 하면 다음에 한 줄짜리를 다시 입력하는 수고를 덜 수 있습니다.

그러나 파일 자체를 실행할 수 없으므로 아직 *실제* 명령줄 도구가 아닙니다.
다음 단계에서 변경해 보겠습니다.


### 2단계: 실행 권한 부여

파일을 직접 실행할 수 없는 이유는 올바른 액세스 권한이 없기 때문입니다.
특히 사용자로서 파일을 실행할 수 있는 권한이 있어야 합니다.
이 섹션에서는 파일의 액세스 권한을 변경합니다.

단계 간의 차이점을 비교하기 위해 `cp -v top-words-{1,2}.sh`를 사용하여 파일을 *top-words-2.sh*로 복사합니다.

```{block2, type="rmdtip"}
중괄호 확장이나 다른 형태의 파일 확장이 무엇으로 이어지는지 확인하고 싶다면 명령을 `echo`로 바꾸어 결과를 인쇄하기만 하면 됩니다.
예를 들어 `echo book_{draft,final}.md` 또는 `echo agent-{001..007}`입니다.
```

파일의 액세스 권한을 변경하려면 *change mode*를 의미하는 `chmod` [@chmod]라는 명령줄 도구를 사용해야 합니다.
특정 파일의 파일 모드 비트를 변경합니다.
다음 명령은 사용자인 귀하에게 *top-words-2.sh*를 실행할 수 있는 권한을 부여합니다.

```{console chmod}
cp -v top-words-{1,2}.sh
chmod u+x top-words-2.sh
```

인수 `u+x`는 세 글자로 구성됩니다. (1) `u`는 파일을 소유한 사용자(파일을 만들었으므로 귀하)에 대한 권한을 변경하려고 함을 나타냅니다. (2) `+`는 권한을 추가하려고 함을 나타냅니다. (3) `x`는 실행 권한을 나타냅니다.

이제 두 파일의 액세스 권한을 살펴보겠습니다.

```{console compare_permissions}
l top-words-{1,2}.sh
```

첫 번째 열은 각 파일의 액세스 권한을 보여줍니다.
*top-words-2.sh*의 경우 *`-rwxrw-r--`*입니다.
첫 번째 문자 *`-`*(하이픈)는 파일 유형을 나타냅니다.
*`-`*는 일반 파일을 의미하고 *`d`*는 디렉터리를 의미합니다.
다음 세 문자 *`rwx`*는 파일을 소유한 사용자에 대한 액세스 권한을 나타냅니다.
*`r`*과 *`w`*는 각각 *읽기*와 *쓰기*를 의미합니다.
(보시다시피 *top-words-1.sh*에는 *`x`* 대신 *`-`*가 있으며 이는 해당 파일을 *실행*할 수 없음을 의미합니다.) 다음 세 문자 *`rw-`*는 파일을 소유한 그룹의 모든 구성원에 대한 액세스 권한을 나타냅니다.
마지막으로 열의 마지막 세 문자 *`r--`*는 다른 모든 사용자에 대한 액세스 권한을 나타냅니다.

이제 다음과 같이 파일을 실행할 수 있습니다.

```{console run_top_words_2}
./top-words-2.sh
```

*top-words-1.sh*와 같이 올바른 액세스 권한이 없는 파일을 실행하려고 하면 다음과 같은 오류 메시지가 표시됩니다.

```{console permission_denied}
./top-words-1.sh
```

### 3단계: 쉬뱅 정의

이미 파일을 자체적으로 실행할 수 있지만 파일에 소위 쉬뱅을 추가해야 합니다.
*쉬뱅*은 스크립트의 특수 줄로, 명령을 해석하는 데 사용할 실행 파일을 시스템에 지시합니다.

*쉬뱅*이라는 이름은 처음 두 문자, 즉 해시(쉬)와 느낌표(뱅): `#!`에서 유래했습니다.
이전 단계에서처럼 생략하는 것은 좋지 않습니다. 각 셸마다 기본 실행 파일이 다르기 때문입니다.
이 책 전체에서 사용하는 Z 셸은 쉬뱅이 정의되지 않은 경우 기본적으로 실행 파일 */bin/sh*를 사용합니다.
이 경우 `bash`가 `sh`보다 더 많은 기능을 제공하므로 명령을 해석하도록 `bash`를 사용하고 싶습니다.

다시 말하지만, 원하는 편집기를 자유롭게 사용할 수 있지만 Docker 이미지에 설치된 `nano` [@nano]를 계속 사용할 것입니다.

```{console nano_start}
cp -v top-words-{2,3}.sh
nano top-words-3.sh #! enter=FALSE
```

```{console nano_open, fullscreen=TRUE, highlight=FALSE}
Enter #! literal=FALSE
```
*`#!/usr/bin/env/bash`*를 입력하고 **`Enter`** 키를 누릅니다.
준비가 되면 **`Ctrl-X`**를 눌러 저장하고 종료합니다.

```{console nano_edit, fullscreen=TRUE, highlight=FALSE}
# ! #! literal=FALSE
/usr/bin/env bash #! expect_prompt=FALSE
C-X #! literal=FALSE
```

파일을 저장할 것인지 묻는 메시지가 나타나면 **`Y`**를 누릅니다.

```{console nano_confirm, fullscreen=TRUE, highlight=FALSE}
Y #! literal=FALSE
```

*top-words-3.sh*가 어떻게 보이는지 확인해 보겠습니다.

```{console, include=FALSE}
Enter #! literal=FALSE, expect_prompt = TRUE
```

```{console nano_exit}
bat top-words-3.sh
```

이것이 바로 우리가 필요한 것입니다. 앞에 쉬뱅이 있는 원래 파이프라인입니다.

때로는 *`!/usr/bin/bash`* 또는 *`!/usr/bin/python`*(다음 섹션에서 볼 수 있듯이 Python의 경우) 형식의 쉬뱅이 있는 스크립트를 접하게 될 것입니다.
일반적으로 작동하지만 `bash` 또는 `python` [@python] 실행 파일이 */usr/bin*과 다른 위치에 설치된 경우 스크립트가 더 이상 작동하지 않습니다.
여기에 제시된 형식, 즉 *`!/usr/bin/env bash`* 및 *`!/usr/bin/env python`*을 사용하는 것이 좋습니다. `env` [@env] 실행 파일은 `bash`와 `python`이 설치된 위치를 알고 있기 때문입니다.
요컨대 `env`를 사용하면 스크립트의 이식성이 향상됩니다.


### 4단계: 고정 입력 제거

이제 명령줄에서 실행할 수 있는 유효한 명령줄 도구가 있습니다.
하지만 이보다 더 잘할 수 있습니다.
명령줄 도구를 더 재사용 가능하게 만들 수 있습니다.
파일의 첫 번째 명령은 `curl`이며, 가장 많이 사용되는 상위 10개 단어를 얻으려는 텍스트를 다운로드합니다.
따라서 데이터와 작업이 하나로 결합됩니다.

다른 전자책이나 다른 텍스트에서 가장 많이 사용되는 상위 10개 단어를 얻으려면 어떻게 해야 할까요? 입력 데이터는 도구 자체 내에 고정되어 있습니다.
데이터를 명령줄 도구와 분리하는 것이 좋습니다.

명령줄 도구 사용자가 텍스트를 제공한다고 가정하면 도구가 일반적으로 적용 가능해집니다.
따라서 해결책은 스크립트에서 `curl` 명령을 단순히 제거하는 것입니다.
다음은 *top-words-4.sh*라는 업데이트된 스크립트입니다.

```{console remove_fixed_input}
cp -v top-words-{3,4}.sh
sed -i '2d' top-words-4.sh
bat top-words-4.sh
```

스크립트가 `tr`과 같이 표준 입력에서 데이터가 필요한 명령으로 시작하면 명령줄 도구에 제공된 입력을 사용하기 때문에 이것이 작동합니다.
예를 들면 다음과 같습니다.

```{console cat_top_words_4}
curl -sL 'https://www.gutenberg.org/files/11/11-0.txt' | ./top-words-4.sh
curl -sL 'https://www.gutenberg.org/files/12/12-0.txt' | ./top-words-4.sh
man bash | ./top-words-4.sh
```

```{block2, type="rmdtip"}
스크립트에서는 그렇게 하지 않았지만 데이터 저장에도 동일한 원칙이 적용됩니다.
일반적으로 스크립트가 특정 파일에 쓰도록 하는 것보다 출력 리디렉션을 사용하여 사용자가 처리하도록 하는 것이 좋습니다.
물론 명령줄 도구를 자신의 프로젝트에만 사용하려는 경우 특정할 수 있는 한계는 없습니다.
```


### 5단계: 인수 추가

명령줄 도구를 더욱 재사용 가능하게 만들기 위한 단계가 하나 더 있습니다. 바로 매개변수입니다.
명령줄 도구에는 `sort`의 `-nr` 및 `head`의 `-n 10`과 같이 여러 고정 명령줄 인수가 있습니다.
이전 인수는 고정된 상태로 유지하는 것이 가장 좋습니다.
그러나 `head` 명령에 다른 값을 허용하면 매우 유용할 것입니다.
이렇게 하면 최종 사용자가 출력할 가장 자주 사용되는 단어 수를 설정할 수 있습니다.
아래는 *top-words-5.sh* 파일의 모양입니다.

```{console copy_cache_top_words, include=FALSE}
 cp /data/.cache/top-words top-words-5.sh
```

```{console bat_top_words_5}
bat top-words-5.sh
```

* 변수 *NUM\_WORDS*는 Bash의 특수 변수인 *\$1*의 값으로 설정됩니다. 이 변수는 명령줄 도구에 전달된 첫 번째 명령줄 인수의 값을 보유합니다. 아래 표에는 Bash가 제공하는 다른 특수 변수가 나열되어 있습니다. 값이 지정되지 않으면 "10" 값을 갖습니다.
* *\$NUM\_WORDS* 변수의 값을 *사용*하려면 그 앞에 달러 기호를 넣어야 합니다. *설정*할 때는 달러 기호를 쓰지 않습니다.

`head`의 인수로 *\$1*을 직접 사용하고 *NUM\_WORDS*와 같은 추가 변수를 만들지 않아도 됩니다.
그러나 스크립트가 더 크고 *\$2* 및 *\$3*과 같은 몇 가지 명령줄 인수가 더 있는 경우 명명된 변수를 사용하면 코드를 더 읽기 쉽게 만들 수 있습니다.

이제 텍스트에서 가장 많이 사용되는 상위 20개 단어를 보려면 다음과 같이 명령줄 도구를 호출합니다.

```{console cat_top_words_5_with_argument}
curl -sL "https://www.gutenberg.org/files/11/11-0.txt" > alice.txt
< alice.txt ./top-words-5.sh 20
```

사용자가 숫자를 지정하지 않으면 스크립트가 가장 일반적인 상위 10개 단어를 표시합니다.

```{console cat_top_words_5_no_argument}
< alice.txt ./top-words-5.sh
```

### 6단계: PATH 확장


이전 5단계를 거쳐 재사용 가능한 명령줄 도구 만들기를 마쳤습니다.
그러나 매우 유용할 수 있는 단계가 하나 더 있습니다.
이 선택적 단계에서는 어디에서나 명령줄 도구를 실행할 수 있도록 합니다.

현재 명령줄 도구를 실행하려면 해당 도구가 있는 디렉터리로 이동하거나 2단계에서 설명한 대로 전체 경로 이름을 포함해야 합니다.
명령줄 도구가 특정 프로젝트용으로 특별히 빌드된 경우에는 괜찮습니다.
그러나 명령줄 도구를 여러 상황에 적용할 수 있는 경우 Ubuntu와 함께 제공되는 명령줄 도구처럼 어디에서나 실행할 수 있으면 유용합니다.

이를 위해 Bash는 명령줄 도구를 찾을 위치를 알아야 합니다.
*PATH*라는 환경 변수에 저장된 디렉터리 목록을 순회하여 이 작업을 수행합니다.
새로운 Docker 컨테이너에서 *PATH*는 다음과 같습니다.

```{console echo_path}
echo $PATH
```

디렉터리는 콜론으로 구분됩니다.
콜론을 줄 바꿈으로 *변환*하여 디렉터리 목록으로 인쇄할 수 있습니다.

```{console echo_path_tr}
echo $PATH | tr ':' '\n'
```

*PATH*를 영구적으로 변경하려면 홈 디렉터리에 있는 *.bashrc* 또는 *.profile* 파일을 편집해야 합니다.
모든 사용자 지정 명령줄 도구를 하나의 디렉터리(예: *\~/tools*)에 넣으면 *PATH*를 한 번만 변경하면 됩니다.
이제 더 이상 *./*를 추가할 필요 없이 파일 이름만 사용하면 됩니다.
또한 명령줄 도구가 어디에 있는지 더 이상 기억할 필요가 없습니다.

```{console echo_path_again}
cp -v top-words{-5.sh,}
export PATH="${PATH}:/data/ch04"
echo $PATH
curl "https://www.gutenberg.org/files/11/11-0.txt" |
top-words 10
```


## Python 및 R로 명령줄 도구 만들기

이전 섹션에서 만든 명령줄 도구는 Bash로 작성되었습니다.
(물론 Bash 프로그래밍 언어의 모든 기능이 사용된 것은 아니지만 인터프리터는 여전히 `bash`였습니다.) 이제 아시다시피 명령줄은 언어에 구애받지 않으므로 명령줄 도구를 만드는 데 반드시 Bash를 사용할 필요는 없습니다.

이 섹션에서는 다른 프로그래밍 언어로도 명령줄 도구를 만들 수 있음을 보여줄 것입니다.
현재 데이터 과학 커뮤니티에서 가장 인기 있는 두 프로그래밍 언어인 Python과 R에 중점을 둘 것입니다.
두 언어에 대한 완전한 소개를 제공할 수 없으므로 Python 및/또는 R에 대한 어느 정도의 친숙도가 있다고 가정합니다.
Java, Go, Julia와 같은 다른 프로그래밍 언어는 명령줄 도구를 만들 때 유사한 패턴을 따릅니다.

Bash가 아닌 다른 프로그래밍 언어로 명령줄 도구를 만드는 세 가지 주요 이유가 있습니다.
첫째, 명령줄에서 사용하고 싶은 기존 코드가 있을 수 있습니다.
둘째, 명령줄 도구가 100줄 이상의 Bash 코드를 포함하게 될 수 있습니다.
셋째, 명령줄 도구가 더 안전하고 강력해야 합니다(Bash에는 유형 검사와 같은 많은 기능이 부족합니다).

이전 섹션에서 설명한 6단계는 다른 프로그래밍 언어로 명령줄 도구를 만드는 데에도 대략적으로 적용됩니다.
그러나 첫 번째 단계는 명령줄에서 복사하여 붙여넣는 것이 아니라 관련 코드를 새 파일에 복사하여 붙여넣는 것입니다.
Python 및 R로 작성된 명령줄 도구는 쉬뱅 뒤에 인터프리터로 각각 `python` 및 `Rscript` [@R]를 지정해야 합니다.

Python과 R을 사용하여 명령줄 도구를 만들 때 특별한 주의가 필요한 두 가지 측면이 더 있습니다.
첫째, 셸 스크립트에는 자연스러운 표준 입력 처리를 Python과 R에서는 명시적으로 처리해야 합니다.
둘째, Python과 R로 작성된 명령줄 도구는 더 복잡한 경향이 있으므로 사용자에게 더 정교한 명령줄 인수를 지정할 수 있는 기능도 제공하고 싶을 수 있습니다.

### 셸 스크립트 포팅

시작점으로 방금 만든 셸 스크립트를 Python과 R 모두로 포팅하는 방법을 살펴보겠습니다.
즉, 표준 입력에서 가장 자주 사용되는 상위 단어를 제공하는 Python 및 R 코드는 무엇일까요? 먼저 두 파일 *top-words.py*와 *top-words.R*을 보여준 다음 셸 코드와의 차이점을 설명합니다.
Python에서 코드는 다음과 같습니다.


```{console bat_python}
cd /data/ch04
bat top-words.py
```

이 Python 예제는 타사 패키지를 사용하지 않습니다.
고급 텍스트 처리를 원하면 NLTK 패키지 [@Perkins2010]를 확인하는 것이 좋습니다.
많은 수치 데이터를 다룰 예정이라면 Pandas 패키지 [@McKinney2012]를 사용하는 것이 좋습니다.

그리고 R에서 코드는 다음과 같습니다.

```{console bat_r}
bat top-words.R
```

세 가지 구현(즉, Bash, Python, R) 모두 동일한 개수로 동일한 상위 5개 단어를 반환하는지 확인해 보겠습니다.

```{console compare_time}
time < alice.txt top-words 5
time < alice.txt top-words.py 5
time < alice.txt top-words.R 5
```

훌륭합니다! 물론 출력 자체는 그다지 흥미롭지 않습니다.
흥미로운 점은 여러 언어로 동일한 작업을 수행할 수 있다는 것입니다.
접근 방식 간의 차이점을 살펴보겠습니다.

첫째, 코드 양의 차이가 즉시 분명합니다.
이 특정 작업의 경우 Python과 R 모두 Bash보다 훨씬 많은 코드가 필요합니다.
이는 일부 작업의 경우 명령줄을 사용하는 것이 더 낫다는 것을 보여줍니다.
다른 작업의 경우 프로그래밍 언어를 사용하는 것이 더 나을 수 있습니다.
명령줄 경험이 많아질수록 어떤 접근 방식을 언제 사용해야 하는지 인식하기 시작할 것입니다.
모든 것이 명령줄 도구인 경우 작업을 하위 작업으로 나누고 Bash 명령줄 도구를 예를 들어 Python 명령줄 도구와 결합할 수도 있습니다.
당면한 작업에 가장 적합한 접근 방식을 사용하십시오.

### 표준 입력에서 스트리밍 데이터 처리

이전 두 코드 조각에서 Python과 R 모두 전체 표준 입력을 한 번에 읽었습니다.
명령줄에서 대부분의 도구는 데이터를 스트리밍 방식으로 다음 명령줄 도구로 파이프합니다.
`sort`와 같이 표준 출력에 데이터를 쓰기 전에 전체 데이터가 필요한 몇 가지 명령줄 도구가 있습니다.
즉, 이러한 명령줄 도구에 의해 파이프라인이 차단됩니다.
입력 데이터가 파일과 같이 유한한 경우에는 문제가 되지 않을 수 있습니다.
그러나 입력 데이터가 논스톱 스트림인 경우 이러한 차단 명령줄 도구는 쓸모가 없습니다.

다행히 Python과 R은 스트리밍 데이터 처리를 지원합니다.
예를 들어 줄 단위로 함수를 적용할 수 있습니다.
다음은 각각 Python과 R에서 이것이 어떻게 작동하는지 보여주는 두 가지 최소한의 예입니다.

Python 및 R 도구 모두 이제는 악명 높은 Fizz Buzz 문제를 해결합니다. 이 문제는 다음과 같이 정의됩니다. 1에서 100까지의 숫자를 인쇄하되, 숫자가 3으로 나누어지면 "fizz"를 인쇄하고, 5로 나누어지면 "buzz"를 인쇄하고, 15로 나누어지면 "fizzbuzz"를 인쇄합니다. 다음은 Python 코드입니다[^fb].

```{console bat_stream_py}
bat fizzbuzz.py
```

그리고 R 코드는 다음과 같습니다.

```{console bat_stream_r}
bat fizzbuzz.R
```

두 도구를 모두 테스트해 보겠습니다(공간을 절약하기 위해 출력을 `column`으로 파이프합니다).

```{console test_streams}
seq 30 | fizzbuzz.py | column -x
seq 30 | fizzbuzz.R | column -x
```

이 출력은 올바르게 보입니다!
이 두 도구가 실제로 스트리밍 방식으로 작동하는지 보여주기는 어렵습니다.
입력 데이터를 Python 또는 R 도구로 파이프하기 전에 `sample -d 100`으로 파이프하여 직접 확인할 수 있습니다.
이렇게 하면 각 줄 사이에 약간의 지연이 추가되어 도구가 모든 입력 데이터를 기다리지 않고 줄 단위로 작동하는지 확인하기가 더 쉬워집니다.


## 요약

이 막간 장에서는 자신만의 명령줄 도구를 빌드하는 방법을 보여주었습니다.
코드를 재사용 가능한 빌딩 블록으로 바꾸는 데는 6단계만 필요합니다.
훨씬 더 생산적이 될 것입니다.
자신만의 도구를 만들 기회를 계속 주시하는 것이 좋습니다.
다음 장에서는 데이터 과학을 위한 OSEMN 모델의 두 번째 단계인 데이터 정제를 다룹니다.


## 추가 탐색을 위해

- 도구에 기억해야 할 옵션이 많거나 다른 사람과 도구를 공유하려는 경우 도구에 도움말 설명서를 추가하는 것이 중요합니다. `docopt`는 도움말을 제공하고 도구가 허용하는 가능한 옵션을 정의하는 언어 독립적인 프레임워크입니다. Bash, Python, R을 포함한 거의 모든 프로그래밍 언어에서 구현을 사용할 수 있습니다.
- Bash 프로그래밍에 대해 더 자세히 알고 싶다면 Arnold Robbins와 Nelson Beebe의 *Classic Shell Programming*과 Carl Albing과 JP Vossen의 *Bash Cookbook*을 권장합니다.
- 강력하고 안전한 Bash 스크립트를 작성하는 것은 상당히 까다롭습니다. [ShellCheck](https://www.shellcheck.net/)는 Bash 코드의 실수와 취약점을 확인하는 온라인 도구입니다. 명령줄 도구도 사용할 수 있습니다.
- Joel Grus의 책 *Ten Essays on Fizz Buzz*는 Python으로 Fizz Buzz를 해결하는 열 가지 다른 방법에 대한 통찰력 있고 재미있는 모음집입니다.

[^fb]: 이 코드는 [Joel Grus의 Python 스크립트](https://github.com/joelgrus/fizzbuzz/blob/master/fizzbuzz/cycle_of_15.py)를 수정한 것입니다.
