---
suppress-bibliography: true
---

```{r console_start, include=FALSE}
console_start()
```

```{console setup_history, include=FALSE}
 export CHAPTER="07"
 export HISTFILE=/history/history_${CHAPTER}
 rm -f $HISTFILE
```


# 데이터 탐색하기 {#chapter-7-exploring-data}

그 모든 고된 작업 끝에 (이미 정제된 데이터가 준비되어 있지 않았다면 말이죠), 이제 즐거운 시간을 보낼 때입니다.
데이터를 획득하고 정제했으니, 이제 OSEMN 모델의 세 번째 단계인 데이터 탐색(explore)으로 넘어갈 수 있습니다.

데이터 탐색은 데이터와 친숙해지는 과정입니다.
데이터를 잘 아는 것은 그로부터 가치를 추출하는 데 필수적입니다.
예를 들어, 데이터가 어떤 특성(features)을 가지고 있는지 알면, 어떤 특성을 더 깊이 파고들 가치가 있는지, 그리고 가지고 있는 질문에 답하기 위해 어떤 특성을 사용할 수 있을지 알 수 있게 됩니다.

데이터 탐색은 세 가지 관점에서 진행할 수 있습니다.
첫 번째 관점은 데이터와 그 속성을 검사(inspect)하는 것입니다.
여기서는 원시 데이터가 어떻게 생겼는지, 데이터셋에 데이터 포인트가 몇 개인지, 어떤 특성들이 있는지 등을 파악하고자 합니다.

두 번째는 기술 통계량(descriptive statistics)을 계산하는 것입니다. 이 관점은 개별 특성에 대해 더 자세히 배우는 데 유용합니다.
출력 결과는 대게 짧은 텍스트 형태이므로 커맨드 라인에 바로 출력할 수 있습니다.

세 번째 관점은 데이터 시각화(visualizations)를 생성하는 것입니다. 이 관점을 통해 여러 특성이 서로 어떻게 상호작용하는지에 대한 통찰을 얻을 수 있습니다. 커맨드 라인에 출력할 수 있는 시각화 생성 방법을 설명하겠지만, 시각화는 그래픽 사용자 인터페이스(GUI)에 표시하는 것이 가장 적합합니다. 기술 통계량과 비교했을 때 데이터 시각화의 장점은 더 유연하고 훨씬 더 많은 정보를 전달할 수 있다는 점입니다.


## 개요

이 장에서 여러분은 다음 내용을 배우게 됩니다.

- 데이터와 그 속성 검사하기
- 기술 통계량 계산하기
- 커맨드 라인 안팎에서 데이터 시각화 생성하기

이 장은 다음 파일들로 시작합니다.

```{console cd}
cd /data/ch07
l
```

이 파일들을 가져오는 방법은 [2장](#chapter-2-getting-started)에 설명되어 있습니다.
그 외의 파일들은 커맨드 라인 도구를 사용하여 다운로드하거나 생성한 것들입니다.

## 데이터와 그 속성 검사하기

이 섹션에서는 데이터셋과 그 속성을 검사하는 방법을 보여드리겠습니다. 앞으로 다룰 시각화 및 모델링 기술들은 데이터가 표(rectangular) 형태일 것으로 예상하므로, 데이터가 CSV 형식이라고 가정하겠습니다. 필요한 경우 [5장](#chapter-5-scrubbing-data)에서 설명한 기술을 사용하여 데이터를 CSV로 변환할 수 있습니다.

편의상 데이터에 헤더(header)가 있다고 가정하겠습니다.
첫 번째 하위 섹션에서는 실제로 헤더가 있는지 확인하는 방법을 보여드리겠습니다.
헤더가 있다는 것을 알게 되면 다음과 같은 질문들에 답할 수 있습니다.

- 데이터셋에 데이터 포인트와 특성이 몇 개나 있는가?
- 원시 데이터는 어떻게 생겼는가?
- 데이터셋에는 어떤 종류의 특성들이 있는가?
- 이러한 특성 중 일부를 범주형(categorical)으로 취급할 수 있는가?


### 헤더의 유무 확인하기

`head`를 사용하여 처음 몇 줄을 출력함으로써 파일에 헤더가 있는지 확인할 수 있습니다.

```{console head_venture}
head -n 5 venture.csv
```

행이 너무 길어 화면을 넘어간다면 `nl`을 사용하여 행 번호를 추가해 보세요.

```{console head_nl_venture}
head -n 3 venture.csv | nl
```

또는 `trim`을 사용할 수도 있습니다.

```{console trim_venture}
< venture.csv trim 5
```

이 경우에는 첫 번째 행이 대문자 이름만 포함하고 있고 그 다음 행들은 숫자를 포함하고 있으므로 헤더임이 분명합니다.
이는 사실 상당히 주관적인 과정이며, 첫 번째 행을 헤더로 볼지 아니면 첫 번째 데이터 포인트로 볼지는 여러분의 판단에 달려 있습니다.
데이터셋에 헤더가 없는 경우, [5장](#chapter-5-scrubbing-data)에서 다룬 `header` 도구를 사용하여 이를 바로잡는 것이 가장 좋습니다.


### 모든 데이터 검사하기

원시 데이터를 자신의 속도에 맞춰 검토하고 싶다면 `cat`을 사용하는 것은 좋은 생각이 아닙니다. 모든 데이터가 한꺼번에 출력되기 때문입니다.
커맨드 라인에서 데이터를 상호작용적으로 검사할 수 있게 해주는 `less` [@less]를 사용하는 것을 추천합니다.
`-S` 옵션을 지정하면 (*venture.csv*처럼) 긴 행이 줄바꿈되는 것을 방지할 수 있습니다.

```{console less}
less -S venture.csv#! enter=FALSE
```

```{console less_enter, fullscreen=TRUE}
Enter Right Left#! literal=FALSE, hold=0.1, wait=0.1
```

```{console less_exit, include=FALSE}
q#! enter=FALSE, expect_prompt=TRUE
```

오른쪽의 크다 기호(`>`)는 가로로 스크롤할 수 있음을 나타냅니다.
**`위`** 및 **`아래`** 방향키를 눌러 위아래로 스크롤할 수 있습니다.
**`스페이스바`**를 누르면 한 화면씩 아래로 스크롤됩니다.
가로 스크롤은 **`왼쪽`** 및 **`오른쪽`** 방향키를 사용합니다.
**`g`**와 **`G`**를 누르면 각각 파일의 시작과 끝으로 이동합니다.
`less`를 종료하려면 **`q`**를 누르면 됩니다.
매뉴얼 페이지(manual page)에는 사용 가능한 모든 키 바인딩이 나열되어 있습니다.

`less`의 장점 중 하나는 파일 전체를 메모리에 로드하지 않는다는 점입니다. 즉, 대용량 파일을 볼 때도 매우 빠릅니다.


### 특성 이름과 데이터 유형

열(또는 특성) 이름은 특성의 의미를 나타낼 수 있습니다.
다음과 같은 `head`와 `tr` 조합을 사용할 수 있습니다.

```{console head_tr}
< venture.csv head -n 1 | tr , '\n'
```

이 기본적인 명령어는 파일이 쉼표로 구분되어 있다고 가정합니다.
더 견고한 접근 방식은 `csvcut`을 사용하는 것입니다.

```{console csvcut_names}
csvcut -n venture.csv
```

단순히 열 이름을 출력하는 것보다 한 걸음 더 나아갈 수 있습니다.
열 이름 외에도 각 열이 문자열, 숫자, 또는 날짜와 같이 어떤 유형의 값을 포함하고 있는지 아는 것이 매우 유용할 것입니다.
다음과 같은 장난감 데이터셋이 있다고 가정해 봅시다.

```{console bat_datatypes}
bat -A datatypes.csv
```

`csvlook`은 이를 다음과 같이 해석합니다.

```{console csvlook_datatypes}
csvlook datatypes.csv
```

[5장](#chapter-5-scrubbing-data)에서 CSV 데이터에 직접 SQL 쿼리를 실행하기 위해 `csvsql`을 이미 사용해 보았습니다.
커맨드 라인 인자를 전달하지 않으면, 이 데이터를 실제 데이터베이스에 삽입할 때 필요한 SQL 문을 생성합니다.
이 출력을 사용하여 유추된 열 유형이 무엇인지 검사할 수도 있습니다.
데이터 유형 뒤에 *NOT NULL* 문자열이 인쇄되어 있다면 해당 열에는 결측치가 없다는 뜻입니다.

```{console csvsql_datatypes}
csvsql datatypes.csv
```

이 출력은 `csvgrep`, `csvsort`, `csvsql`과 같은 `csvkit` 제품군의 다른 도구들을 사용할 때 특히 유용합니다.
*venture.csv*의 경우 열 유형은 다음과 같이 유추됩니다.

```{console csvsql_venture}
csvsql venture.csv
```


### 고유 식별자, 연속형 변수, 그리고 요인(Factors)

각 특성의 데이터 유형을 아는 것만으로는 충분하지 않습니다.
각 특성이 무엇을 나타내는지 아는 것도 필수적입니다.
도메인 지식이 있으면 매우 유용하겠지만, 데이터 자체를 살펴봄으로써 맥락을 파악할 수도 있습니다.

문자열과 정수 모두 고유 식별자일 수도 있고 범주를 나타낼 수도 있습니다.
후자의 경우 시각화에서 색상을 할당하는 데 사용될 수 있습니다.
하지만 정수가 우편번호 등을 나타낸다면 평균을 계산하는 것은 의미가 없습니다.

특성을 고유 식별자로 취급해야 할지 아니면 범주형 변수로 취급해야 할지 결정하기 위해, 특정 열의 고유 값(unique values) 개수를 세어볼 수 있습니다.

```{console}
wc -l tips.csv
< tips.csv csvcut -c day | header -d | sort | uniq | wc -l
```

`csvkit`의 일부인 `csvstat` [@csvstat]을 사용하여 각 열의 고유 값 개수를 얻을 수 있습니다.

```{console}
csvstat tips.csv --unique
csvstat venture.csv --unique
```

고유 값이 단 하나만 있다면 (*OBS_STATUS*처럼), 해당 열은 어떠한 가치도 제공하지 못하므로 삭제할 가능성이 큽니다.
그러한 모든 열을 자동으로 삭제하고 싶다면 다음과 같은 파이프라인을 사용할 수 있습니다.

```{console discard_columns, callouts=1:7}
< venture.csv csvcut -C $(
  csvstat venture.csv --unique |
  grep ': 1$' |
  cut -d. -f 1 |
  tr -d ' ' |
  paste -sd,
) | trim
```
<1> `-C` 옵션은 명령 대치(command substitution)를 통해 제공된 위치(또는 이름)의 열을 선택 해제합니다.
<2> *venture.csv*의 각 열에 대한 고유 값 개수를 얻습니다.
<3> 고유 값이 1개인 열만 남깁니다.
<4> 열의 위치를 추출합니다.
<5> 모든 공백을 제거합니다.
<6> 모든 열 위치를 쉼표로 구분된 한 줄로 만듭니다.
<7> 처음 10행만 보여줍니다.

그렇긴 하지만, 일단은 그 열들을 유지하도록 하겠습니다.

일반적으로 고유 값의 개수가 전체 행 수에 비해 적다면, 해당 특성은 범주형으로 취급될 수 있습니다 (*venture.csv*의 *GEO*처럼).
만약 개수가 행 수와 같다면 고유 식별자일 수도 있지만 수치형 값일 수도 있습니다.
이를 알아낼 수 있는 유일한 방법은 더 깊이 파고드는 것입니다.


## 기술 통계량 계산하기

### 열 통계(Column Statistics)

커맨드 라인 도구인 `csvstat`은 많은 정보를 제공합니다. 각 특성(열)에 대해 다음과 같은 내용을 보여줍니다.

- 데이터 유형
- 결측치(nulls)의 존재 여부
- 고유 값의 개수
- 해당 특성에 적합한 다양한 기술 통계량 (최솟값, 최댓값, 합계, 평균, 표준 편차, 중앙값)

`csvstat`을 다음과 같이 실행합니다.

```{console}
csvstat venture.csv | trim 32
```

내용이 매우 많기 때문에 처음 32행만 보여드리고 있습니다. 이 출력을 `less`로 연결해서 보는 것이 좋습니다.
특정 통계량에만 관심이 있다면 다음 옵션 중 하나를 사용할 수도 있습니다.

- `--max` (최댓값)
- `--min` (최솟값)
- `--sum` (합계)
- `--mean` (평균)
- `--median` (중앙값)
- `--stdev` (표준 편차)
- `--nulls` (결측치 포함 여부)
- `--unique` (고유 값 개수)
- `--freq` (빈번한 값)
- `--len` (최대 값 길이)

예를 들어 다음과 같습니다.

```{console csvstat_null}
csvstat venture.csv --freq | trim
```

정수와 열 이름을 모두 사용할 수 있는 `-c` 옵션으로 특정 특성들만 선택할 수 있습니다.

```{console csvstat_c}
csvstat venture.csv -c 3,GEO
```

```{block2, type="rmdtip"}
`csvstat`은 `csvsql`과 마찬가지로 휴리스틱을 사용하여 데이터 유형을 결정하므로 항상 정확하지는 않을 수 있다는 점을 명심하십시오.
항상 이전 하위 섹션에서 다룬 것처럼 수동으로 직접 검사해 보는 것이 좋습니다.
또한 데이터 유형이 문자열이나 정수일지라도, 그것이 데이터를 어떻게 사용해야 하는지에 대해서는 아무것도 알려주지 않습니다.
```

참고로 `csvstat`은 맨 마지막에 전체 데이터 포인트(행)의 수도 출력합니다.
값 내부의 줄바꿈과 쉼표도 올바르게 처리됩니다.
마지막 줄만 보고 싶다면 `tail`을 사용할 수 있습니다.
또는 실제 행의 개수만 반환하는 `xsv`를 사용할 수도 있습니다.

```{console csvstat_count}
csvstat venture.csv | tail -n 1
xsv count venture.csv
```

이 두 가지 옵션은 줄바꿈 횟수를 세는 (따라서 헤더도 포함하는) `wc -l`과 결과가 다르다는 점에 유의하십시오.


### 쉘에서의 R 한 줄 명령어

이 섹션에서는 커맨드 라인에서 직접 통계 프로그래밍 환경인 `R` [@R]을 활용할 수 있게 해주는 `rush` [@rush]라는 커맨드 라인 도구를 소개해 드리고자 합니다.
`rush`가 무엇을 하고 왜 존재하는지 설명하기 전에, 먼저 `R` 자체에 대해 잠깐 이야기해 보겠습니다.

`R`은 데이터 과학을 하기에 매우 강력한 통계 소프트웨어 패키지입니다.
패키지 모음이 방대하고 자체적인 REPL을 제공하는 인터프리터 언어이므로, 커맨드 라인과 비슷하게 데이터를 가지고 놀 수 있습니다.
`R`을 시작하면 유닉스 커맨드 라인과는 분리된 상호작용 세션에 들어가게 됩니다.

*tips.csv*라는 CSV 파일이 있고, 팁 비율(tip percentage)을 계산하여 그 결과를 저장하고 싶다고 가정해 봅시다.
이를 `R`에서 수행하려면 먼저 `R`을 실행합니다.

```{console start_r, keep_last_prompt=TRUE, callouts=list(1)}
R --quiet
```
<1> 긴 시작 메시지를 생략하기 위해 `--quiet` 옵션을 사용했습니다.

그 다음 아래의 코드를 실행합니다.

```{console r_code, keep_last_prompt=TRUE}
library(tidyverse)                            #<1>
df <- read_csv("tips.csv")                    #<2>
df <- mutate(df, percent = tip / bill * 100)  #<3>
write_csv(df, "percent.csv")                  #<4>
q("no")                                       #<5>
```
<1> 필요한 패키지를 로드합니다.
<2> CSV 파일을 읽어 들여 `df` 변수에 할당합니다.
<3> 새로운 *percent* 열을 계산합니다.
<4> 결과를 디스크에 저장합니다.
<5> `R`을 종료합니다.

그 후에 커맨드 라인에서 저장된 *percent.csv* 파일로 작업을 계속할 수 있습니다.

```{console}
< percent.csv trim 5
```

여기서 세 번째 줄만이 여러분이 구체적으로 달성하고자 하는 작업과 관련이 있다는 점에 주목하십시오.
나머지 줄들은 필요한 상용구(boilerplate)일 뿐입니다.
단순한 작업을 위해 이런 상용구들을 일일이 입력하는 것은 번거롭고 워크플로우를 방해합니다.
때로는 데이터에 대해 한두 가지만 하고 싶을 때가 있습니다.
`R`의 위력을 커맨드 라인에서 바로 사용할 수 있다면 정말 좋지 않을까요?

이것이 바로 `rush`가 등장하는 지점입니다.
방금 전과 똑같은 작업을 `rush`를 사용하여 수행해 보겠습니다.

```{console rush_tips}
rm percent.csv
rush run -t 'mutate(df, percent = tip / bill * 100)' tips.csv > percent.csv
< percent.csv trim 5
```

`rush`가 모든 상용구를 대신 처리해주기 때문에 이러한 짧은 한 줄 명령어가 가능합니다.
여기서는 `run` 서브 명령어를 사용하고 있습니다. 다음 섹션에서 데이터 시각화를 빠르게 생성할 때 사용할 `plot` 서브 명령어도 있습니다.
입력 데이터를 전달할 때 `rush`는 기본적으로 헤더가 있고 쉼표로 구분된 CSV 형식이라고 가정합니다.
또한 열 이름은 작업하기 쉽도록 정리(sanitized)됩니다.
이러한 기본값들은 각각 `--no-header` (또는 `-H`), `--delimiter` (또는 `-d`), `--no-clean-names` (또는 `-C`) 옵션을 사용하여 변경할 수 있습니다.
도움말을 보면 `run` 서브 명령어에서 사용 가능한 옵션들을 잘 확인할 수 있습니다.

```{console rush_run_help}
rush run --help
```

내부적으로 `rush`는 `R` 스크립트를 생성하고 바로 실행합니다.
`--dry-run` (또는 `-n`) 옵션을 지정하면 이렇게 생성된 스크립트를 확인할 수 있습니다.

```{console rush_dryrun}
rush run -n --tidyverse 'mutate(df, percent = tip / bill * 100)' tips.csv
```

생성된 스크립트는 다음과 같은 일을 합니다.

- 커맨드 라인에서 `R` 스크립트를 실행하는 데 필요한 쉬뱅(*`#!`*; [4장](#chapter-4-creating-command-line-tools) 참조)을 작성합니다.
- *tidyverse*와 *glue* 패키지를 임포트합니다.
- *tips.csv*를 데이터 프레임으로 로드하고 열 이름을 정리한 뒤 `df` 변수에 할당합니다.
- 지정된 표현식을 실행합니다.
- 결과를 표준 출력으로 인쇄합니다.

생성된 스크립트를 파일로 리다이렉션하면 쉬뱅 덕분에 아주 쉽게 새로운 커맨드 라인 도구로 만들 수 있습니다.

`rush`의 출력이 반드시 CSV 형식이어야 할 필요는 없습니다. 여기서는 평균 팁 비율, 최대 일행 인원수, 시간 열의 고유 값들, 전체 금액과 팁 사이의 상관관계를 계산합니다. 마지막으로 열 하나를 통째로 추출합니다 (처음 10개 값만 보여줍니다).

```{console rush_run_more}
< percent.csv rush run 'mean(df$percent)' -
< percent.csv rush run 'max(df$size)' -
< percent.csv rush run 'unique(df$time)' -
< percent.csv rush run 'cor(df$bill, df$tip)' -
< percent.csv rush run 'df$tip' - | trim
```

마지막의 대시(`-`) 기호는 `rush`가 표준 입력을 읽어야 함을 의미합니다.

이제 여러분의 데이터셋에 `R`로 한두 가지 작업을 하고 싶을 때, 이를 한 줄 명령어로 지정하고 계속해서 커맨드 라인에서 작업을 이어 나갈 수 있습니다.
여러분이 이미 알고 있는 `R`에 대한 모든 지식을 이제 커맨드 라인에서 사용할 수 있습니다. `rush`를 사용하면 다음 섹션에서 보여드릴 것처럼 정교한 시각화도 만들 수 있습니다.


## 시각화 생성하기

이 섹션에서는 커맨드 라인에서 데이터 시각화를 생성하는 방법을 보여드리겠습니다.
`rush plot`을 사용하여 막대 그래프, 산점도, 박스 플롯을 만들어 볼 것입니다.
본격적으로 시작하기 전에, 생성한 시각화를 어떻게 표시(display)할 수 있는지 먼저 설명하겠습니다.


### 커맨드 라인에서 이미지 표시하기

*tips.png* 이미지를 예로 들어보겠습니다.
`rush`와 *tips.csv* 데이터셋을 사용하여 생성한 데이터 시각화인 \@ref(fig:plot-demo)를 살펴보십시오.
(`rush` 구문은 잠시 후에 설명하겠습니다.)
저는 책에 이미지를 삽입하기 위해 `display` 도구를 사용하지만, 여러분이 직접 `display` 명령어를 실행하면 작동하지 않을 수도 있습니다.
커맨드 라인에서 이미지를 표시하는 것은 사실 꽤나 까다로운 일이기 때문입니다.

```{console plot_demo_png, include=FALSE}
rush plot --x bill --y tip --color size --facets '~day' tips.csv > tips.png
display tips.png
```
```{r plot-demo, echo=FALSE, fig.cap="이미지를 직접 표시하는 것은 까다로울 수 있습니다", fig.align="center", out.width="90%"}
knitr::include_graphics("images/tips.png")
```

환경 설정에 따라 이미지를 표시하는 몇 가지 옵션이 있습니다.
제가 아는 네 가지 옵션은 각각 장단점이 있습니다.
(1) 텍스트 표현으로 표시,
(2) 인라인(inline) 이미지로 표시,
(3) 이미지 뷰어 사용,
(4) 브라우저 사용.
이들을 빠르게 훑어봅시다.

```{r screenshot-display-ansi-and-inline, echo=FALSE, fig.cap="ASCII 문자와 ANSI 이스케이프 시퀀스를 통해 터미널에 이미지를 표시(위)하거나, iTerm2 인라인 이미지 프로토콜을 사용(아래)하기", fig.align="center"}
knitr::include_graphics("images/screenshot_display_ansi_and_inline.png")
```

옵션 1은 \@ref(fig:screenshot-display-ansi-and-inline)의 상단에 표시된 것처럼 터미널 내부에 이미지를 표시하는 것입니다.
표준 출력이 파일로 리다이렉션되지 않을 때 `rush`가 이 출력을 생성합니다.
이는 ASCII 문자와 ANSI 이스케이프 시퀀스를 기반으로 하므로 모든 터미널에서 사용 가능합니다.
이 책을 읽는 방식에 따라, 코드를 실행했을 때 얻는 출력이 \@ref(fig:screenshot-display-ansi-and-inline)의 스크린샷과 일치할 수도 있고 아닐 수도 있습니다.

```{console plot_demo_ansi, trailing_spaces=TRUE, remove=c(-2, -1)}
rush plot --x bill --y tip --color size --facets '~day' tips.csv
```

만약 ASCII 문자만 보인다면, 이 책을 읽고 있는 매체가 색상을 담당하는 ANSI 이스케이프 시퀀스를 지원하지 않는다는 뜻입니다.
다행히 위 명령어를 직접 실행해 보면 스크린샷과 똑같이 보일 것입니다.

옵션 2는 \@ref(fig:screenshot-display-ansi-and-inline)의 하단에서 볼 수 있듯이 터미널 내부에 이미지를 바로 표시합니다.
이는 macOS에서만 사용 가능한 iTerm2 터미널이며, 작은 스크립트(제가 `display`라고 이름 붙인)를 통해 [인라인 이미지 프로토콜(Inline Images Protocol)](https://iterm2.com/documentation-images.html)을 사용합니다.
이 스크립트는 Docker 이미지에 포함되어 있지 않지만 쉽게 설치할 수 있습니다.

```{console}
curl -s "https://iterm2.com/utilities/imgcat" > display && chmod u+x display#!enter=FALSE
C-C#!literal=FALSE
```

macOS에서 iTerm2를 사용하지 않더라도 인라인으로 이미지를 표시할 수 있는 다른 옵션이 있을 수 있습니다.
선호하는 검색 엔진을 통해 확인해 보시기 바랍니다.

```{r screenshot-display-preview-and-browser, echo=FALSE, fig.cap="파일 탐색기와 이미지 뷰어(왼쪽) 또는 웹 서버와 브라우저(오른쪽)를 통해 외부에서 이미지 표시하기", fig.align="center"}
knitr::include_graphics("images/screenshot_display_preview_and_browser.png")
```

옵션 3은 이미지(이 예제에서는 *tips.csv* [역주: *tips.png*의 오타로 보임])를 이미지 뷰어에서 수동으로 여는 것입니다.
\@ref(fig:screenshot-display-preview-and-browser)의 왼쪽은 macOS의 파일 탐색기(Finder)와 이미지 뷰어(Preview)를 보여줍니다.
로컬에서 작업할 때는 이 옵션이 항상 작동합니다.
Docker 컨테이너 안에서 작업할 때는 `-v` 옵션을 사용하여 로컬 디렉터리를 매핑한 경우에만 운영체제에서 생성된 이미지에 접근할 수 있습니다.
방법에 대해서는 [2장](#chapter-2-getting-started)을 참조하십시오.
이 옵션의 장점은 이미지가 변경되었을 때 대부분의 이미지 뷰어가 자동으로 화면을 갱신해준다는 것입니다. 덕분에 시각화를 미세 조정하면서 빠르게 반복 작업을 할 수 있습니다.

옵션 4는 브라우저에서 이미지를 여는 것입니다.
\@ref(fig:screenshot-display-preview-and-browser)의 오른쪽은 *http://localhost:8000/tips.png*를 보여주는 파이어폭스(Firefox) 스크린샷입니다.
어떤 브라우저든 상관없지만, 이 옵션을 사용하려면 두 가지 전제 조건이 필요합니다.
첫째, `-p` 옵션을 사용하여 Docker 컨테이너의 포트(이 예제에서는 8000번 포트)를 열어두어야 합니다.
(역시 [2장](#chapter-2-getting-started)에 설명되어 있습니다.)
둘째, 웹 서버를 실행해야 합니다.
이를 위해 Docker 컨테이너에는 파이썬을 사용하여 현재 작업 디렉터리를 서비스하는 `servewd` [@servewd]라는 작은 도구가 들어 있습니다.

```{console}
bat $(which servewd)
```

디렉터리(예: */data/*)에서 `servewd`를 한 번만 실행해 두면 백그라운드에서 계속 실행됩니다.
그림을 그린 뒤에는 브라우저에서 *localhost:8000*에 접속하여 해당 디렉터리와 모든 하위 디렉터리의 내용에 접근할 수 있습니다.
기본 포트는 8000번이지만 `servewd`에 인자로 지정하여 변경할 수도 있습니다.

```{console}
servewd 9999#!enter=FALSE
C-C#!literal=FALSE
```

해당 포트에 접근 가능한지만 확인하면 됩니다.
`servewd`는 백그라운드에서 실행되므로 다음과 같이 종료해야 합니다.

```{console}
pkill -f http.server
```

옵션 4는 원격 시스템에서도 작동할 수 있습니다.

이제 이미지를 표시하는 네 가지 옵션을 다루었으니, 실제로 시각화를 만들어 봅시다.


### 서둘러 그림 그리기

데이터 시각화를 생성할 때 가질 수 있는 선택지는 매우 많습니다.
개인적으로 저는 R의 시각화 패키지인 `ggplot2`를 강력하게 지지합니다.
기저에 흐르는 '그래픽 문법(grammar of graphics)'과 그를 따르는 일관된 API 덕분에, 매번 문서를 찾아볼 필요 없이 아름다운 데이터 시각화를 빠르고 반복적으로 만들어낼 수 있습니다.
이는 데이터를 탐색할 때 매우 환영할 만한 특성입니다.

지금 당장 급한(in a rush) 것은 아니지만, 하나의 시각화에 너무 많은 시간을 쏟고 싶지는 않습니다.
또한 가능한 한 커맨드 라인에 머물고 싶습니다.
다행히 우리에게는 커맨드 라인에서 `ggplot2`를 사용할 수 있게 해주는 `rush`가 있습니다.
\@ref(fig:plot-demo)의 시각화는 다음과 같이 만들 수 있었습니다.

```{console rush_ggplot2}
rush run --library ggplot2 'ggplot(df, aes(x = bill, y = tip, color = size)) + geom_point() + facet_wrap(~day)' tips.csv > tips.png#!enter=FALSE
C-C#!literal=FALSE
```

하지만 눈치채셨겠지만, 저는 *tips.png*를 만들기 위해 아주 다른 명령어를 사용했습니다.

```{console rush_plot_again}
rush plot --x bill --y tip --color size --facets '~day' tips.csv > tips.png#!enter=FALSE
C-C#!literal=FALSE
```

`ggplot2`의 구문이 유연성에 비해 상당히 간결하긴 하지만, 기본적인 그래프를 빠르게 생성할 수 있는 지름길이 있습니다.
이 지름길은 `rush`의 `plot` 서브 명령어를 통해 제공됩니다.
덕분에 R이나 그래픽 문법을 배우지 않고도 아름다운 기초 그래프를 만들 수 있습니다.

내부적으로 `rush plot`은 `ggplot2` 패키지의 `qplot` 함수를 사용합니다.
다음은 해당 함수의 문서 중 일부입니다.

```{console}
R -q -e '?ggplot2::qplot' | trim 14
```

저도 이 조언에 동의합니다. 이 책을 다 읽고 나면 `ggplot2`를 배울 가치가 충분하며, 특히 탐색용 시각화를 외부에 전달하기 적합한 수준으로 업그레이드하고 싶다면 더욱 그렇습니다.
지금은 커맨드 라인에 있으니 지름길을 택해 봅시다.

\@ref(fig:screenshot-display-ansi-and-inline)에서 이미 보았듯이, `rush plot`은 동일한 구문으로 그래픽 시각화(픽셀로 구성)와 텍스트 시각화(ASCII 문자와 ANSI 이스케이프 시퀀스로 구성)를 모두 만들 수 있습니다.
`rush`가 자신의 출력이 다른 명령어로 파이프되거나(예: `display`) 파일로 리다이렉션되는 것을 감지하면 그래픽 시각화를 생성하고, 그렇지 않으면 텍스트 시각화를 생성합니다.

잠시 시간을 내어 `rush plot`의 그래프 생성 및 저장 옵션들을 읽어봅시다.

```{console}
rush plot --help
```

가장 중요한 옵션은 *`<name>`*을 인자로 받는 그래프 옵션들입니다.
예를 들어 `--x` 옵션은 x축을 따라 물체들이 놓일 위치를 결정하는 데 어떤 열을 사용할지 지정해 줍니다.
`--y` 옵션도 마찬가지입니다.
`--color`와 `--fill` 옵션은 색상을 입히는 데 사용할 열을 지정합니다.
`--size`와 `--alpha` 옵션이 무엇에 관한 것인지는 아마 짐작하실 수 있을 것입니다.
기타 공통 옵션들은 다양한 시각화를 직접 만들어 보면서 각 섹션에서 설명하겠습니다.
각 시각화에 대해 먼저 텍스트 표현(ASCII 및 ANSI 문자)을 보여드린 다음, 실제 그래픽 표현(픽셀)을 보여드리겠습니다.


### 막대 그래프(Bar Charts) 생성하기

막대 그래프는 범주형 특성의 값 개수(counts)를 표시하는 데 특히 유용합니다.
다음은 tips 데이터셋의 *time* 특성에 대한 텍스트 시각화입니다.

```{console plot_bar_ansi, trailing_spaces=TRUE, remove=c(-2, -1)}
rush plot --x time tips.csv
```

\@ref(fig:plot-bar-image)는 출력이 파일로 리다이렉션될 때 `rush plot`이 생성하는 그래픽 시각화입니다.

```{console plot_bar_png}
rush plot --x time tips.csv > plot-bar.png
display plot-bar.png
```
```{r plot-bar-image, echo=FALSE, fig.cap="막대 그래프", fig.align="center", out.width="90%"}
knitr::include_graphics("images/plot-bar.png")
```

이 막대 그래프로부터 내릴 수 있는 결론은 간단합니다. 점심(lunch)보다 저녁(dinner) 데이터 포인트가 두 배 이상 많다는 것입니다.


### 히스토그램(Histograms) 생성하기

연속형 변수의 개수는 히스토그램으로 시각화할 수 있습니다.
여기서는 *time* 특성을 사용하여 채우기(fill) 색상을 설정했습니다.
그 결과, `rush plot`은 편리하게도 누적 히스토그램(stacked histogram)을 생성합니다.

```{console plot_histogram_ansi, trailing_spaces=TRUE, remove=c(-2, -1)}
rush plot --x tip --fill time tips.csv
```

\@ref(fig:plot-histogram-image)는 그래픽 시각화를 보여줍니다.

```{block2, type="rmdtip"}
유용하게 쓰일 수 있는 두 가지 구문 지름길(shortcuts)을 보여드리겠습니다.
두 개의 느낌표(`!!`)는 이전 명령어로 대체됩니다.
느낌표와 달러 기호(`!$`)는 이전 명령어의 마지막 부분인 파일명 *plot-histogram.png*로 대체됩니다.
보시는 것처럼, Z 쉘이 업데이트된 명령어를 먼저 출력해주므로 무엇이 실행되는지 정확히 알 수 있습니다.
이 두 지름길은 타이핑 양을 크게 줄여주지만, 기억하기가 쉽지는 않습니다.
```

```{console plot_histogram_png}
!! > plot-histogram.png
display !$
```
```{r plot-histogram-image, echo=FALSE, fig.cap="히스토그램", fig.align="center", out.width="90%"}
knitr::include_graphics("images/plot-histogram.png")
```

이 히스토그램은 대부분의 팁이 2.5달러 근처임을 보여줍니다.
저녁과 점심 두 그룹이 서로 겹쳐 쌓여 있고 절대적인 개수를 보여주기 때문에 서로 비교하기가 어렵습니다.
아마도 밀도 그래프(density plot)가 도움이 될 수 있을 것 같습니다.


### 밀도 그래프(Density Plots) 생성하기

밀도 그래프는 연속형 변수의 분포를 시각화하는 데 유용합니다.
`rush plot`은 적절한 도형(geometry)을 결정하기 위해 휴리스틱을 사용하지만, `geom` 옵션을 사용하여 이를 직접 지정할 수 있습니다.

```{console plot_density_ansi, trailing_spaces=TRUE, remove=c(-2, -1)}
rush plot --x tip --fill time --geom density tips.csv
```

이 경우에는 텍스트 시각화가 \@ref(fig:plot-density-image)의 그래픽 시각화와 비교했을 때 확실히 한계가 있음을 보여줍니다.

```{console plot_density_png}
rush plot --x tip --fill time --geom density tips.csv > plot-density.png
display plot-density.png
```
```{r plot-density-image, echo=FALSE, fig.cap="밀도 그래프", fig.align="center", out.width="90%"}
knitr::include_graphics("images/plot-density.png")
```


### 행복한 사고(Happy Little Accidents)

여러분은 이미 세 가지 유형의 시각화를 보았습니다.
`ggplot2`에서 이들은 각각 `geom_bar`, `geom_histogram`, `geom_density` 함수에 해당합니다.
*geom*은 기하학(geometry)의 약자로, 실제로 무엇을 그릴지 지시합니다.
이 [`ggplot2` 컨닝 페이퍼](https://ggplot2.tidyverse.org/)는 사용 가능한 도형 유형에 대한 좋은 개요를 제공합니다.
사용할 수 있는 도형 유형은 지정한 열(및 그 유형)에 따라 달라집니다.
모든 조합이 의미가 있는 것은 아닙니다.
이 선 그래프(line plot)를 예로 들어보겠습니다.

```{console plot_accident_ansi, trailing_spaces=TRUE, remove=c(-2, -1)}
rush plot --x tip --y bill --color size --size day --geom path tips.csv
```

이 행복한 사고(역주: 밥 로스가 말하던 'Happy Accident'를 인용한 듯함)는 \@ref(fig:plot-accident-image)의 그래픽 표현에서 더 분명해집니다.

```{console plot_accident_png}
rush plot --x tip --y bill --color size --size day --geom path tips.csv > plot-accident.png
display plot-accident.png
```
```{r plot-accident-image, echo=FALSE, fig.cap="행복한 사고", fig.align="center", out.width="90%"}
knitr::include_graphics("images/plot-accident.png")
```

*tips.csv*의 행들은 독립적인 관측치인 반면, 데이터 포인트 사이에 선을 긋는 것은 그들이 서로 연결되어 있다고 가정하는 것입니다.
*tip*과 *bill* 사이의 관계를 시각화하려면 산점도(scatter plot)를 사용하는 것이 더 낫습니다.


### 산점도(Scatter Plots) 생성하기

산점도는 도형이 점(point)인 그래프로, 두 개의 연속형 특성을 지정했을 때 기본적으로 선택됩니다.

```{console plot_scatter_ansi, trailing_spaces=TRUE, remove=c(-2, -1)}
rush plot --x bill --y tip --color time tips.csv
```

각 점의 색상은 `--color` 옵션(채우기 옵션인 `--fill`이 아닙니다)으로 지정된다는 점에 유의하십시오.
그래픽 표현은 \@ref(fig:plot-scatter-image)를 참조하십시오.

```{console plot_scatter_png}
rush plot --x bill --y tip --color time tips.csv > plot-scatter.png
display plot-scatter.png
```
```{r plot-scatter-image, echo=FALSE, fig.cap="산점도", fig.align="center", out.width="90%"}
knitr::include_graphics("images/plot-scatter.png")
```

이 산점도로부터 우리는 전체 금액(bill)과 팁(tip) 사이에 관계가 있다는 결론을 내릴 수 있습니다.
아마도 추세선(trend lines)을 만들어 더 높은 수준에서 이 데이터를 검토하는 것이 유용할 것입니다.


### 추세선(Trend Lines) 생성하기

기본 도형을 *`smooth`*로 변경하면 추세선을 시각화할 수 있습니다.
이는 전체적인 그림을 파악하는 데 유용합니다.

```{console plot_trend_ansi, trailing_spaces=TRUE, remove=c(-2, -1)}
rush plot --x bill --y tip --color time --geom smooth tips.csv
```

`rush plot`은 투명도를 처리할 수 없으므로, 이 경우에는 \@ref(fig:plot-trend-image)와 같은 그래픽 표현이 훨씬 낫습니다.

```{console plot_trend_png}
rush plot --x bill --y tip --color time --geom smooth tips.csv > plot-trend.png
display plot-trend.png
```
```{r plot-trend-image, echo=FALSE, fig.cap="추세선", fig.align="center", out.width="90%"}
knitr::include_graphics("images/plot-trend.png")
```

추세선과 함께 원래의 점들도 시각화하고 싶다면 `rush run`을 사용하여 직접 `ggplot2` 코드를 작성해야 합니다 (\@ref(fig:plot-trend-points-image) 참조).

```{console plot_trend_points_png}
rush run --library ggplot2 'ggplot(df, aes(x = bill, y = tip, color = time)) + geom_point() + geom_smooth()' tips.csv > plot-trend-points.png
display plot-trend-points.png
```
```{r plot-trend-points-image, echo=FALSE, fig.cap="추세선과 원래 점들이 결합된 모습", fig.align="center", out.width="90%"}
knitr::include_graphics("images/plot-trend-points.png")
```


### 박스 플롯(Box Plots) 생성하기

박스 플롯은 하나 이상의 특성에 대해 다섯 수치 요약(최솟값, 최댓값, 표본 중앙값, 제1 및 제3 사분위수)을 시각화합니다.
이 경우 *size* 특성을 `factor()` 함수를 사용하여 범주형으로 변환해야 합니다. 그렇지 않으면 *bill* 특성의 모든 값이 하나로 뭉쳐지게 됩니다.

```{console plot_boxplot_ansi, trailing_spaces=TRUE, remove=c(-2, -1)}
rush plot --x 'factor(size)' --y bill --geom boxplot tips.csv
```

텍스트 표현도 나쁘지는 않지만, 그래픽 표현이 훨씬 더 명확합니다 (\@ref(fig:plot-boxplot-image) 참조).

```{console plot_boxplot_png}
rush plot --x 'factor(size)' --y bill --geom boxplot tips.csv > plot-boxplot.png
display plot-boxplot.png
```
```{r plot-boxplot-image, echo=FALSE, fig.cap="박스 플롯", fig.align="center", out.width="90%"}
knitr::include_graphics("images/plot-boxplot.png")
```

당연하게도, 이 박스 플롯은 평균적으로 일행 인원수가 많을수록 전체 금액이 더 높아짐을 보여줍니다.


### 레이블 추가하기

기본 레이블은 열 이름(또는 명세)을 기반으로 합니다.
이전 이미지에서 *`factor(size)`*라는 레이블은 개선될 필요가 있습니다.
`--xlab` 및 `--ylab` 옵션을 사용하여 x축과 y축의 레이블을 변경할 수 있습니다.
제목은 `--title` 옵션으로 추가할 수 있습니다.
다음은 이를 보여주는 바이올린 플롯(박스 플롯과 밀도 그래프를 혼합한 것)입니다 (\@ref(fig:plot-labels-image) 참조).

```{console plot_labels_ansi, trailing_spaces=TRUE, remove=c(-2, -1)}
rush plot --x 'factor(size)' --y bill --geom violin --title '일행 인원수별 전체 금액 분포' --xlab '일행 인원수' --ylab '전체 금액 (USD)' tips.csv
```

```{console plot_labels_png}
rush plot --x 'factor(size)' --y bill --geom violin --title '일행 인원수별 전체 금액 분포' --xlab '일행 인원수' --ylab '전체 금액 (USD)' tips.csv > plot-labels.png
display plot-labels.png
```
```{r plot-labels-image, echo=FALSE, fig.cap="제목과 레이블이 추가된 바이올린 플롯", fig.align="center", out.width="90%"}
knitr::include_graphics("images/plot-labels.png")
```

적절한 레이블과 제목을 시각화에 추가하는 것은 다른 사람(또는 미래의 자신)과 공유할 때 무엇을 보여주고 있는지 더 쉽게 이해할 수 있게 해주므로 특히 유용합니다.


### 기초적인 그래프 그 이상으로

데이터를 탐색할 때 기초적인 그래프를 만드는 데는 `rush plot`이 적합하지만, 분명히 한계가 있습니다.
때로는 여러 도형을 겹쳐 그리거나 좌표계 변환, 테마 적용과 같이 더 유연하고 정교한 옵션이 필요할 때가 있습니다.
그럴 경우에는 `rush plot`의 기능이 기반하고 있는 R 패키지인 `ggplot2`에 대해 더 배워보는 것이 가치 있을 것입니다.
만약 R보다 파이썬을 더 좋아하신다면 파이썬용 `ggplot2` 재구현체인 [`plotnine` 패키지](https://plotnine.readthedocs.io)가 있습니다.


## 요약

이 장에서는 데이터를 탐색하는 다양한 방법을 살펴보았습니다.
텍스트 기반 시각화와 그래픽 기반 시각화 모두 장단점이 있습니다.
그래픽 시각화는 분명히 품질이 훨씬 높지만 커맨드 라인에서 보기가 까다로울 수 있습니다.
이때 텍스트 시각화가 유용하게 쓰입니다.
최소한 `rush`는 `R`과 `ggplot2` 덕분에 두 가지 유형 모두에 대해 일관된 구문을 제공합니다.

다음 장은 다시 한번 '인터메조(intermezzo)' 장으로, 명령어와 파이프라인의 속도를 높이는 방법을 다룹니다.
[9장](#chapter-9-modeling-data)에서 데이터 모델링을 시작하고 싶어 견딜 수 없다면 이 장은 나중에 읽으셔도 좋습니다.


## 더 읽어보기

- 아쉽게도 제대로 된 `ggplot2` 튜토리얼은 이 책의 범위를 벗어납니다. 데이터 시각화 능력을 키우고 싶다면 그래픽 문법의 힘과 아름다움을 이해하는 데 시간을 투자하시기를 강력히 권장합니다. Hadley Wickham과 Garrett Grolemund의 저서 [*R for Data Science*](https://r4ds.had.co.nz/)의 3장과 28장은 훌륭한 자료입니다.
- 3장과 28장 이야기가 나와서 말인데, 만약 R보다 파이썬을 선호하신다면 제가 [Plotnine과 Pandas를 사용하여 해당 장들을 파이썬으로 번역해둔 자료](https://datascienceworkshops.com/blog/plotnine-grammar-of-graphics-for-python/)가 있습니다.
