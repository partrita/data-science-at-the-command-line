#!/usr/bin/env python

# - tools.yaml 로드
# - box를 사용하여 버전 가져오기
# - 부록을 만들고 파일로 쓰기
# - bigtable을 만들고 파일로 쓰기


import logging
import subprocess
from yaml import load, dump

log_format = '%(asctime)-15s [%(levelname).3s] %(message)s'
logging.basicConfig(format=log_format, level=logging.WARNING)
log = logging.getLogger('process-tools')

def get_version(tool):
    error = 0
    version = None
    command = None
    if 'version_cmd' in tool:
        command = tool['version_cmd']
    elif 'manager' in tool:
        package = tool.get('package') or tool['command']
        if tool['manager'] == 'pip':
            command = "pip show {package} | grep Version | cut -d' ' -f2".format(package=package)
        elif tool['manager'] == 'apt':
            command = "dpkg-query -p {package} | grep Version | tr - ' ' | cut -d' ' -f2".format(package=package)
    if command:
        ssh_command = "ssh -p 2200 -i /home/jeroen/.vagrant.d/insecure_private_key vagrant@localhost \"source ~/.profile;{command}\"".format(command=command)
        p = subprocess.Popen(ssh_command, stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)
        output, errors = p.communicate()
        if len(errors) > 0:
            log.error("%s", errors)
            error = 1
        version = output.strip()
        if len(version) < 1:
            error = 1
            log.warn("%s has version %s" % (tool['command'], version))
    return version, error

def run_example(tool):
    example_output = None
    if 'example' in tool:
        if 'output' in tool:
            return tool['output']
        command = tool['example']
        if command:
            command = command.replace('\\','\\\\')
            command = command.replace('"','\\"')
            command = command.replace('$','\$')
            command = command.replace('[','\[')
            command = command.replace(']','\]')
            ssh_command = "ssh -p 2200 -i /home/jeroen/.vagrant.d/insecure_private_key vagrant@localhost \"source ~/.profile;{command}\"".format(command=command)
            log.debug("Executing: %s", ssh_command)
            p = subprocess.Popen(ssh_command, stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)
            output, errors = p.communicate()
            if len(errors) > 0:
                log.error("%s", errors)
                error = 1
            example_output = output.strip() + errors.strip()
    return example_output

def get_type(tool):
    if 'type' in tool:
        return tool['type']
    command = "type -t %s" % tool['command']
    ssh_command = "ssh -p 2200 -i /home/jeroen/.vagrant.d/insecure_private_key vagrant@localhost \"source ~/.profile;{command}\"".format(command=command)
    log.debug("Getting type: %s", ssh_command)
    p = subprocess.Popen(ssh_command, stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)
    output, errors = p.communicate()
    if len(errors) > 0:
        log.error("%s", errors)
        error = 1
    if len(output.strip()) < 1:
        log.warn("%s has type %s" % (tool['command'], output))
    return output.strip()

def get_install(tool):
    if 'install_cmd' in tool:
        return tool['install_cmd']
    elif 'manager' in tool:
        package = tool.get('package') or tool['command']
        if tool['manager'] == 'pip':
            command = "sudo pip install {package}"
        elif tool['manager'] == 'apt':
            command = "sudo apt-get install {package}"
        elif tool['manager'] == 'git':
            command = "git clone {package}"
        else:
            return None
        command = command.format(package=package)
    else:
        return None
    return command


def format_tool_reference(t):
    if t['command'] == 'Rio-scatter':
        return None
    if 'website' not in t:
        t['website'] = ''
    if 'year' not in t:
        return None
    if 'author' not in t:
        return None


    t['author_and'] = t['author'].replace(', ', ' and ').replace('and and', 'and')

    return """@webpage{{{command},
    title = {{{name}}},
    url = {{{website}}},
    author = {{{author_and}}},
    year = {{{year}}}
}}

""".format(**t)

def format_tool_appendix(t):

    t['help'] = t.get('help', None)
    if t['help'] == '--help': t['format_help'] = '%s --help' % t['command']
    elif t['help'] == '-h': t['format_help'] = '%s -h' % t['command']
    elif t['help'] == 'man': t['format_help'] = 'man %s' % t['command']
    elif t['help'] == 'help': t['format_help'] = 'help %s' % t['command']
    else: t['format_help'] = t['help']

    s =  "\n\n==== %s\n\n%s" % (t['command'], t['description'])


    s += " %s" % t['name']
    if t.get('version', None):
        s+= " (버전 %s)" % t['version']
    if t.get('type', None) == "builtin":
        s+= "은 Bash 내장 명령입니다"
    elif t.get('type', None) == "keyword":
        s+= "은 Bash 키워드입니다"
    if 'author' in t and len(t['author']) > 2:
        s+= " 저자: %s (%d)" % (t['author'].replace('{','').replace('}',''), t['year'])
    s += "."
    if 'website' in t:
        w = t['website']
        if w.endswith('/'):
            log.warn("Removing trailing slash of: %s", w)
            w == w[:-2]
        s+= " %s." % w
    s += "\n\n[source,console]\n----\n"
    if t.get('type', None) not in ["keyword","builtin"] and t.get('install_cmd', None):
        s += "$ %s\n" % t['install_cmd']
    if t['format_help']:
        s += "$ %s\n" % t['format_help']
    if t.get('example', None):
        s += "$ %s\n" % t['example']
        if t.get('output', None):
            s += "%s\n" % t['output']
    s+= "----\n"
    return s


def sanitize_tool(tool):
    error = 0

    for attr in [
        'author',
        'description',
    ]:
        if attr not in tool or tool[attr] is None:
            log.error("Tool %s missing '%s'", tool['command'], attr)
            error += 1

    for attr in [
        'help',
        'author',
        'manager',
    ]:
        if attr not in tool or tool[attr] is None:
            log.warning("Tool %s missing '%s'", tool['command'], attr)

    tool['name'] = tool.get('name') or tool['command'].title()

    return tool, error


def process_tools(tools_list):

    appendix = """:source-highlighter: pygments
:icons:
:data-uri:

[appendix]
== 명령줄 도구 목록

이 책에서 논의된 모든 명령줄 도구의 개요입니다. 여기에는 이진 실행 파일, 해석된 스크립트, Bash 내장 명령 및 키워드가 포함됩니다. 각 명령줄 도구에 대해 사용 가능하고 적절한 경우 다음 정보가 제공됩니다.

* 명령줄에 입력할 실제 명령.
* 설명.
* 속한 패키지의 이름.
* 책에서 사용된 버전.
* 해당 버전이 출시된 연도.
* 기본 작성자.
* 자세한 정보를 찾을 수 있는 웹사이트.
* 설치 방법.
* 도움말을 얻는 방법.
* 사용 예.

여기에 나열된 모든 명령줄 도구는 명령줄에서의 데이터 과학을 위한 데이터 과학 도구 상자에 포함되어 있습니다. 설정 방법에 대한 지침은 2장을 참조하십시오. 설치 명령은 Ubuntu 14.04를 실행하고 있다고 가정합니다. 오픈 소스 소프트웨어를 인용하는 것은 간단하지 않으며 일부 정보가 누락되거나 정확하지 않을 수 있습니다.

"""

    references = ""

    tools = {t['command']: t for t in tools_list}
    total_errors = 0
    log.info("Found %d command-line tools", len(tools))

    for command, tool in sorted(tools.items(), key=lambda k_v: k_v[0].lower()): # k_v 대신 (k,v) 사용
        log.debug("processing: %s", command)

        # 다른 도구에서 속성 복사
        if 'copy' in tool:
            for other_tool, attrs in tool['copy'].items():
                for attr in attrs:
                    log.debug("Copying '%s' from '%s'", attr, other_tool)
                    tool[attr] = tools[other_tool][attr]

        # 속성 확인
        tool, error = sanitize_tool(tool)
        if error > 0:
            total_errors += 1
            continue

        # 버전 가져오기
        tool['version'], error = get_version(tool)
        if error > 0:
            total_errors += 1
            continue

        # 설치 명령 가져오기
        tool['install_cmd'] = get_install(tool)

        # 예제 실행
        tool['output'] = run_example(tool)

        # 유형 가져오기
        tool['type'] = get_type(tool)

        #print tool['command'], tool['version'], tool['install']
        appendix += format_tool_appendix(tool)
        ref = format_tool_reference(tool)
        if ref:
            references += ref

    if total_errors > 0:
        log.error("Still %d command-line tools have errors", total_errors)

    with open('output/chapters/tools2.asciidoc', 'w') as f:
        f.write(appendix)

    with open('tools2.bib', 'w') as f:
        f.write(references)

if __name__ == '__main__':

    with open('tools.yml', 'r') as f:
       process_tools(load(f.read()))
