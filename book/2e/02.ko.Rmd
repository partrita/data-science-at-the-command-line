---
suppress-bibliography: true
---

```{r console_start, include=FALSE}
console_start()
```

```{console setup_history, include=FALSE}
 export CHAPTER="02"
 export HISTFILE=/history/history_${CHAPTER}
 rm -f $HISTFILE
```


# 시작하기 {#chapter-2-getting-started}

이 장에서는 명령줄에서 데이터 과학을 수행하기 위한 모든 전제 조건이 갖추어졌는지 확인합니다.
전제 조건은 세 부분으로 나뉩니다. (1) 이 책에서 사용하는 동일한 데이터 세트를 갖는 것, (2) 이 책 전체에서 사용하는 모든 명령줄 도구가 포함된 적절한 환경을 갖추는 것, (3) 명령줄을 사용할 때 필요한 필수 개념을 이해하는 것입니다.

먼저 데이터 세트를 다운로드하는 방법을 설명합니다.
둘째, 필요한 모든 명령줄 도구가 포함된 Ubuntu Linux 기반 가상 환경인 Docker 이미지를 설치하는 방법을 설명합니다.
그런 다음 예제를 통해 필수적인 Unix 개념을 살펴봅니다.

이 장이 끝나면 데이터 과학의 첫 번째 단계인 데이터 획득을 계속하는 데 필요한 모든 것을 갖추게 됩니다.


## 데이터 가져오기

이 책에서 사용하는 데이터 세트는 다음과 같이 다운로드할 수 있습니다.

1. https://www.datascienceatthecommandline.com/2e/data.zip에서 ZIP 파일을 다운로드합니다.
2. 새 디렉터리를 만듭니다. 이 디렉터리에 원하는 이름을 지정할 수 있지만 명령줄에서 작업하기 쉽도록 소문자, 숫자, 하이픈 또는 밑줄을 사용하는 것이 좋습니다. 예를 들어 *dsatcl2e-data*입니다. 이 디렉터리가 어디에 있는지 기억하십시오.
3. ZIP 파일을 해당 새 디렉터리로 이동하고 압축을 풉니다.
4. 이 디렉터리에는 이제 장별 하위 디렉터리가 하나씩 포함되어 있습니다.

다음 섹션에서는 이 데이터로 작업하기 위한 모든 명령줄 도구가 포함된 환경을 설치하는 방법을 설명합니다.


## Docker 이미지 설치 {#docker-image}

이 책에서는 다양한 명령줄 도구를 사용합니다.
Unix에는 종종 많은 명령줄 도구가 사전 설치되어 제공되며 더 관련 있는 도구가 포함된 많은 패키지를 제공합니다.
이러한 패키지를 직접 설치하는 것은 종종 그리 어렵지 않습니다.
그러나 패키지로 제공되지 않고 더 수동적이고 복잡한 설치가 필요한 도구도 사용할 것입니다.
각 도구의 설치 프로세스를 거치지 않고 필요한 명령줄 도구를 얻으려면 Windows, macOS 또는 Linux 사용자이든 이 책을 위해 특별히 만들어진 Docker 이미지를 설치하는 것이 좋습니다.

Docker 이미지는 하나 이상의 응용 프로그램과 모든 종속성을 함께 묶은 것입니다.
Docker 컨테이너는 이미지를 실행하는 격리된 환경입니다.
`docker` 명령줄 도구(아래에서 수행할 작업) 또는 Docker GUI를 사용하여 Docker 이미지와 컨테이너를 관리할 수 있습니다.
어떤 면에서 Docker 컨테이너는 가상 머신과 같지만 Docker 컨테이너는 훨씬 적은 리소스를 사용합니다.
이 장의 끝에서는 Docker에 대해 자세히 알아볼 수 있는 몇 가지 자료를 제안합니다.

```{block2, type="rmdtip"}
Docker 컨테이너 내부가 아닌 기본적으로 명령줄 도구를 실행하는 것을 선호한다면 물론 명령줄 도구를 직접 개별적으로 설치할 수 있습니다.
이는 매우 시간이 많이 걸리는 프로세스라는 점에 유의하십시오.
부록에는 이 책에서 사용된 모든 명령줄 도구가 나열되어 있습니다.
설치 지침은 Ubuntu 전용입니다.
이 책에서 사용된 스크립트와 데이터 세트는 이 책의 [GitHub 저장소](https://github.com/datasciencetoolbox/datasciencetoolbox)를 복제하여 얻을 수 있습니다.
```

Docker 이미지를 설치하려면 먼저 [Docker 웹사이트](https://www.docker.com/products/docker)에서 Docker 자체를 다운로드하여 설치해야 합니다.
Docker가 설치되면 터미널이나 명령 프롬프트에서 다음 명령을 호출하여 Docker 이미지를 다운로드합니다(달러 기호는 입력하지 마십시오).

```{console docker_pull}
docker pull datasciencetoolbox/dsatcl2e#! enter=FALSE
```

```{console docker_pull_cancel, include=FALSE}
C-C #! literal=FALSE
```

다음과 같이 Docker 이미지를 실행할 수 있습니다.

```{console, docker_run}
docker run --rm -it datasciencetoolbox/dsatcl2e#! enter=FALSE
```

```{console, docker_run_cancel, include=FALSE}
C-C #! literal=FALSE
```

이제 필요한 모든 명령줄 도구가 설치된 격리된 환경( *Docker 컨테이너*라고 함) 내부에 있습니다.
다음 명령이 열정적인 소를 생성하면 모든 것이 올바르게 작동하는 것입니다.

```{console cowsay_lets_moove}
cowsay "움직여 봅시다\!"
```

컨테이너 안팎으로 데이터를 가져오려면 볼륨을 추가할 수 있습니다. 즉, 로컬 디렉터리가 컨테이너 내부의 디렉터리에 매핑됩니다.
먼저 새 디렉터리를 만들고 이 새 디렉터리로 이동한 다음 macOS 또는 Linux에서 다음을 실행하는 것이 좋습니다.

```{console docker_run_v}
docker run --rm -it -v "$(pwd)":/data datasciencetoolbox/dsatcl2e#! enter=FALSE
```

```{console, docker_run_v_cancel, include=FALSE}
C-C #! literal=FALSE
```

또는 Windows에서 명령 프롬프트( `cmd`라고도 함)를 사용하는 경우 다음을 실행합니다.

```{console eval=FALSE}
C:\> docker run --rm -it -v "%cd%":/data datasciencetoolbox/dsatcl2e
```

또는 Windows PowerShell을 사용하는 경우 다음을 실행합니다.

```{console eval=FALSE}
PS C:\> docker run --rm -it -v ${PWD}:/data datasciencetoolbox/dsatcl2e
```

위 명령에서 `-v` 옵션은 `docker`에게 현재 디렉터리를 컨테이너 내부의 */data* 디렉터리에 매핑하도록 지시하므로 Docker 컨테이너 안팎으로 데이터를 가져오는 곳입니다.


```{block2, type="rmdnote"}
Docker 이미지에 대해 자세히 알아보려면 [Docker Hub에서 방문](https://hub.docker.com/r/datasciencetoolbox/dsatcl2e)하십시오.
```

완료되면 `exit`를 입력하여 Docker 컨테이너를 종료할 수 있습니다.


## 필수 Unix 개념 {#essential-concepts}

[1장](#chapter-1-introduction)에서는 명령줄이 무엇인지 간략하게 보여주었습니다.
이제 Docker 이미지를 실행하고 있으므로 실제로 시작할 수 있습니다.
이 섹션에서는 명령줄에서 데이터 과학을 편안하게 수행하기 위해 알아야 할 몇 가지 개념과 도구에 대해 설명합니다.
지금까지 주로 그래픽 사용자 인터페이스로 작업했다면 이것은 상당한 변화일 수 있습니다.
하지만 걱정하지 마십시오. 처음부터 시작하여 점차 고급 주제로 넘어갈 것입니다.

```{block2, type="rmdnote"}
이 섹션은 Unix에 대한 완전한 과정이 아닙니다.
데이터 과학 수행과 관련된 개념과 도구만 설명합니다.
Docker 이미지의 장점 중 하나는 이미 많은 것이 설정되어 있다는 것입니다.
더 자세히 알고 싶다면 이 장의 끝에 있는 추가 읽을거리 섹션을 참조하십시오.
```


### 환경

새로운 환경에 방금 로그인했습니다.
무엇이든 하기 전에 이 환경에 대한 높은 수준의 이해를 얻는 것이 좋습니다.
대략 네 가지 계층으로 정의되며, 위에서부터 간략하게 설명합니다.

명령줄 도구

:   무엇보다도 작업하는 명령줄 도구가 있습니다.
해당 명령을 입력하여 사용합니다.
다음 섹션에서 설명할 다양한 유형의 명령줄 도구가 있습니다.
도구의 예로는 `ls` [@ls], `cat` [@cat], `jq` [@jq]가 있습니다.

터미널

:   두 번째 계층인 터미널은 명령을 입력하는 응용 프로그램입니다. 책에 다음 텍스트가 언급되어 있으면 다음과 같습니다.

    ```{console}
    seq 3
    ```

    그러면 터미널에 `seq 3`을 입력하고 **`Enter`** 키를 누릅니다.
(명령줄 도구 `seq` [@seq]는 보시다시피 숫자 시퀀스를 생성합니다.) 달러 기호는 입력하지 않습니다.
이것은 터미널에 입력할 수 있는 명령임을 알려주기 위한 것입니다.
이 달러 기호는 프롬프트라고 합니다.
`seq 3` 아래의 텍스트는 명령의 출력입니다.

셸

:   세 번째 계층은 셸입니다. 명령을 입력하고 **`Enter`** 키를 누르면 터미널이 해당 명령을 셸로 보냅니다. *셸*은 명령을 해석하는 프로그램입니다. 저는 Z 셸을 사용하지만 Bash 및 Fish와 같은 다른 많은 셸을 사용할 수 있습니다.

운영 체제

:   네 번째 계층은 운영 체제이며, 이 경우 GNU/Linux입니다. Linux는 운영 체제의 핵심인 커널의 이름입니다. 커널은 CPU, 디스크 및 기타 하드웨어와 직접 접촉합니다. 커널은 또한 명령줄 도구를 실행합니다. GNU는 GNU's not UNIX의 약자로 기본 도구 세트를 나타냅니다. Docker 이미지는 Ubuntu라는 특정 GNU/Linux 배포판을 기반으로 합니다.


### 명령줄 도구 실행

이제 환경에 대한 기본적인 이해가 되었으므로 몇 가지 명령을 시도해 볼 차례입니다.
터미널에 다음을 입력하고(달러 기호 제외) **`Enter`** 키를 누릅니다.

```{console}
pwd
```

단일 명령줄 도구가 포함된 명령을 방금 실행했습니다.
도구 `pwd` [@pwd]는 현재 있는 디렉터리의 이름을 출력합니다.
기본적으로 로그인하면 홈 디렉터리입니다.

Z 셸 내장 명령인 명령줄 도구 `cd`를 사용하면 다른 디렉터리로 이동할 수 있습니다.

```{console, callouts=c(1, 3, 6, 8, 11)}
cd /data/ch02
pwd
cd ..
pwd
cd ch02
```
<1> */data/ch02* 디렉터리로 이동합니다.
<2> 현재 디렉터리를 인쇄합니다.
<3> 상위 디렉터리로 이동합니다.
<4> 현재 디렉터리를 다시 인쇄합니다.
<5> *ch02* 하위 디렉터리로 이동합니다.

`cd` 뒤의 부분은 이동하려는 디렉터리를 지정합니다.
명령 뒤에 오는 값은 *명령줄 인수* 또는 *옵션*이라고 합니다.
두 개의 점은 상위 디렉터리를 나타냅니다.
참고로 하나의 점은 현재 디렉터리를 나타냅니다.
`cd .`는 아무런 효과가 없지만 다른 곳에서 하나의 점이 사용되는 것을 볼 수 있습니다.
다른 명령을 시도해 보겠습니다.

```{console}
head -n 3 movies.txt
```

여기서는 `head` [@head]에 세 개의 명령줄 인수를 전달합니다.
첫 번째는 옵션입니다.
여기서는 짧은 옵션 `-n`을 사용했습니다.
때로는 짧은 옵션에 긴 변형이 있으며 이 경우 `--lines`가 됩니다.
두 번째는 옵션에 속하는 값입니다.
세 번째는 파일 이름입니다.
이 특정 명령은 */data/ch02/movies.txt* 파일의 처음 세 줄을 출력합니다.


### 다섯 가지 유형의 명령줄 도구

```{console, include=FALSE}
 alias bat='bat --tabs 8 --paging never --terminal-width 70'
```

*명령줄 도구*라는 용어를 많이 사용하지만 지금까지 실제로 무엇을 의미하는지 설명하지 않았습니다.
명령줄에서 실행할 수 있는 *모든 것*에 대한 포괄적인 용어로 사용합니다(\@ref(fig:umbrella) 참조).
내부적으로 각 명령줄 도구는 다음 다섯 가지 유형 중 하나입니다.

- 바이너리 실행 파일
- 셸 내장 명령
- 해석된 스크립트
- 셸 함수
- 별칭

```{r umbrella, echo=FALSE, fig.cap="명령줄 도구라는 용어를 포괄적인 용어로 사용합니다", fig.align="center"}
knitr::include_graphics("images/dscl_0201.png")
```

유형 간의 차이점을 아는 것이 좋습니다.
Docker 이미지와 함께 사전 설치된 명령줄 도구는 대부분 처음 두 가지 유형(바이너리 실행 파일 및 셸 내장 명령)으로 구성됩니다.
다른 세 가지 유형(해석된 스크립트, 셸 함수 및 별칭)을 사용하면 데이터 과학 도구 상자를 더욱 구축하고 더 효율적이고 생산적인 데이터 과학자가 될 수 있습니다.

바이너리 실행 파일

:   바이너리 실행 파일은 고전적인 의미의 프로그램입니다. 바이너리 실행 파일은 소스 코드를 기계 코드로 컴파일하여 만들어집니다. 즉, 텍스트 편집기에서 파일을 열면 읽을 수 없습니다.

셸 내장 명령

:   셸 내장 명령은 이 경우 Z 셸(또는 `zsh`)인 셸에서 제공하는 명령줄 도구입니다. 예로는 `cd`와 `pwd`가 있습니다. 셸 내장 명령은 셸마다 다를 수 있습니다. 바이너리 실행 파일과 마찬가지로 쉽게 검사하거나 변경할 수 없습니다.

해석된 스크립트

:   해석된 스크립트는 바이너리 실행 파일에 의해 실행되는 텍스트 파일입니다. 예로는 Python, R 및 Bash 스크립트가 있습니다. 해석된 스크립트의 한 가지 큰 장점은 읽고 변경할 수 있다는 것입니다. 아래 스크립트는 파일 확장자 *.py* 때문이 아니라 스크립트의 첫 번째 줄이 실행해야 하는 바이너리를 정의하기 때문에 Python에 의해 해석됩니다.

    ```{console bat_fac}
    bat fac.py
    ```

    이 스크립트는 매개변수로 전달하는 정수의 계승을 계산합니다. 다음과 같이 명령줄에서 호출할 수 있습니다.

    ```{console run_fac}
    ./fac.py 5
    ```

    [4장](#chapter-4-creating-command-line-tools)에서는 해석된 스크립트를 사용하여 재사용 가능한 명령줄 도구를 만드는 방법에 대해 자세히 설명합니다.

셸 함수

:   셸 함수는 이 경우 `zsh`에 의해 실행되는 함수입니다. 스크립트와 유사한 기능을 제공하지만 일반적으로 스크립트보다 작습니다(반드시 그런 것은 아님). 또한 더 개인적인 경향이 있습니다. 다음 명령은 위에서 해석된 Python 스크립트와 마찬가지로 전달하는 정수의 계승을 계산하는 `fac`라는 함수를 정의합니다. `seq`를 사용하여 숫자 목록을 생성하고, `paste` [@paste]를 사용하여 해당 숫자를 구분 기호로 `*`를 사용하여 한 줄에 넣고, 이 방정식을 `bc` [@bc]에 전달하여 평가하고 결과를 출력합니다.

    ```{console fac_zsh}
    fac() { (echo 1; seq $1) | paste -s -d\* - | bc; }
    fac 5
    ```

    Z 셸의 구성 파일인 *~/.zshrc* 파일은 셸 함수를 정의하기에 좋은 위치이므로 항상 사용할 수 있습니다.

별칭

:   별칭은 매크로와 같습니다. 특정 명령을 동일한 매개변수(또는 그 일부)로 자주 실행하는 경우 시간을 절약하기 위해 별칭을 정의할 수 있습니다. 별칭은 특정 명령을 계속해서 잘못 입력하는 경우에도 매우 유용합니다(Chris Wiggins는 [유용한 별칭 목록](https://github.com/chrishwiggins/mise/blob/master/sh/aliases-public.sh)을 유지 관리합니다). 다음 명령은 이러한 별칭을 정의합니다.

    ```{console define_alias}
    alias l='ls --color -lhF --group-directories-first'
    alias les=less
    ```

    이제 명령줄에 다음을 입력하면 셸이 발견하는 각 별칭을 해당 값으로 바꿉니다.

    ```{console run_alias}
    cd /data
    l
    cd ch02
    ```

    별칭은 매개변수를 허용하지 않으므로 셸 함수보다 간단합니다. 함수 `fac`는 매개변수 때문에 별칭을 사용하여 정의할 수 없었습니다. 그래도 별칭을 사용하면 많은 키 입력을 절약할 수 있습니다. 셸 함수와 마찬가지로 별칭은 홈 디렉터리에 있는 *.zshrc* 파일에 자주 정의됩니다. 현재 정의된 모든 별칭을 보려면 인수 없이 `alias`를 실행하기만 하면 됩니다. 시도해 보십시오. 무엇이 보입니까?

이 책에서는 해석된 스크립트, 셸 함수 및 별칭과 같이 마지막 세 가지 유형의 명령줄 도구에 주로 초점을 맞출 것입니다.
이는 쉽게 변경할 수 있기 때문입니다.
명령줄 도구의 목적은 명령줄에서의 생활을 더 쉽게 만들고 더 생산적이고 효율적인 데이터 과학자로 만드는 것입니다.
`type`(자체적으로 셸 내장 명령임)을 사용하여 명령줄 도구의 유형을 알아낼 수 있습니다.

```{console type}
type -a pwd
type -a cd
type -a fac
type -a l
```

```{console, include=FALSE}
 alias bat='bat --tabs 8 --paging never --terminal-width 80'
```

`type`은 `pwd`에 대해 세 개의 명령줄 도구를 반환합니다.
이 경우 `pwd`를 입력하면 보고된 첫 번째 명령줄 도구가 사용됩니다.
다음 섹션에서는 명령줄 도구를 결합하는 방법을 살펴보겠습니다.


### 명령줄 도구 결합 {#combining-command-line-tools}

대부분의 명령줄 도구는 Unix 철학[@raymond2003art]을 따르므로 한 가지 작업만 수행하고 매우 잘 수행하도록 설계되었습니다.
예를 들어 명령줄 도구 `grep` [@grep]은 줄을 필터링할 수 있고, `wc` [@wc]는 줄 수를 셀 수 있으며, `sort` [@sort]는 줄을 정렬할 수 있습니다.
명령줄의 강력함은 이러한 작지만 강력한 명령줄 도구를 결합하는 능력에서 비롯됩니다.

이러한 강력함은 이러한 도구의 통신 스트림을 관리함으로써 가능해집니다.
각 도구에는 표준 입력, 표준 출력, 표준 오류라는 세 가지 표준 통신 스트림이 있습니다.
이들은 종종 *`stdin`*, *`stdout`*, *`stderr`*로 약칭됩니다.

표준 출력과 표준 오류 모두 기본적으로 터미널로 리디렉션되므로 일반 출력과 모든 오류 메시지가 화면에 인쇄됩니다.
\@ref(fig:diagram-essential-streams)는 `pwd`와 `rev`[@rev] 모두에 대해 이를 보여줍니다.
`rev`를 실행하면 아무 일도 일어나지 않는 것을 볼 수 있습니다.
이는 `rev`가 입력을 예상하고 기본적으로 키보드에서 누르는 모든 키이기 때문입니다.
문장을 입력하고 **`Enter`** 키를 눌러 보십시오.
`rev`는 즉시 입력을 반대로 응답합니다.
**`Ctrl-D`**를 누르면 입력 전송을 중지할 수 있으며 그 후 `rev`가 중지됩니다.

```{r diagram-essential-streams, echo=FALSE, fig.cap="모든 도구에는 표준 입력(*`stdin`*), 표준 출력(*`stdout`*), 표준 오류(*`stderr`*)라는 세 가지 표준 스트림이 있습니다.", fig.align="center"}
knitr::include_graphics("images/dscl_0202.png")
```

실제로 키보드를 입력 소스로 사용하지 않고 다른 도구에서 생성된 출력과 파일 내용을 사용합니다.
예를 들어 `curl`을 사용하면 Lewis Carrol의 책 *이상한 나라의 앨리스*를 다운로드하고 다음 도구로 *파이프*할 수 있습니다.
(`curl`에 대해서는 [3장](#chapter-3-obtaining-data)에서 자세히 설명합니다.)
이는 파이프 연산자(`|`)를 사용하여 수행됩니다.

```{r diagram-essential-pipe, echo=FALSE, fig.cap="도구의 출력을 다른 도구로 파이프할 수 있습니다.", fig.align="center"}
knitr::include_graphics("images/dscl_0203.png")
```

`curl`의 출력을 `grep`으로 *파이프*하여 패턴으로 줄을 필터링할 수 있습니다.
목차에 나열된 장을 보고 싶다고 상상해 보십시오.
다음과 같이 `curl`과 `grep`을 결합할 수 있습니다.

```{console}
curl -s "https://www.gutenberg.org/files/11/11-0.txt" | grep " CHAPTER"
```

그리고 책에 장이 *몇 개* 있는지 알고 싶다면 계산에 매우 능숙한 `wc`를 사용할 수 있습니다.

```{console seq_grep_wc, callouts="wc"}
curl -s "https://www.gutenberg.org/files/11/11-0.txt" |
grep " CHAPTER" |
wc -l
```
<1> `-l` 옵션은 `wc`가 전달된 줄 수만 출력하도록 지정합니다. 기본적으로 문자 수와 단어 수도 반환합니다.

파이핑은 자동화된 복사 및 붙여넣기로 생각할 수 있습니다.
파이프 연산자를 사용하여 도구를 결합하는 데 익숙해지면 여기에는 사실상 제한이 없다는 것을 알게 될 것입니다.


### 입력 및 출력 리디렉션

한 도구에서 다른 도구로 출력을 파이핑하는 것 외에도 파일에 저장할 수도 있습니다.
전체 경로가 지정되지 않으면 파일은 현재 디렉터리에 저장됩니다.
이것을 *출력 리디렉션*이라고 하며 다음과 같이 작동합니다.

```{console seq_redirect}
curl "https://www.gutenberg.org/files/11/11-0.txt" | grep " CHAPTER" > chapters.txt
cat chapters.txt
```

여기서는 `grep`의 출력을 */data/ch02* 디렉터리의 *chapters.txt*라는 파일에 저장합니다.
이 파일이 아직 존재하지 않으면 생성됩니다.
이 파일이 이미 존재하면 내용이 덮어쓰여집니다.
\@ref(fig:diagram-essential-redirect-stdout)은 출력 리디렉션이 개념적으로 어떻게 작동하는지 보여줍니다.
표준 오류는 여전히 터미널로 리디렉션됩니다.

```{r diagram-essential-redirect-stdout, echo=FALSE, fig.cap="도구의 출력을 파일로 리디렉션할 수 있습니다.", fig.align="center"}
knitr::include_graphics("images/dscl_0204.png")
```

`>>`를 사용하여 파일에 출력을 추가할 수도 있습니다. 즉, 출력이 원래 내용 뒤에 추가됩니다.

```{console echo_append}
echo -n "안녕하세요" > greeting.txt
echo " 세상" >> greeting.txt
```

`echo` 도구는 지정한 값을 출력합니다.
*줄 바꿈*을 의미하는 `-n` 옵션은 `echo`가 후행 줄 바꿈을 출력하지 않도록 지정합니다.

출력을 파일에 저장하는 것은 예를 들어 나중에 분석을 계속하기 위해 중간 결과를 저장해야 하는 경우에 유용합니다.
*greeting.txt* 파일의 내용을 다시 사용하려면 파일을 읽고 인쇄하는 `cat`을 사용할 수 있습니다.

```{console, callouts="wc"}
cat greeting.txt
cat greeting.txt | wc -w
```
<1> `-w` 옵션은 `wc`가 단어만 계산하도록 나타냅니다.

작음 기호(`<`)를 사용하여 동일한 결과를 얻을 수 있습니다.

```{console}
< greeting.txt wc -w
```

이렇게 하면 추가 프로세스를 실행하지 않고 파일을 `wc`의 표준 입력으로 직접 전달합니다[^cat].
\@ref(fig:diagram-essential-stdin-cat)은 이 두 가지 방법이 어떻게 작동하는지 보여줍니다.
다시 말하지만 최종 출력은 동일합니다.

```{r diagram-essential-stdin-cat, echo=FALSE, fig.cap="파일 내용을 입력으로 사용하는 두 가지 방법", fig.align="center"}
knitr::include_graphics("images/dscl_0205.png")
```

많은 명령줄 도구와 마찬가지로 `wc`는 하나 이상의 파일 이름을 인수로 지정할 수 있습니다.
예를 들면 다음과 같습니다.

```{console}
wc -w greeting.txt movies.txt
```

이 경우 `wc`는 파일 이름도 출력합니다.


*/dev/null*이라는 특수 파일로 리디렉션하여 모든 도구의 출력을 표시하지 않을 수 있습니다.
오류 메시지를 표시하지 않기 위해 종종 이렇게 합니다(\@ref(fig:diagram-essential-redirect-devnull) 그림 참조).
다음은 *404.txt* 파일을 찾을 수 없기 때문에 `cat`이 오류 메시지를 생성하도록 합니다.

```{console}
cat movies.txt 404.txt
```

다음과 같이 표준 오류를 */dev/null*로 리디렉션할 수 있습니다.

```{console callouts=1}
cat movies.txt 404.txt 2> /dev/null
```
<1> *`2`*는 표준 오류를 나타냅니다.

```{r diagram-essential-redirect-devnull, echo=FALSE, fig.cap="*`stderr`*를 */dev/null*로 리디렉션", fig.align="center", out.width="50%"}
knitr::include_graphics("images/dscl_0206.png")
```

동일한 파일에서 읽고 쓰지 않도록 주의하십시오.
그렇게 하면 빈 파일이 됩니다.
출력이 리디렉션되는 도구가 즉시 쓰기 위해 해당 파일을 열고 비우기 때문입니다.
이에 대한 두 가지 해결 방법이 있습니다. (1) 다른 파일에 쓰고 나중에 `mv`로 이름을 바꾸거나 (2) 파일에 쓰기 전에 모든 입력을 흡수하는 `sponge` [@sponge]를 사용합니다.
\@ref(fig:diagram-essential-sponge)은 이것이 어떻게 작동하는지 보여줍니다.

```{r diagram-essential-sponge, echo=FALSE, fig.cap="`sponge`를 사용하지 않으면 한 파이프라인에서 동일한 파일에서 읽고 쓸 수 없습니다.", fig.align="center"}
knitr::include_graphics("images/dscl_0207.png")
```

예를 들어 `dseq`[@dseq]를 사용하여 *dates.txt* 파일을 생성했고 이제 `nl`[@nl]을 사용하여 줄 번호를 추가하고 싶다고 상상해 보십시오.
다음을 실행하면 *dates.txt* 파일이 비게 됩니다.

```{console}
dseq 5 > dates.txt
< dates.txt nl > dates.txt
bat dates.txt
```

대신 방금 설명한 해결 방법 중 하나를 사용할 수 있습니다.

```{console}
dseq 5 > dates.txt
< dates.txt nl > dates-nl.txt
bat dates-nl.txt
dseq 5 > dates.txt
< dates.txt nl | sponge dates.txt
bat dates.txt
```


### 파일 및 디렉터리 작업

데이터 과학자로서 우리는 많은 데이터를 다룹니다.
이 데이터는 종종 파일에 저장됩니다.
명령줄에서 파일(및 해당 파일이 있는 디렉터리)로 작업하는 방법을 아는 것이 중요합니다.
GUI를 사용하여 수행할 수 있는 모든 작업은 명령줄 도구로 수행할 수 있습니다(그리고 훨씬 더 많은 작업).
이 섹션에서는 파일 및 디렉터리를 나열, 생성, 이동, 복사, 이름 바꾸기 및 삭제하는 가장 중요한 도구를 소개합니다.

디렉터리 내용을 나열하는 것은 `ls`로 수행할 수 있습니다.
디렉터리를 지정하지 않으면 현재 디렉터리의 내용을 나열합니다.
저는 `ls`가 긴 목록 형식을 갖고 파일 앞에 디렉터리가 그룹화되는 것을 선호합니다.
해당 옵션을 매번 입력하는 대신 별칭 `l`을 사용합니다.

```{console}
ls /data/ch10
alias l
l /data/ch10
```

`>` 또는 `>>`를 사용하여 출력을 리디렉션하여 새 파일을 만드는 방법을 이미 보았습니다.
파일을 다른 디렉터리로 이동해야 하는 경우 `mv` [@mv]를 사용할 수 있습니다.

```{console, eval=FALSE}
$ mv hello.txt /data/ch02
```

`mv`를 사용하여 파일 이름을 바꿀 수도 있습니다.

```{console, eval=FALSE}
$ cd data
$ mv hello.txt bye.txt
```

전체 디렉터리의 이름을 바꾸거나 이동할 수도 있습니다.
파일이 더 이상 필요하지 않은 경우 `rm` [@rm]을 사용하여 삭제(또는 제거)합니다.

```{console, eval=FALSE}
$ rm bye.txt
```

모든 내용이 포함된 전체 디렉터리를 제거하려면 재귀를 의미하는 `-r` 옵션을 지정합니다.

```{console, eval=FALSE}
$ rm -r /data/ch02/old
```

파일을 복사하려면 `cp` [@cp]를 사용합니다.
이는 백업을 만드는 데 유용합니다.

```{console, eval=FALSE}
$ cp server.log server.log.bak
```

`mkdir` [@mkdir]를 사용하여 디렉터리를 만들 수 있습니다.

```{console}
cd /data
mkdir logs
l
```

```{block2, type="rmdtip"}
명령줄 도구를 사용하여 파일을 관리하는 것은 처음에는 무서울 수 있습니다. 왜냐하면 즉각적인 피드백을 제공하는 파일 시스템의 그래픽 개요가 없기 때문입니다.
GNU Midnight Commander, Ranger, Vifm과 같이 이를 도와줄 수 있는 몇 가지 시각적 파일 관리자가 있습니다.
이러한 도구는 Docker 이미지에 설치되어 있지 않지만 `sudo apt install` 다음에 `mc`, `ranger` 또는 `vifm`을 실행하여 직접 설치할 수 있습니다.
```

위의 모든 명령줄 도구는 자세한 정보를 의미하는 `-v` 옵션을 허용하므로 진행 상황을 출력합니다.
예를 들면 다음과 같습니다.

```{console}
mkdir -v backup
cp -v * backup
```

`mkdir`를 제외한 모든 도구는 대화형을 의미하는 `-i` 옵션도 허용하며 도구가 확인을 요청하도록 합니다.
예를 들면 다음과 같습니다.

```{console}
rm -i *#! expect_prompt=FALSE
n#! enter=FALSE, expect_prompt=TRUE
```


### 출력 관리

때로는 도구나 도구 시퀀스가 책에 포함하기에는 너무 많은 출력을 생성합니다.
이러한 출력을 수동으로 변경하는 대신 도우미 도구를 통해 파이프하여 투명하게 처리하는 것을 선호합니다.
특히 전체 출력에 관심이 있는 경우 반드시 이렇게 할 필요는 없습니다.

다음은 출력을 관리하는 데 사용하는 도구입니다.

출력을 지정된 높이와 너비로 제한하기 위해 종종 `trim`을 사용합니다.
기본적으로 출력은 10줄과 터미널 너비로 잘립니다.
높이 및/또는 너비 자르기를 비활성화하려면 음수를 전달합니다.
예를 들면 다음과 같습니다.

```{console}
cat /data/ch07/tips.csv | trim 5 25
```

출력을 마사지하는 데 사용하는 다른 도구로는 `head`, `tail`, `fold`, `paste`, `column`이 있습니다.
부록에는 각 도구에 대한 예제가 포함되어 있습니다.

출력이 쉼표로 구분된 값인 경우 종종 `csvlook`을 통해 파이프하여 보기 좋은 테이블로 만듭니다.
`csvlook`을 실행하면 전체 테이블이 표시됩니다.
테이블이 `trim`에 의해 단축되도록 `csvlook`을 재정의했습니다.

```{console}
which csvlook
csvlook /data/ch07/tips.csv
```

줄 번호와 구문 강조 표시가 중요한 파일 내용을 표시하기 위해 `bat`을 사용합니다.
예를 들어 소스 코드:

```{console}
bat /data/ch04/stream.py
```

때로는 파일의 공백, 탭 및 줄 바꿈을 명시적으로 지적하고 싶을 때 `-A` 옵션을 추가합니다.

때로는 중간 출력을 파일에 쓰는 것이 유용합니다.
이렇게 하면 파이프라인의 모든 단계가 완료되면 검사할 수 있습니다.
파이프라인에 원하는 만큼 `tee` 도구를 삽입할 수 있습니다.
최종 출력의 일부를 검사하면서 전체 출력을 파일에 쓰는 데 종종 사용합니다(\@ref(fig:diagram-essential-tee) 참조).
여기서 전체 출력은 *even.txt*에 기록되고 처음 5줄은 `trim`을 사용하여 인쇄됩니다.

```{console}
seq 0 2 100 | tee even.txt | trim 5
```

```{r diagram-essential-tee, echo=FALSE, fig.cap="`tee`를 사용하면 중간 출력을 파일에 쓸 수 있습니다.", fig.align="center"}
knitr::include_graphics("images/dscl_0208.png")
```

마지막으로 명령줄 도구에서 생성된 이미지(스크린샷 및 다이어그램을 제외한 모든 이미지)를 삽입하기 위해 `display`를 사용합니다.
`display`를 실행하면 작동하지 않는 것을 볼 수 있습니다.
[7장](#chapter-7-exploring-data)에서는 명령줄에서 생성된 이미지를 표시하기 위한 네 가지 옵션을 설명합니다.


### 도움말!

명령줄을 사용하는 방법을 익히는 동안 도움이 필요할 수 있습니다.
가장 노련한 사용자도 어느 시점에는 도움이 필요합니다.
모든 다른 명령줄 도구와 가능한 인수를 모두 기억하는 것은 불가능합니다.
다행히 명령줄은 도움을 받을 수 있는 여러 가지 방법을 제공합니다.

도움을 받는 가장 중요한 명령은 아마도 *manual*의 약자인 `man` [@man]일 것입니다.
대부분의 명령줄 도구에 대한 정보가 포함되어 있습니다.
항상 발생하는 `tar` 도구의 옵션을 잊어버린 경우 다음을 사용하여 해당 매뉴얼 페이지에 액세스하기만 하면 됩니다.

```{console man_cat}
man tar | trim 20
```


모든 명령줄 도구에 매뉴얼 페이지가 있는 것은 아닙니다.
예를 들어 `cd`를 살펴보십시오.

```{console}
man cd
```

`cd`와 같은 셸 내장 명령의 경우 *zshbuiltins* 매뉴얼 페이지를 참조할 수 있습니다.

```{console}
man zshbuiltins | trim
```

**`/`**를 눌러 검색하고 **`q`**를 눌러 종료할 수 있습니다.
`cd`에 대한 적절한 섹션을 찾아보십시오.

최신 명령줄 도구에도 매뉴얼 페이지가 없는 경우가 많습니다.
이 경우 가장 좋은 방법은 `--help`(또는 `-h`) 옵션으로 도구를 호출하는 것입니다.
예를 들면 다음과 같습니다.

```{console}
jq --help | trim
```

`--help` 옵션을 지정하는 것은 `cat`과 같은 명령줄 도구에서도 작동합니다.
그러나 해당 매뉴얼 페이지는 종종 더 많은 정보를 제공합니다.
이 세 가지 방법을 시도한 후에도 여전히 막히면 인터넷을 참조하는 것이 완벽하게 허용됩니다.
부록에는 이 책에서 사용된 모든 명령줄 도구 목록이 있습니다.
각 명령줄 도구를 설치하는 방법 외에도 도움을 받는 방법도 보여줍니다.

매뉴얼 페이지는 매우 장황하고 읽기 어려울 수 있습니다.
도구 `tldr` [@tldr]은 명령줄 도구에 대한 커뮤니티 유지 관리 도움말 페이지 모음으로, 기존 매뉴얼 페이지보다 간단하고 접근하기 쉬운 보완 자료가 되는 것을 목표로 합니다.
다음은 `tar`에 대한 tldr 페이지를 보여주는 예입니다.

```{console, include=FALSE}
tldr --update
```

```{console}
tldr tar | trim 20
```

보시다시피 `man`이 종종 그렇듯이 많은 옵션을 알파벳순으로 나열하는 대신 `tldr`은 실용적인 예제 목록을 제공하여 요점을 바로 설명합니다.


## 요약

이 장에서는 Docker 이미지를 설치하여 필요한 모든 명령줄 도구를 얻는 방법을 배웠습니다.
또한 몇 가지 필수적인 명령줄 개념과 도움을 받는 방법을 살펴보았습니다.
이제 필요한 모든 재료가 준비되었으므로 데이터 과학을 위한 OSEMN 모델의 첫 번째 단계인 데이터 획득을 시작할 준비가 되었습니다.


## 추가 탐색을 위해

- 이 책의 부제는 Jerry Peek, Shelley Powers, Tim O'Reilly, Mike Loukides의 대작 *Unix Power Tools*에 경의를 표합니다. 그리고 당연합니다. 51개 장과 1000페이지가 넘는 분량으로 Unix에 대해 알아야 할 거의 모든 것을 다룹니다. 무게가 4파운드가 넘으므로 전자책을 고려해 볼 수 있습니다.
- 웹사이트 [explainshell](https://explainshell.com/)은 명령 또는 명령 시퀀스를 구문 분석하고 각 부분에 대한 간략한 설명을 제공합니다. 관련 매뉴얼 페이지를 훑어보지 않고도 새 명령이나 옵션을 빠르게 이해하는 데 유용합니다.
- Docker는 정말 훌륭한 소프트웨어입니다. 이 장에서는 Docker 이미지를 다운로드하고 Docker 컨테이너를 실행하는 방법을 간략하게 설명했지만 [자신만의 Docker 이미지를 만드는 방법](https://www.docker.com/101-tutorial)을 배우는 것이 좋습니다. Sean Kane과 Karl Matthias의 책 *Docker: Up & Running*도 좋은 자료입니다.


[^cat]: [일부](http://porkmail.org/era/unix/award.html)는 이것을 `cat`의 쓸모없는 사용으로 간주하며, `cat`의 목적은 파일을 연결하는 것이고 이 목적을 위해 사용하지 않으면 시간 낭비이며 프로세스 비용이 든다고 주장합니다. 저는 이것이 어리석다고 생각합니다. 우리는 더 중요한 할 일이 있습니다!
