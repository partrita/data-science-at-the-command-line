---
suppress-bibliography: true
---






# Make으로 프로젝트 관리하기 {#chapter-6-project-management-with-make}

이제 여러분도 커맨드 라인이 데이터를 다루기에 매우 편리한 환경이라는 것을 체감하셨으리라 생각합니다.
커맨드 라인에서 작업하면서 우리는 다음과 같은 상황을 겪게 된다는 것을 눈치채셨을 것입니다.

- 수많은 서로 다른 명령어를 호출합니다.
- 다양한 디렉터리에서 작업합니다.
- 우리만의 커맨드 라인 도구를 개발합니다.
- 많은 (중간) 파일들을 획득하고 생성합니다.

이 과정은 탐색적인 성격이 강하기 때문에, 우리의 워크플로우는 다소 혼란스러워지는 경향이 있으며, 그로 인해 우리가 무엇을 했는지 추적하기가 어려워집니다.
우리가 거쳐온 단계들은 본인이나 타인에 의해 재현될 수 있어야 합니다.
얼마간의 시간이 흐른 뒤 프로젝트를 다시 시작할 때, 어떤 명령어를 어떤 디렉터리에서, 어떤 파일을 대상으로, 어떤 매개변수와 함께, 그리고 어떤 순서로 실행했는지 잊어버릴 가능성이 큽니다.
이런 상황에서 협업자와 프로젝트를 공유하는 것은 얼마나 힘들지 상상해 보십시오.

`history` 명령어의 출력을 뒤져서 일부 명령어를 복구할 수도 있겠지만, 이는 당연히 신뢰할 수 있는 방법이 아닙니다.
그보다 나은 방법은 명령어를 쉘 스크립트에 저장하는 것입니다.
최소한 이 방법을 통해 여러분과 협업자들은 프로젝트를 재현할 수 있습니다.
하지만 쉘 스크립트 역시 다음과 같은 이유로 최선의 방법은 아닙니다.

- 읽고 유지보수하기가 어렵습니다.
- 단계들 사이의 의존성이 불분명합니다.
- 매번 모든 단계가 실행되는데, 이는 비효율적이며 때로는 바람직하지 않습니다.

이것이 바로 `make`가 정말 빛을 발하는 지점입니다 [@make]. `make`는 다음과 같은 작업을 가능하게 해주는 커맨드 라인 도구입니다.

- 입력과 출력의 의존성 관점에서 데이터 워크플로우 단계를 공식화합니다.
- 워크플로우의 특정 단계만 실행합니다.
- 인라인 코드를 사용합니다.
- 외부 소스로부터 데이터를 저장하고 가져옵니다.

\BeginKnitrBlock{rmdnote}<div class="rmdnote">초판에서 이 장은 `make` 대신 `drake` [@drake]를 사용했습니다.
드레이크(Drake)는 데이터를 다루기 위한 추가 기능을 갖춘 `make`의 후계자가 될 예정이었습니다.
안타깝게도 드레이크는 2016년에 해결되지 않은 많은 버그를 남긴 채 개발진에 의해 중단되었습니다.
그래서 저는 대신 `make`를 사용하기로 결정했습니다.</div>\EndKnitrBlock{rmdnote}

중요한 관련 주제로 *버전 관리(version control)*가 있습니다. 이는 프로젝트의 변경 사항을 추적하고, 프로젝트를 서버에 백업하며, 다른 사람들과 협업하고, 문제가 생겼을 때 이전 버전으로 되돌릴 수 있게 해줍니다.
버전 관리를 위한 대중적인 커맨드 라인 도구는 `git` [@git]입니다.
Git은 흔히 분산 버전 관리를 위한 온라인 서비스인 GitHub와 함께 사용됩니다.
[이 책](https://github.com/jeroenjanssens/data-science-at-the-command-line)을 포함한 많은 오픈 소스 프로젝트가 GitHub에서 호스팅되고 있습니다.
버전 관리라는 주제는 이 책의 범위를 벗어나지만, 특히 다른 사람들과 협업을 시작하게 된다면 이를 꼭 살펴보시길 강력히 추천합니다.
이 장의 끝부분에서 더 배울 수 있는 몇 가지 자료를 추천해 드리겠습니다.


## 개요

`make`로 데이터 워크플로우를 관리하는 것이 이 장의 주요 주제입니다.
이에 대해 다음 내용을 배우게 됩니다.

- *Makefile*을 사용하여 워크플로우를 정의하기.
- 입력 및 출력 의존성의 관점에서 워크플로우 생각하기.
- 작업(task)을 실행하고 타겟(target)을 빌드하기.


``` console
cd /data/ch06
l
```

이 파일들을 가져오는 방법은 [2장](#chapter-2-getting-started)에 설명되어 있습니다.
그 외의 파일들은 커맨드 라인 도구를 사용하여 다운로드하거나 생성한 것들입니다.


## Make 소개

`make`는 데이터와 그 의존성을 중심으로 명령어 실행을 조직화합니다.
데이터 처리 단계는 별도의 텍스트 파일(워크플로우)에 공식화됩니다.
각 단계는 입력과 출력을 가질 수 있습니다.
`make`는 그들의 의존성을 자동으로 해결하고 어떤 명령어를 어떤 순서로 실행해야 하는지 결정합니다.

예를 들어, 10분 정도 걸리는 SQL 쿼리가 있다고 할 때, 이는 결과 파일이 없거나 쿼리가 나중에 변경되었을 때만 실행됩니다.
또한 특정 단계를 (재)실행하고 싶을 때, `make`는 해당 단계가 의존하는 단계들만 재실행합니다.
이는 시간을 대폭 절약해 줍니다.

공식화된 워크플로우를 갖추면 몇 주 후에 프로젝트를 다시 시작하거나 다른 사람들과 협업하기가 훨씬 수월해집니다.
일회성 프로젝트라고 생각하더라도 이를 수행하시기를 강력히 권장합니다.
언제 특정 단계를 다시 실행해야 하거나 다른 프로젝트에서 재사용하게 될지 누구도 모르기 때문입니다.


## 작업(Task) 실행하기

기본적으로 `make`는 현재 디렉터리에서 *Makefile*이라는 설정 파일을 찾습니다.
파일 이름을 *makefile*(소문자)로 할 수도 있지만, 더 일반적이고 디렉터리 목록의 상단에 나타나도록 *Makefile*로 지정하는 것을 추천합니다.
보통 프로젝트당 하나의 설정 파일만 가집니다.
이 장에서는 여러 장을 논의하기 때문에 각각 *.make* 확장자를 가진 다른 파일 이름을 부여했습니다.
다음 *Makefile*부터 시작해 보겠습니다.


``` console
bat -A numbers.make
```

이 *Makefile*은 *`numbers`*라는 하나의 *타겟(target)*을 포함하고 있습니다.
*타겟*은 하나의 작업과 같습니다.
보통 생성하고자 하는 파일의 이름이지만, 그보다 더 일반적인 것일 수도 있습니다.
그 아래 줄인 *`seq 7`*은 *규칙(rule)*으로 알려져 있습니다.
규칙은 요리 레시피(recipe)라고 생각하면 됩니다. 타겟을 어떻게 빌드할지 명시하는 하나 이상의 명령어입니다.

규칙 앞의 공백은 하나의 탭(tab) 문자입니다.
`make`는 공백에 매우 민감합니다.
일부 에디터는 **`TAB`** 키를 눌렀을 때 소프트 탭(soft tab)이라고 불리는 공백들을 삽입하는데, 이는 `make` 에러를 유발할 수 있으니 주의하십시오.
다음 코드는 탭을 8개의 공백으로 확장하여 이를 보여줍니다.


``` console
< numbers.make expand > spaces.make
bat -A spaces.make
make -f spaces.make
rm spaces.make
```
<1> 설정 파일의 이름이 기본값인 *Makefile*이 아니기 때문에 `--makefile` 옵션의 약어인 `-f` 옵션을 추가해야 합니다.
<2> 커맨드 라인에서 볼 수 있는 매우 친절한 에러 메시지 중 하나입니다!

이제부터는 실제 사용 사례와 더 비슷하도록 해당 파일의 이름을 *Makefile*로 바꿀 것입니다.
그냥 `make`를 실행해 보겠습니다.


``` console
cp numbers.make Makefile
make
```

그러면 `make`가 먼저 규칙 자체(*`seq 7`*)를 출력한 다음, 규칙에 의해 생성된 출력을 인쇄하는 것을 볼 수 있습니다.
이 과정을 타겟을 *빌드(building)*한다고 합니다.
타겟의 이름을 지정하지 않으면 `make`는 *Makefile*에 정의된 첫 번째 타겟을 빌드합니다.
실제로는 빌드하고 싶은 타겟을 직접 지정하는 경우가 더 많습니다.


``` console
make numbers
```

\BeginKnitrBlock{rmdnote}<div class="rmdnote">`make`는 원래 소스 코드의 컴파일을 쉽게 하기 위해 만들어졌기 때문에 *타겟*, *규칙*, *빌드*와 같은 용어가 사용됩니다.</div>\EndKnitrBlock{rmdnote}

이 경우 실제로는 아무것도 빌드하지 않았습니다. 즉, 새로운 파일을 생성하지 않았습니다.
`make`는 *numbers*라는 파일을 찾지 못하므로 기꺼이 `numbers` 타겟을 다시 *빌드*할 것입니다.
다음 섹션에서 이에 대해 자세히 다루겠습니다.

가끔은 동일한 이름의 파일 존재 여부와 상관없이 무조건 빌드되는 타겟이 필요할 때가 있습니다.
프로젝트의 일부로 수행해야 하는 작업들을 생각해 보십시오.
그러한 타겟들은 *Makefile*의 최상단에 `.PHONY`라는 특수 타겟을 사용하고 그 뒤에 가짜(phony) 타겟들의 이름을 나열하여 가짜 타겟으로 선언하는 것이 좋은 관례입니다.
다음은 가짜 타겟의 사용법을 보여주는 예시 *Makefile*입니다.


``` console
bat tasks.make
```
<1> *`$(pwd)`* 앞의 달러 기호가 하나 더 있다는 점에 주목하십시오. 이는 `make`가 단일 달러 기호를 나중에 설명할 다양한 특수 변수를 참조하는 데 사용하기 때문에 필요합니다.

위 내용은 제가 이 책을 작업하면서 사용하는 *Makefile*에서 가져온 것입니다.
제가 `make`를 고성능 작업 실행기(task runner)로 사용하고 있다고 말할 수도 있습니다.
이것이 `make`의 주된 목적은 아니었지만, 제가 어떤 명령어를 사용했는지 기억하거나 찾아볼 필요가 없기 때문에 여전히 큰 가치가 있습니다.
대신 `make publish`를 입력하면 책의 최신 버전이 발행됩니다.
*Makefile*에 시간이 오래 걸리는 명령어를 넣는 것도 전혀 문제가 되지 않습니다.

그리고 `make`는 우리를 위해 훨씬 더 많은 일을 할 수 있습니다!


## 본격적으로 빌드하기

규칙의 출력이 파일 *numbers*에 기록되도록 *Makefile*을 수정해 보겠습니다.


``` console
cp numbers-write.make Makefile
bat Makefile
make numbers
bat numbers
```

이제 `make`가 실제로 무언가를 빌드하고 있다고 말할 수 있습니다.
또한, 이를 다시 실행하면 `make`는 `numbers` 타겟이 이미 최신 상태(up-to-date)라고 보고합니다.


``` console
make numbers
```

파일 *numbers*가 이미 존재하기 때문에 `numbers` 타겟을 다시 빌드할 필요가 없습니다.
`make`가 불필요한 작업을 반복하지 않음으로써 우리의 시간을 절약해 주는 것입니다.

`make`에서는 모든 것이 파일에 관한 것입니다.
하지만 `make`는 타겟의 *이름*에만 신경 쓴다는 점을 명심하십시오.
해당 이름의 파일이 실제로 규칙에 의해 생성되었는지 여부는 확인하지 않습니다.
만약 우리가 "문자"라는 뜻의 네덜란드어인 *nummers* 파일에 쓰고 타겟 이름이 여전히 `numbers`라면, `make`는 항상 이 타겟을 빌드할 것입니다. 반대로, 자동이든 수동이든 다른 프로세스에 의해 *numbers* 파일이 생성되었다면, `make`는 여전히 해당 타겟이 최신 상태라고 간주할 것입니다.

타겟의 이름으로 확장되는 자동 변수 `$@`를 사용하여 중복을 피할 수 있습니다.


```` console
cp numbers-write-var.make Makefile
200: bat Makefile
201: ```

*numbers* 파일을 삭제하고 `make`를 다시 호출하여 제대로 작동하는지 확인해 보겠습니다.

````

``` console
rm numbers
make numbers
bat numbers
```

`make`가 타겟을 다시 빌드하는 또 다른 이유는 의존성(dependencies) 때문입니다. 이에 대해 다음에서 논의해 보겠습니다.


## 의존성 추가하기

지금까지는 개별적으로 존재하는 타겟들을 살펴보았습니다.
전형적인 데이터 과학 워크플로우에서 많은 단계는 다른 단계들에 의존합니다.
*Makefile*에서 의존성에 대해 제대로 이야기하기 위해, 스타워즈 캐릭터에 대한 데이터셋을 다루는 두 가지 작업을 예로 들어보겠습니다.

데이터셋의 일부 내용을 살펴보겠습니다.


``` console
curl -sL 'https://raw.githubusercontent.com/tidyverse/dplyr/master/data-raw/starwars.csv' |
xsv select name,height,mass,homeworld,species |
csvlook
```

첫 번째 작업은 키가 가장 큰 인간 10명을 계산하는 것입니다.


``` console
curl -sL 'https://raw.githubusercontent.com/tidyverse/dplyr/master/data-raw/starwars.csv' |
grep Human |
cut -d, -f 1,2 |
sort -t, -k2 -nr |
head
```
<1> 패턴 *`Human`*을 포함하는 행만 유지합니다.
<2> 처음 두 열을 추출합니다.
<3> 두 번째 열을 기준으로 숫자 역순으로 행을 정렬합니다.
<4> 기본적으로 `head`는 처음 10개 행을 출력합니다. `-n` 옵션으로 이를 변경할 수 있습니다.

두 번째 작업은 종(species)별 키 분포를 보여주는 박스 플롯을 생성하는 것입니다(\@ref(fig:starwars-image) 참조).


``` console
curl -sL 'https://raw.githubusercontent.com/tidyverse/dplyr/master/data-raw/starwars.csv' |
rush plot --x height --y species --geom boxplot > heights.png
display heights.png
```


이 두 작업을 *Makefile*에 넣어보겠습니다.
이를 하나씩 점진적으로 하는 대신, 완성된 *Makefile*이 어떤 모습인지 먼저 보여준 다음 모든 구문을 단계별로 설명하겠습니다.


``` console
cp starwars.make Makefile
bat Makefile
```

이 *Makefile*을 단계별로 살펴보겠습니다.
처음 세 줄은 `make` 자체와 관련된 몇 가지 기본 설정을 변경하기 위한 것입니다.

1. 모든 규칙은 쉘에서 실행되며, 기본값은 `sh`입니다. *`SHELL`* 변수를 사용하여 이를 `bash`와 같은 다른 쉘로 변경할 수 있습니다. 이렇게 하면 Bash가 제공하는 for 루프와 같은 모든 기능을 사용할 수 있습니다.
2. 기본적으로 규칙의 각 줄은 쉘로 별도로 전송됩니다. *`.ONESHELL`*이라는 특수 타겟을 사용하면 이를 무시할 수 있으며, 이 덕분에 *`top10`* 타겟의 규칙이 제대로 작동합니다.
3. *`.SHELLFLAGS`* 줄은 Bash를 더 엄격하게 만드는데, 이는 [모범 사례(best practice)](http://redsymbol.net/articles/unofficial-bash-strict-mode/)로 간주됩니다. 예를 들어, 이 설정 덕분에 *`top10`* 타겟 규칙의 파이프라인은 오류가 발생하는 즉시 중단됩니다.

우리는 *`URL`*이라는 사용자 정의 변수를 정의합니다.
이 변수가 한 번만 사용되기는 하지만, 파일의 시작 부분 부분에 이러한 정보를 배치하면 나중에 설정을 쉽게 변경할 수 있어 도움이 됩니다.

특수 타겟 *`.PHONY`*를 사용하면 어떤 타겟이 파일로 나타나지 않는지 나타낼 수 있습니다. 이 예제에서는 *`all`*과 *`top10`* 타겟이 이에 해당합니다. 이제 이 타겟들은 디렉터리에 동일한 이름의 파일이 있는지 여부와 상관없이 항상 실행됩니다.

타겟은 *`all`*, *`data`*, *`data/starwars.csv`*, *`top10`*, *`heights.png`*의 다섯 가지가 있습니다.
\@ref(fig:dependencies)에서는 이러한 타겟들과 그들 사이의 의존성을 개괄적으로 보여줍니다.



각 타겟을 차례대로 살펴보겠습니다.

1. 타겟 *`all`*은 두 개의 의존성을 갖지만 규칙은 없습니다. 이는 지정된 순서대로 하나 이상의 타겟을 실행하기 위한 지름길과 같습니다. 이 경우 *`top10`*과 *`heights.png`*입니다. 타겟 *`all`*은 *Makefile*에서 첫 번째 타겟으로 나타나므로, 우리가 `make`를 실행하면 이 타겟이 빌드됩니다.
2. 타겟 *`data`*는 *data* 디렉터리를 생성합니다. 앞에서 `make`는 파일에 관한 것이라고 말씀드렸지만, 디렉터리에 관한 것이기도 합니다. 이 타겟은 *data* 디렉터리가 아직 존재하지 않을 때만 실행됩니다.
3. 타겟 *`data/starwars.csv`*는 타겟 *`data`*에 의존합니다. 만약 *`data`* 디렉터리가 없다면 먼저 생성될 것입니다. 모든 의존성이 충족되면 규칙이 실행되며, 여기에는 파일을 다운로드하여 타겟과 동일한 이름의 파일로 저장하는 과정이 포함됩니다.
4. 타겟 *`top10`*은 가짜 타겟으로 표시되어 있으므로 지정되면 항상 빌드됩니다. 이 타겟은 *`data/starwars.csv`* 타겟에 의존합니다. 첫 번째 전제 조건인 *data/starwars.csv*로 확장되는 특수 변수 *`$<`*를 사용합니다.
5. 타겟 *`heights.png`*는 *`top10`* 타겟과 마찬가지로 *`data/starwars.csv`*에 의존하며, 이 장에서 살펴본 두 가지 자동 변수를 모두 사용합니다. 다른 자동 변수에 대해 더 알고 싶다면 [온라인 문서](https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html)를 참조하십시오.

마지막으로 이 *Makefile*이 제대로 작동하는지 확인해 보겠습니다.


``` console
make
```

놀라운 일은 없군요. 타겟을 지정하지 않았으므로 *`all`* 타겟이 빌드되고, 결과적으로 *`top10`*과 *`heights.png`* 타겟이 모두 빌드됩니다. 전자의 출력은 표준 출력으로 인쇄되고 후자는 *heights.png* 파일을 생성합니다. *data* 디렉터리는 한 번만 생성되며, CSV 파일 역시 한 번만 다운로드됩니다.

데이터를 가지고 놀다 보면 다른 모든 것을 잊어버리는 것보다 더 즐거운 일은 없습니다.
하지만 *Makefile*을 사용하여 작업 내용을 기록해 두는 것이 가치 있다는 제 말을 믿으셔야 합니다.
그것이 여러분의 삶을 더 편하게 만들어줄 뿐만 아니라(말장난입니다), 여러분이 데이터 워크플로우를 단계별로 생각하기 시작하는 데 도움을 줄 것입니다.
시간이 지나면서 여러분만의 커맨드 라인 도구 상자가 확장되는 것처럼, `make` 워크플로우도 마찬가지입니다.
정의된 단계가 많을수록 특정 단계들을 재사용할 수 있는 경우가 매우 많기 때문에 작업을 꾸준히 해나가기가 더 쉬워집니다.
여러분이 `make`에 익숙해지고, 그것이 여러분의 삶을 더 풍요롭게(make your life easier) 만들기를 바랍니다.


## 요약

커맨드 라인의 묘미 중 하나는 데이터를 마음껏 가지고 놀 수 있다는 점입니다.
다양한 명령어를 쉽게 실행하고 여러 데이터 파일을 처리할 수 있습니다.
이는 매우 상호작용적이고 반복적인 과정입니다.
시간이 지나면 원하는 결과를 얻기 위해 어떤 단계를 거쳤는지 잊어버리기 쉽습니다.
따라서 이따금 여러분이 수행한 단계들을 기록해 두는 것이 매우 중요합니다.
그래야 나중에 여러분이나 동료가 다시 프로젝트를 시작했을 때, 동일한 단계를 실행하여 같은 결과를 만들어낼 수 있습니다.

이 장에서는 모든 명령어를 하나의 Bash 스크립트에 몰아넣는 것이 최선이 아님을 보여드렸습니다.
대신 데이터 워크플로우를 관리하기 위한 커맨드 라인 도구로 `make`를 사용할 것을 제안했습니다.
다음 장은 데이터 과학을 위한 OSEMN 모델의 세 번째 단계인 데이터 탐색(Exploring data)을 다룹니다.


## 더 읽어보기

- Robert Mecklenburg의 저서 *Managing Projects with GNU Make*와 온라인 *GNU Make Manual*은 `make`에 대한 포괄적이고 고급스러운 내용을 제공합니다.
- `make` 외에도 수많은 워크플로우 관리자가 존재합니다. 구문과 기능은 다르지만 타겟, 규칙, 의존성과 같은 개념을 공통적으로 사용합니다. 대표적인 예로 [Luigi](https://luigi.readthedocs.io), [Apache Airflow](https://airflow.apache.org), [Nextflow](https://www.nextflow.io) 등이 있습니다.
- 버전 관리, 특히 `git`과 GitHub에 대해 더 자세히 알고 싶다면 Scott Chacon과 Ben Straub이 쓴 *Pro Git*을 추천합니다. [무료로 제공](https://git-scm.com/book/en/v2)됩니다. [온라인 GitHub 문서](https://docs.github.com/en/get-started) 또한 좋은 시작점입니다.
