---
suppress-bibliography: true
---






# 데이터 모델링 {#chapter-9-modeling-data}

이 장에서는 OSEMN 모델의 네 번째 단계인 데이터 모델링을 수행할 것입니다.
일반적으로 모델은 여러분이 가진 데이터에 대한 추상적이거나 상위 수준의 설명(description)입니다.
모델링은 개별 데이터 포인트에서 한 걸음 물러나 큰 그림을 본다는 점에서 시각화를 만드는 것과 약간 비슷합니다.

시각화는 모양, 위치, 색상으로 특징지어집니다. 우리는 그것들을 직접 눈으로 보고 해석할 수 있습니다.
반면 모델은 내부적으로 숫자로 특징지어지며, 이는 컴퓨터가 새로운 데이터 포인트에 대한 예측을 수행하는 등의 작업에 모델을 사용할 수 있음을 의미합니다.
(모델이 어떻게 작동하고 성능이 어떠한지 이해하기 위해 여전히 모델을 시각화할 수 있습니다.)

이 장에서 저는 데이터를 모델링하는 데 흔히 사용되는 세 가지 유형의 알고리즘을 살펴볼 것입니다.

- 차원 축소(Dimensionality reduction)
- 회귀(Regression)
- 분류(Classification)

이 알고리즘들은 통계학과 머신러닝 분야에서 온 것이므로, 용어를 조금 바꾸어 사용하겠습니다.
우리가 *데이터셋*이라고도 불리는 CSV 파일을 가지고 있다고 가정해 봅시다.
헤더를 제외한 각 행은 하나의 *데이터 포인트*로 간주됩니다.
각 데이터 포인트는 하나 이상의 *특성(features)* 또는 측정된 속성들을 가집니다.
때로는 데이터 포인트가 *레이블(label)*을 가지기도 하는데, 이는 일반적으로 판단 결과나 성과를 의미합니다.
아래에서 와인 데이터셋을 소개할 때 이 개념이 더 구체화될 것입니다.

첫 번째 유형의 알고리즘(차원 축소)은 대부분 비지도 학습(unsupervised)입니다. 즉, 데이터셋의 특성만을 기반으로 모델을 생성합니다.
마지막 두 유형의 알고리즘(회귀 및 분류)은 정의상 지도 학습(supervised) 알고리즘이며, 이는 모델에 레이블 정보도 포함시킨다는 의미입니다.

\BeginKnitrBlock{rmdcaution}<div class="rmdcaution">이 장은 결코 머신러닝 입문서가 아닙니다.
따라서 많은 세부 사항을 생략하고 넘어갈 수밖에 없습니다.
일반적인 권고 사항은, 여러분의 데이터에 알고리즘을 적용하기 전에 해당 알고리즘에 익숙해지는 시간을 갖는 것입니다.
이 장의 끝에서 머신러닝에 관한 몇 권의 책을 추천해 드립니다.</div>\EndKnitrBlock{rmdcaution}

## 개요

이 장에서 여러분은 다음 방법을 배우게 됩니다.

- `tapkee` [@tapkee]를 사용하여 데이터셋의 차원 축소하기
- `vw` [@vw]를 사용하여 화이트 와인의 품질 예측하기
- `skll` [@skll]을 사용하여 와인을 레드 또는 화이트로 분류하기

이 장은 다음 파일로 시작합니다.


``` console
cd /data/ch09
l
```

이 파일들을 가져오는 방법은 [2장](#chapter-2-getting-started)에 설명되어 있습니다.
그 외의 파일들은 커맨드 라인 도구를 사용하여 다운로드하거나 생성한 것들입니다.


## 와인 좀 더 주세요!

이 장 전반에 걸쳐 '비뉴 베르드(vinho verde)'라고 불리는 포르투갈 와인의 레드 및 화이트 품종에 대한 와인 감별사들의 기록 데이터셋을 사용할 것입니다.
각 데이터 포인트는 하나의 와인을 나타냅니다. 각 와인은 11가지 물리화학적 특성에 대해 등급이 매겨져 있습니다: (1) 고정 산도(fixed acidity), (2) 휘발성 산도(volatile acidity), (3) 구연산(citric acid), (4) 잔류 당분(residual sugar), (5) 염화물(chlorides), (6) 유리 이산화황(free sulfur dioxide), (7) 총 이산화황(total sulfur dioxide), (8) 밀도(density), (9) pH, (10) 황산염(sulphates), (11) 알코올(alcohol).
또한 0(매우 나쁨)에서 10(매우 우수) 사이의 종합 품질 점수가 있는데, 이는 와인 전문가들에 의한 최소 세 번의 평가 결과에 대한 중앙값입니다. 이 데이터셋에 대한 더 자세한 정보는 [UCI 머신러닝 저장소](http://archive.ics.uci.edu/ml/datasets/Wine+Quality)에서 확인할 수 있습니다.

데이터셋은 화이트 와인용과 레드 와인용 두 개의 파일로 나뉘어 있습니다.
가장 먼저 할 일은 `curl`을 사용하여 두 파일을 가져오는 것입니다 (물론 시간이 아까우니 `parallel`을 사용합니다).


``` console
parallel "curl -sL http://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-{}.csv > wine-{}.csv" ::: red white#!enter=FALSE
C-C#!literal=FALSE
```

세 개의 콜론(`:::`)은 `parallel`에 데이터를 전달하는 또 다른 방법입니다.


``` console
cp /data/.cache/wine-*.csv .
```

두 파일을 검사하고 줄 수를 세어봅시다.


``` console
< wine-red.csv nl |
fold |
trim
< wine-white.csv nl | fold | trim
wc -l wine-{red,white}.csv
```
<1> 명확성을 위해 `nl`을 사용하여 줄 번호를 추가했습니다.
<2> 헤더 전체를 보기 위해 `fold`를 사용했습니다.

언뜻 보기에 이 데이터는 꽤 깨끗해 보입니다.
그래도 대부분의 커맨드 라인 도구가 기대하는 형식에 더 잘 부합하도록 정제(scrub)해 보겠습니다.
구체적으로 다음 작업을 할 것입니다.

- 헤더를 소문자로 변환합니다.
- 세미콜론(`;`)을 쉼표(`,`)로 바꿉니다.
- 공백을 언더스코어(`_`)로 바꿉니다.
- 불필요한 따옴표를 제거합니다.

`tr` 도구를 사용하면 이 모든 작업을 처리할 수 있습니다.
이번에는 옛 추억을 되살려 `for` 루프를 사용하여 두 파일을 처리해 보겠습니다.


``` console
for COLOR in red white; do
< wine-$COLOR.csv tr '[A-Z]; ' '[a-z],_' | tr -d \" > wine-${COLOR}-clean.csv
done
```

또한 두 파일을 결합하여 단일 데이터셋을 만들어 봅시다.
`csvstack` [@csvstack]을 사용하여 *type*이라는 열을 추가할 것입니다. 이 열은 첫 번째 파일의 행에는 "red", 두 번째 파일의 행에는 "white"라는 값을 갖게 됩니다.


``` console
csvstack -g red,white -n type wine-{red,white}-clean.csv |
xsv select 2-,1 > wine.csv
```
<1> 새 열 *type*은 `csvstack`에 의해 맨 앞에 배치됩니다.
<2> 일부 알고리즘은 레이블이 마지막 열에 있다고 가정하므로, `xsv`를 사용하여 *type* 열을 맨 뒤로 옮깁니다.

대부분의 머신러닝 알고리즘은 결측값(missing values)을 처리하지 못하므로, 이 데이터셋에 결측값이 있는지 확인하는 것이 좋습니다.


``` console
csvstat wine.csv --nulls
```

훌륭합니다!
만약 결측값이 있었다면 해당 특성의 평균값이나 가장 빈번한 값 등으로 채워 넣을 수 있었을 것입니다.
대안적으로, 결측값이 하나라도 있는 데이터 포인트를 아예 제거하는 덜 정교한 접근 방식도 있습니다.
그냥 호기심에, 레드 와인과 화이트 와인의 품질 분포가 어떻게 다른지 살펴봅시다.


``` console
rush run -t 'ggplot(df, aes(x = quality, fill = type)) + geom_density(adjust = 3, alpha = 0.5)' wine.csv > wine-quality.png
display wine-quality.png
```


밀도 그래프를 통해 화이트 와인의 품질이 더 높은 값 쪽으로 분포되어 있음을 알 수 있습니다.
이것이 화이트 와인이 전반적으로 레드 와인보다 더 좋다는 뜻일까요, 아니면 화이트 와인 전문가들이 레드 와인 전문가들보다 더 쉽게 높은 점수를 준다는 뜻일까요?
그것은 데이터가 우리에게 말해주지 않는 부분입니다.
혹시 알코올 농도와 품질 사이에 관계가 있을까요?
`rush`를 사용하여 알아봅시다.


``` console
rush plot --x alcohol --y quality --color type --geom smooth wine.csv > wine-alcohol-vs-quality.png
display wine-alcohol-vs-quality.png
```


유레카! 흠흠, 이제 모델링을 계속해 볼까요?


## Tapkee를 사용한 차원 축소

차원 축소의 목표는 고차원의 데이터 포인트를 저차원의 매핑으로 옮기는 것입니다.
핵심 과제는 유사한 데이터 포인트들이 저차원 매핑에서도 서로 가깝게 유지되도록 하는 것입니다.
이전 섹션에서 보았듯이, 우리의 와인 데이터셋은 13개의 특성을 포함하고 있습니다.
시각화하기에 가장 직관적인 두 개의 차원으로 축소를 진행해 보겠습니다.

차원 축소는 종종 탐색적 데이터 분석(EDA)의 일부로 간주됩니다.
플로팅하기에 특성이 너무 많을 때 유용합니다.
산점도 행렬(scatter-plot matrix)을 만들 수도 있지만, 이는 한 번에 두 개의 특성만 보여줄 수 있습니다.
또한 다른 머신러닝 알고리즘을 위한 전처리 단계로도 유용합니다.

대부분의 차원 축소 알고리즘은 비지도 학습입니다.
이는 데이터 포인트의 레이블을 사용하지 않고 저차원 매핑을 구축한다는 의미입니다.

이 섹션에서는 PCA(주성분 분석, Principal Components Analysis [@Pearson1901])와 t-SNE(t-분포 확률적 임베딩, t-distributed Stochastic Neighbor Embedding [@van2008visualizing])라는 두 가지 기술을 살펴보겠습니다.


### Tapkee 소개

Tapkee는 차원 축소를 위한 C++ 템플릿 라이브러리입니다 [@Lisitsyn2013].
이 라이브러리에는 다음을 포함한 많은 차원 축소 알고리즘이 구현되어 있습니다.

- 국소 선형 임베딩(Locally Linear Embedding)
- Isomap
- 다차원 척도법(Multidimensional Scaling)
- PCA
- t-SNE

이 알고리즘들에 대한 자세한 정보는 [Tapkee 웹사이트](http://tapkee.lisitsyn.me/)에서 찾을 수 있습니다.
Tapkee는 주로 다른 애플리케이션에 포함될 수 있는 라이브러리지만, `tapkee`라는 커맨드 라인 도구도 제공합니다.
이를 사용하여 와인 데이터셋의 차원 축소를 수행해 보겠습니다.


### 선형 및 비선형 매핑

먼저, 각 특성이 동일하게 중요하게 취급되도록 표준화(standardization)를 사용하여 특성의 스케일을 조정하겠습니다.
일반적으로 머신러닝 알고리즘을 적용할 때 스케일 조정을 하면 더 나은 결과를 얻을 수 있습니다.

스케일 조정을 위해 `rush`와 `tidyverse` 패키지를 사용합니다.


``` console
rush run --tidyverse --output wine-scaled.csv \
'select(df, -type) %>%
scale() %>%
as_tibble() %>%
mutate(type = df$type)' wine.csv
csvlook wine-scaled.csv
```
<1> `scale()` 함수는 수치형 열에만 작동하므로 *`type`* 열을 임시로 제거해야 합니다.
<2> `scale()` 함수는 데이터 프레임을 받지만 행렬을 반환합니다.
<3> `as_tibble()` 함수는 행렬을 다시 데이터 프레임으로 변환합니다.
<4> 마지막으로 *`type`* 열을 다시 추가합니다.

이제 두 가지 차원 축소 기술을 적용하고 `Rio-scatter`를 사용하여 매핑을 시각화해 보겠습니다.


``` console
xsv select '!type' wine-scaled.csv |
header -d |
tapkee --method pca |
tee wine-pca.txt | trim
```
<1> *`type`* 열을 제외합니다.
<2> 헤더를 제거합니다.
<3> PCA를 적용합니다.


``` console
< wine-pca.txt header -a pc1,pc2 |
paste -d, - <(xsv select type wine-scaled.csv) |
tee wine-pca.csv | csvlook
```
<1> *`pc1`*과 *`pc2`* 열이 있는 헤더를 다시 추가합니다.
<2> *`type`* 열을 다시 추가합니다.

이제 산점도를 생성할 수 있습니다.


``` console
rush plot --x pc1 --y pc2 --color type --shape type wine-pca.csv > wine-pca.png
display wine-pca.png
```


동일한 방식으로 t-SNE를 수행해 보겠습니다.


``` console
xsv select '!type' wine-scaled.csv |
header -d |
tapkee --method t-sne |
header -a x,y |
paste -d, - <(xsv select type wine-scaled.csv) |
rush plot --x x --y y --color type --shape type > wine-tsne.png
```
<1> *`type`* 열을 제외합니다.
<2> 헤더를 제거합니다.
<3> t-SNE를 적용합니다.
<4> *`x`*와 *`y`* 열이 있는 헤더를 다시 추가합니다.
<5> *`type`* 열을 다시 추가합니다.
<6> 산점도를 생성합니다.


``` console
display wine-tsne.png
```


t-SNE가 PCA보다 물리화학적 특성을 기반으로 레드 와인과 화이트 와인을 더 잘 분리하는 것을 볼 수 있습니다.
이 산점도들은 데이터셋이 특정한 구조를 가지고 있음을 확인시켜 줍니다. 즉, 특성과 레이블 사이에 관계가 있습니다.
이를 확인했으니 이제 안심하고 지도 학습(supervised machine learning)을 적용해 보겠습니다.
먼저 회귀 작업을 시작하고 이어서 분류 작업을 진행하겠습니다.


## Vowpal Wabbit을 사용한 회귀

이 섹션에서는 와인의 물리화학적 특성을 기반으로 화이트 와인의 품질을 예측하는 모델을 만들 것입니다.
품질은 0에서 10 사이의 숫자이므로, 이를 회귀(regression) 작업으로 간주할 수 있습니다.

이를 위해 Vowpal Wabbit, 줄여서 `vw`를 사용할 것입니다.


### 데이터 준비하기

CSV 파일로 작업하는 대신, `vw`는 자체적인 데이터 형식을 사용합니다.
`csv2vw` [@csv2vw] 도구는 이름에서 알 수 있듯이 CSV를 이 형식으로 변환할 수 있습니다.
`--label` 옵션은 어떤 열이 레이블을 포함하고 있는지 지정하는 데 사용됩니다.
결과를 살펴봅시다.


``` console
csv2vw wine-white-clean.csv --label quality | trim
```

이 형식에서 각 줄은 하나의 데이터 포인트입니다.
줄은 레이블로 시작하고, 그 뒤에 파이프 기호(`|`)가 오며, 그 다음에는 공백으로 구분된 특성 이름/값 쌍들이 옵니다.
CSV 형식과 비교했을 때 이 형식이 지나치게 장황해 보일 수도 있지만, 가중치(weights), 태그(tags), 네임스페이스(namespaces), 그리고 희소 특성 표현(sparse feature representation)과 같은 더 많은 유연함을 제공합니다.
와인 데이터셋에서는 이러한 유연성이 필요하지 않지만, 더 복잡한 문제에 `vw`를 적용할 때는 유용할 수 있습니다.
이 [기사](https://github.com/VowpalWabbit/vowpal_wabbit/wiki/Input-format)에서 `vw` 형식에 대해 더 자세히 설명하고 있습니다.

회귀 모델을 만들거나 *훈련(train)*하고 나면, 이를 사용하여 아직 보지 못한 새로운 데이터 포인트에 대해 예측을 수행할 수 있습니다.
즉, 모델이 이전에 본 적 없는 와인을 제공하면 그 품질을 예측하거나 *테스트(test)*할 수 있습니다.
이러한 예측의 정확도를 적절하게 평가하려면, 훈련에 사용하지 않을 데이터를 일부 따로 떼어놓아야 합니다.
보통 전체 데이터셋의 80%를 훈련용으로 사용하고 나머지 20%를 테스트용으로 사용합니다.

먼저 `split` [@split]을 사용하여 전체 데이터셋을 동일한 다섯 부분으로 나누어 이 작업을 수행할 수 있습니다.
`wc`를 사용하여 각 부분의 데이터 포인트 수를 확인합니다.


``` console
csv2vw wine-white-clean.csv --label quality |
shuf |
split -d -n r/5 - wine-part-
wc -l wine-part-*
```
<1> `shuf` [@shuf] 도구는 데이터셋을 무작위로 섞어서 훈련 세트와 테스트 세트가 유사한 품질 분포를 갖도록 보장합니다.

이제 첫 번째 부분(즉, 20%)을 테스트 세트인 *wine-test.vw*로 사용하고, 나머지 네 부분(즉, 80%)을 합쳐서 훈련 세트인 *wine-train.vw*를 만듭니다.


``` console
mv wine-part-00 wine-test.vw
cat wine-part-* > wine-train.vw
rm wine-part-*
wc -l wine-*.vw
```

이제 `vw`를 사용하여 모델을 훈련할 준비가 되었습니다.


### 모델 훈련하기

`vw` 도구는 매우 많은(거의 400개에 달하는!) 옵션을 제공합니다.
다행히 효과적으로 사용하기 위해 그 모든 옵션이 필요한 것은 아닙니다.
여기서 사용하는 옵션들을 설명하기 위해 각 옵션을 별도의 줄에 적어보겠습니다.


``` console
vw \
--data wine-train.vw \
--final_regressor wine.model \
--passes 10 \
--cache_file wine.cache \
--nn 3 \
--quadratic :: \
--l2 0.000005 \
--bit_precision 25
```
<1> *wine-train.vw* 파일이 모델 훈련에 사용됩니다.
<2> 모델 또는 *회귀분석기(regressor)*는 *wine.model* 파일에 저장됩니다.
<3> 훈련 패스(passes)의 횟수입니다.
<4> 여러 번의 패스를 수행할 때 캐싱이 필요합니다.
<5> 3개의 은닉 유닛(hidden units)을 가진 신경망을 사용합니다.
<6> 모든 입력 특성을 기반으로 이차(quadratic) 특성을 생성하여 사용합니다. 중복되는 특성은 `vw`에 의해 제거됩니다.
<7> L2 규제(regularization)를 사용합니다.
<8> 특성을 저장하는 데 25비트를 사용합니다.

이제 회귀 모델을 훈련시켰으니, 이를 사용하여 예측을 해보겠습니다.


### 모델 테스트하기

모델은 *wine.model* 파일에 저장되어 있습니다.
이 모델을 사용하여 예측을 수행하기 위해, 이번에는 다른 옵션들을 사용하여 `vw`를 다시 실행합니다.


``` console
vw \
--data wine-test.vw \
--initial_regressor wine.model \
--testonly \
--predictions predictions \
--quiet
bat predictions | trim
```
<1> *wine-test.vw* 파일이 모델 테스트에 사용됩니다.
<2> *wine.model* 파일에 저장된 모델을 사용합니다.
<3> 레이블 정보를 무시하고 테스트만 수행합니다.
<4> 예측 결과는 *predictions*라는 파일에 저장됩니다.
<5> 진단 메시지와 진행 상황 업데이트를 출력하지 않습니다.

`paste`를 사용하여 *predictions* 파일에 담긴 예측값과 *wine-test.vw* 파일에 담긴 실제값(관측값, observed values)을 결합해 봅시다.
`awk`를 사용하여 예측값과 관측값을 비교하고 평균 절대 오차(MAE, Mean Absolute Error)를 계산할 수 있습니다.
MAE는 화이트 와인의 품질을 예측할 때 `vw`가 평균적으로 얼마나 차이가 나는지 알려줍니다.


``` console
paste -d, predictions <(cut -d '|' -f 1 wine-test.vw) |
tee results.csv |
awk -F, '{E+=sqrt(($1-$2)^2)} END {print "MAE: " E/NR}' |
cowsay
```

예측값은 평균적으로 약 0.6점 정도 차이가 납니다.
`rush plot`을 사용하여 관측값과 예측값 사이의 관계를 시각화해 봅시다.


``` console
< results.csv header -a "predicted,observed" |
rush plot --x observed --y predicted --geom jitter > wine-regression.png
display wine-regression.png
```


모델 훈련에 사용된 옵션들이 조금 복잡해 보일 수 있습니다.
모든 기본값(default values)을 사용했을 때 `vw`의 성능이 어떠한지 확인해 봅시다.


``` console
vw -d wine-train.vw -f wine2.model --quiet
vw -data wine-test.vw -i wine2.model -t -p predictions --quiet
paste -d, predictions <(cut -d '|' -f 1 wine-test.vw) |
awk -F, '{E+=sqrt(($1-$2)^2)} END {print "MAE: " E/NR}'
```
<1> 회귀 모델 훈련
<2> 회귀 모델 테스트
<3> 평균 절대 오차(MAE) 계산

기본값을 사용했을 때 MAE가 0.04 더 높게 나타났습니다. 이는 예측 결과가 약간 더 나빠졌음을 의미합니다.

이 섹션에서는 `vw`가 할 수 있는 일의 극히 일부만을 다루었습니다.
이 도구에 그렇게 많은 옵션이 있는 데는 이유가 있습니다.
회귀 외에도 이진 분류(binary classification), 다중 클래스 분류(multi-class classification), 강화 학습(reinforcement learning), 그리고 잠재 디리클레 할당(Latent Dirichlet Allocation, LDA) 등을 지원합니다.
[웹사이트](https://vowpalwabbit.org/)에서 더 많은 튜토리얼과 기사를 찾아볼 수 있습니다.


## SciKit-Learn Laboratory를 사용한 분류

<!-- TODO: Explain SKLL better -->

이 섹션에서는 와인이 레드인지 화이트인지를 예측하는 분류 모델(분류기, classifier)을 훈련시킬 것입니다.
이 작업에도 `vw`를 사용할 수 있지만, 다른 도구인 SciKit-Learn Laboratory(SKLL)를 소개해 드리고 싶습니다.
이름에서 알 수 있듯이, 이 도구는 파이썬에서 널리 쓰이는 머신러닝 패키지인 SciKit-Learn을 기반으로 구축되었습니다.
SKLL 자체도 파이썬 패키지이며, 커맨드 라인에서 SciKit-Learn을 사용할 수 있게 해주는 `run_experiment` 도구를 제공합니다.
저는 패키지 이름과 일치하여 기억하기 쉬운 `skll`이라는 별칭(alias)을 사용하여 `run_experiment`를 호출하겠습니다.


``` console
alias skll=run_experiment
skll
```


### 데이터 준비하기

`skll`은 훈련용 데이터셋과 테스트용 데이터셋이 서로 다른 디렉터리에 있되 같은 파일 이름을 가질 것을 기대합니다.
예측치(predictions)가 반드시 원래 데이터셋과 같은 순서로 나오지 않으므로, 예측치를 올바른 데이터 포인트와 일치시킬 수 있도록 고유 식별자를 포함하는 *`id`* 열을 추가하겠습니다.
균형 잡힌(balanced) 데이터셋을 만들어 봅시다.


``` console
NUM_RED="$(< wine-red-clean.csv wc -l)"
csvstack -n type -g red,white \
wine-red-clean.csv \
<(< wine-white-clean.csv body shuf | head -n $NUM_RED) |
body shuf |
nl -s, -w1 -v0 |
sed '1s/0,/id,/' |
tee wine-balanced.csv | csvlook
```
<1> 레드 와인의 수를 *`NUM_RED`* 변수에 저장합니다.
<2> 모든 레드 와인과 무작위로 샘플링된 동일한 수의 화이트 와인을 결합합니다.
<3> `nl`을 사용하여 각 줄 앞에 "줄 번호"를 추가합니다.
<4> 적절한 열 이름이 되도록 첫 번째 줄의 "0"을 "id"로 바꿉니다.

이제 이 균형 잡힌 데이터셋을 훈련 세트와 테스트 세트로 나눕니다.


``` console
mkdir -p {train,test}
HEADER="$(< wine-balanced.csv header)"
< wine-balanced.csv header -d | shuf | split -d -n r/5 - wine-part-
wc -l wine-part-*
cat wine-part-00 | header -a $HEADER > test/features.csv && rm wine-part-00
cat wine-part-* | header -a $HEADER > train/features.csv && rm wine-part-*
wc -l t*/features.csv
```

이제 균형 잡힌 훈련 세트와 테스트 세트가 준비되었으니, 분류기를 만드는 단계를 진행할 수 있습니다.


### 실험 실행하기

`skll`에서 분류기를 훈련시키려면 설정 파일(configuration file)에 실험을 정의해야 합니다.
이 정의에는 데이터셋을 어디서 찾을지, 어떤 분류기를 사용할지 등을 명시하는 여러 섹션이 포함됩니다.
여기서 사용할 설정 파일 *classify.cfg*는 다음과 같습니다.


``` console
bat classify.cfg
```

`skll`을 사용하여 실험을 실행합니다.


``` console
skll -l classify.cfg 2>/dev/null
```

`-l` 옵션은 로컬 모드에서 실행할 것을 지정합니다.
`skll`은 클러스터에서 실험을 실행하는 기능도 제공합니다.
실험이 완료되는 데 걸리는 시간은 선택한 알고리즘의 복잡도와 데이터의 크기에 따라 달라집니다.


### 결과 분석하기

모든 분류기의 훈련과 테스트가 완료되면, 결과는 *output* 디렉터리에서 확인할 수 있습니다.


``` console
ls -1 output
```

`skll`은 각 분류기에 대해 네 개의 파일을 생성합니다: 로그 파일 한 개, 결과 파일 두 개, 그리고 예측값 파일 한 개입니다.
다음 SQL 쿼리를 사용하여 알고리즘 이름과 등급별 정확도를 추출해 보겠습니다.


``` console
< output/wine_summary.tsv csvsql --query "SELECT learner_name, accuracy FROM stdin ORDER BY accuracy DESC" | csvlook -I
```

여기서 가장 중요한 열은 정확도를 나타내는 *`accuracy`*로, 이는 올바르게 분류된 데이터 포인트의 비율을 의미합니다.
이를 통해 실제로 모든 알고리즘이 매우 좋은 성능을 보이고 있음을 알 수 있습니다.
RandomForestClassifier가 가장 좋은 성능을 보였고, 그 뒤를 KNeighborsClassifier가 근소한 차이로 따르고 있습니다.

각 JSON 파일에는 혼동 행렬(confusion matrix)이 포함되어 있어 각 분류기의 성능에 대한 추가적인 통찰을 제공합니다.
혼동 행렬은 열이 실제 레이블(레드와 화이트)을 나타내고 행이 예측된 레이블을 나타내는 표입니다.
대각선 상의 숫자가 높을수록 정확한 예측이 많음을 의미합니다.
`jq`를 사용하여 각 분류기의 이름과 해당 혼동 행렬을 인쇄할 수 있습니다.


``` console
jq -r '.[] | "\(.learner_name):\n\(.result_table)\n"' output/*.json
```

혼동 행렬은 특히 분류해야 할 클래스가 세 개 이상일 때 어떤 종류의 오분류가 발생하는지 확인하거나, 각 클래스별로 오분류 비용이 다를 때 특히 도움이 됩니다.

사용 관점에서 볼 때, `vw`와 `skll`이 서로 다른 두 가지 접근 방식을 취한다는 점이 흥미롭습니다.
`vw`는 커맨드 라인 옵션을 사용하는 반면, `skll`은 별도의 설정 파일이 필요합니다.
두 방식 모두 장단점이 있습니다.
커맨드 라인 옵션은 더 즉흥적인 사용을 가능하게 하지만, 설정 파일은 아마도 재현(reproduce)하기가 더 쉽습니다.
또한 이미 보았듯이, 수많은 옵션과 함께 `vw`를 호출하는 방식은 스크립트나 *Makefile*에 쉽게 넣을 수 있습니다.
반대로, `skll`이 설정 파일 없이 옵션을 받도록 만드는 것은 비교적 덜 명확합니다.


## 요약

이 장에서는 데이터 모델링에 대해 살펴보았습니다.
예제를 통해 비지도 학습인 차원 축소, 그리고 지도 학습인 회귀와 분류라는 세 가지 서로 다른 머신러닝 작업에 대해 깊이 파고들어 보았습니다.
아쉽게도 본격적인 머신러닝 튜토리얼은 이 책의 범위를 벗어납니다.
머신러닝에 대해 더 배우고 싶은 분들을 위해 다음 섹션에서 몇 권의 책을 추천해 드립니다.
이것으로 이 책에서 다루는 데이터 과학 OSEMN 모델의 네 번째이자 마지막 단계를 마쳤습니다.
다음 장은 마지막 중간 막(intermezzo) 장으로, 커맨드 라인을 다른 곳에서 활용하는 방법을 다룰 것입니다.


## 더 읽어보기

- Sebastian Raschka와 Vahid Mirjalili의 저서 *Python Machine Learning*은 머신러닝에 대한 포괄적인 개요와 파이썬을 사용한 적용 방법을 제공합니다.
- Jared Lander의 *R for Everyone*의 후반부 장들에서 R을 사용하여 다양한 머신러닝 작업을 수행하는 방법을 설명합니다.
- 머신러닝에 대해 더 깊이 이해하고 싶다면, Christopher Bishop의 *Pattern Recognition and Machine Learning*과 David MacKay의 *Information Theory, Inference, and Learning Algorithms*를 강력히 추천합니다.
- t-SNE 알고리즘에 대해 더 자세히 알고 싶다면, Laurens van der Maaten과 Geoffrey Hinton의 원저 논문인 *Visualizing Data Using T-SNE*를 추천합니다.

