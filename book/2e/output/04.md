---
suppress-bibliography: true
---





<!-- TODO: Remove dashes from filenames top-words.sh etc. -->


# 커맨드 라인 도구 만들기 {#chapter-4-creating-command-line-tools}

이 책 전반에 걸쳐 기본적으로 한 줄로 작성되는 많은 명령어와 파이프라인을 소개해 드릴 것입니다.
이들은 원라이너(one-liner) 또는 파이프라인으로 알려져 있습니다.
단 한 줄의 명령어만으로 복잡한 작업을 수행할 수 있다는 점이 커맨드 라인을 강력하게 만드는 대목입니다.
이는 전통적인 프로그램을 작성하고 사용하는 것과는 매우 다른 경험입니다.

어떤 작업은 단 한 번만 수행하지만, 어떤 작업은 더 자주 수행하게 됩니다.
또 어떤 작업은 매우 구체적이지만, 다른 작업은 일반화될 수 있습니다.
특정 원라이너를 정기적으로 반복해야 한다면, 이를 하나의 독립적인 커맨드 라인 도구로 만드는 것이 가치가 있습니다.
원라이너와 커맨드 라인 도구는 각자의 용도가 있습니다.
그 기회를 알아보는 데는 연습과 기술이 필요합니다.
커맨드 라인 도구의 장점은 원라이너 전체를 기억할 필요가 없다는 점과, 다른 파이프라인에 포함시켰을 때 가독성을 높여준다는 점입니다.
그런 의미에서 커맨드 라인 도구는 프로그래밍 언어의 함수와 비슷하다고 생각할 수 있습니다.

하지만 프로그래밍 언어로 작업할 때의 이점은 코드가 하나 이상의 파일에 담겨 있다는 점입니다.
이는 코드를 쉽게 수정하고 재사용할 수 있음을 의미합니다.
코드에 매개변수(parameter)가 있다면 일반화하여 비슷한 패턴의 문제들에 다시 적용할 수도 있습니다.

커맨드 라인 도구는 양쪽의 장점을 모두 가집니다. 커맨드 라인에서 사용할 수 있고, 매개변수를 받을 수 있으며, 단 한 번만 만들면 됩니다.
이 장에서는 두 가지 방식으로 커맨드 라인 도구를 만드는 법을 익힐 것입니다.
첫째로, 원라이너를 재사용 가능한 커맨드 라인 도구로 바꾸는 방법을 설명합니다.
명령어에 매개변수를 추가함으로써 프로그래밍 언어가 제공하는 것과 동일한 유연성을 더할 수 있습니다.
그다음에는 프로그래밍 언어로 작성된 코드로부터 재사용 가능한 커맨드 라인 도구를 만드는 방법을 시연하겠습니다.
유닉스 철학을 따름으로써, 여러분의 코드는 전혀 다른 언어로 작성된 다른 커맨드 라인 도구들과 조합될 수 있습니다.
이 장에서는 Bash, Python, R 세 가지 프로그래밍 언어에 집중할 것입니다.

재사용 가능한 커맨드 라인 도구를 만드는 것이 장기적으로 여러분을 더 효율적이고 생산적인 데이터 과학자로 만들어 줄 것이라고 믿습니다.
여러분은 기존 도구들을 꺼내어 이전에 마주했던 문제들에 적용할 수 있는 자신만의 데이터 과학 도구 상자를 점진적으로 구축해 나갈 것입니다.
원라이너나 기존 코드를 커맨드 라인 도구로 바꿀 기회를 포착하는 데는 연습이 필요합니다.

\BeginKnitrBlock{rmdtip}<div class="rmdtip">원라이너를 쉘 스크립트로 바꾸기 위해 아주 기초적인 쉘 스크립팅을 사용할 것입니다.
이 책에서는 변수, 조건문, 반복문 등 쉘 스크립팅의 아주 일부 개념들만 보여드립니다.
쉘 스크립팅 전체 과정은 그 자체로 책 한 권 분량이 될 수 있으므로, 이 책의 범위를 벗어납니다.
쉘 스크립팅에 대해 더 깊이 공부하고 싶다면 @Robbins2005 가 쓴 *Classic Shell Scripting*을 추천합니다.</div>\EndKnitrBlock{rmdtip}

## 개요

이 장에서 여러분은 다음 내용을 배우게 됩니다.

- 원라이너를 매개변수가 있는 쉘 스크립트로 변환하기
- 기존 Python 및 R 코드를 재사용 가능한 커맨드 라인 도구로 바꾸기

이 장은 다음 파일들로 시작합니다.


``` console
cd /data/ch04
l
```

이 파일들을 얻는 방법은 [2장](#chapter-2-getting-started)에 설명되어 있습니다.
그 외의 파일들은 커맨드 라인 도구를 사용하여 다운로드하거나 생성한 것들입니다.

## 원라이너를 쉘 스크립트로 변환하기

이 절에서는 원라이너를 재사용 가능한 커맨드 라인 도구로 만드는 방법을 설명하겠습니다.
텍스트 한 조각에서 가장 자주 등장하는 단어들을 구하고 싶다고 해봅시다.
가장 훌륭한 다른 책들처럼 프로젝트 구텐베르크에서 무료로 제공되는 루이스 캐럴의 *이상한 나라의 앨리스*를 가져와 보겠습니다.


``` console
curl -sL "https://www.gutenberg.org/files/11/11-0.txt" | trim
```

다음과 같은 도구의 시퀀스 혹은 *파이프라인*이 그 작업을 해줄 것입니다.


``` console
curl -sL "https://www.gutenberg.org/files/11/11-0.txt" | # <1>
tr '[:upper:]' '[:lower:]' | # <2>
grep -oE "[a-z\']{2,}" | # <3>
sort | # <4>
uniq -c | # <5>
sort -nr | # <6>
head -n 10 # <7>
```
<1> `curl`을 사용하여 전자책을 다운로드합니다.
<2> `tr` [@tr]을 사용하여 전체 텍스트를 소문자로 변환합니다.
<3> `grep` [@grep]을 사용하여 모든 단어를 추출하고 각 단어를 별도의 줄에 놓습니다.
<4> `sort` [@sort]를 사용하여 이 단어들을 알파벳 순으로 정렬합니다.
<5> `uniq` [@uniq]를 사용하여 모든 중복을 제거하고 각 단어가 목록에 몇 번이나 나타나는지 셉니다.
<6> `sort`를 사용하여 이 고유 단어 목록을 빈도수에 따라 내림차순으로 정렬합니다.
<7> `head`를 사용하여 상위 10개 행(단어)만 남깁니다.

이러한 단어들이 실제로 텍스트에서 가장 자주 나타납니다.
이 단어들은 ("alice"를 제외하고) 많은 영어 텍스트에서 매우 빈번하게 나타나기 때문에 의미를 거의 담고 있지 않습니다.
사실 이러한 단어들을 *불용어(stopwords)*라고 부릅니다.
이들을 제거한다면 우리는 이 텍스트와 관련된 가장 빈번한 단어들을 얻게 될 것입니다.

찾아둔 불용어 목록은 다음과 같습니다.


``` console
curl -sL "https://raw.githubusercontent.com/stopwords-iso/stopwords-en/master/stopwords-en.txt" |
sort | tee stopwords | trim 20
```

`grep`을 사용하여 빈도수를 세기 직전에 불용어들을 필터링할 수 있습니다.


``` console
curl -sL "https://www.gutenberg.org/files/11/11-0.txt" |
tr '[:upper:]' '[:lower:]' |
grep -oE "[a-z\']{2,}" |
sort |
grep -Fvwf stopwords |
uniq -c |
sort -nr |
head -n 10
```
<1> `-f`를 사용하여 파일(우리의 경우 *stopwords*)에서 한 줄에 하나씩 패턴을 가져옵니다. `-F`를 사용하여 이 패턴들을 고정 문자열로 해석합니다. `-w`를 사용하여 전체 단어를 형성하는 일치 항목들만 선택합니다. `-v`를 사용하여 일치하지 않는 줄들을 선택합니다.

\BeginKnitrBlock{rmdtip}<div class="rmdtip">이 원라이너에 사용된 각 커맨드 라인 도구들은 매뉴얼 페이지를 제공합니다.
따라서 `grep`에 대해 더 알고 싶다면 커맨드 라인에서 `man grep`을 실행하면 됩니다.
`tr`, `grep`, `uniq`, `sort` 도구들은 다음 장에서 더 자세히 다루겠습니다.</div>\EndKnitrBlock{rmdtip}

이 원라이너를 단 한 번만 실행하는 데는 아무런 문제가 없습니다.
하지만 프로젝트 구텐베르크의 모든 전자책에 대해 상위 10개 단어를 얻고 싶다고 상상해 보세요.
혹은 뉴스 웹사이트의 상위 10개 단어를 매시간 얻고 싶다고 상상해 보세요.
그럴 경우에는 이 원라이너를 더 큰 무언가의 일부가 될 수 있는 별도의 빌딩 블록으로 가지는 것이 가장 좋습니다.
매개변수 측면에서 이 원라이너에 유연성을 더하기 위해, 이를 쉘 스크립트로 바꿔봅시다.

이를 통해 원라이너를 출발점으로 삼아 점진적으로 개선해 나갈 수 있습니다.
이 원라이너를 재사용 가능한 커맨드 라인 도구로 바꾸기 위해, 다음의 6단계를 안내해 드리겠습니다.

1.  원라이너를 파일에 복사하여 붙여넣습니다.
2.  실행 권한을 추가합니다.
3.  소위 쉬뱅(shebang)을 정의합니다.
4.  고정된 입력 부분을 제거합니다.
5.  매개변수를 추가합니다.
6.  (선택 사항) PATH를 확장합니다.


### 1단계: 파일 생성

첫 번째 단계는 새 파일을 만드는 것입니다.
평소 즐겨 쓰는 텍스트 에디터를 열고 원라이너를 붙여넣으세요.
우리의 새로운 커맨드 라인 도구를 향한 첫걸음이라는 의미로 파일 이름을 *top-words-1.sh*라고 지읍시다. 만약 커맨드 라인에 머물고 싶다면, 내장 명령어인 `fc`(*fix command*의 줄임말)를 사용할 수 있습니다. `fc`는 마지막으로 실행한 명령어를 수정하거나 *편집*할 수 있게 해줍니다.


``` console
fc #! enter=FALSE
```

`fc`를 실행하면 환경 변수 *EDITOR*에 저장된 기본 텍스트 에디터가 실행됩니다.
Docker 컨테이너에서는 이것이 사용하기 쉬운 텍스트 에디터인 `nano`로 설정되어 있습니다.
보시다시피 이 파일에는 우리의 원라이너가 들어 있습니다.


``` console
Enter #! literal=FALSE, hold=0.2, wait=0.2
```

**`Ctrl-O`**를 누르고 임시 파일 이름을 지운 뒤 `top-words-1.sh`를 입력하여 이 임시 파일에 제대로 된 이름을 붙여줍시다.


``` console
C-O BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace BSpace #! literal=FALSE
top-words-1.sh#! enter=FALSE
```

**`Enter`**를 누르세요.


``` console
Enter #! literal=FALSE
```

다른 이름으로 저장할 것인지 묻는 확인창에서 **`Y`**를 누릅니다.


``` console
Y #! literal=FALSE
```

**`Ctrl-X`**를 눌러 `nano`를 종료하고 원래 있던 곳으로 돌아갑니다.



쉘 스크립트를 만들고 있다는 것을 분명히 하기 위해 파일 확장자 *.sh*를 사용하고 있습니다.
하지만 커맨드 라인 도구에 확장자가 꼭 필요한 것은 아닙니다.
실제로 커맨드 라인 도구는 확장자를 거의 갖지 않습니다.

파일의 내용을 확인합니다.


``` console
pwd
l
bat top-words-1.sh
```

이제 `bash` [@bash]를 사용하여 파일의 명령어를 해석하고 실행할 수 있습니다.


``` console
bash top-words-1.sh
```

이렇게 하면 다음에 다시 원라이너를 입력할 필요가 없습니다.

하지만 파일이 스스로 독립적으로 실행될 수 없으므로, 아직은 *진정한* 커맨드 라인 도구라고 할 수 없습니다.
다음 단계에서 이를 바꿔봅시다.


### 2단계: 실행 권한 부여

파일을 직접 실행할 수 없는 이유는 올바른 접근 권한이 없기 때문입니다.
특히 여러분이라는 사용자가 파일에 대한 실행 권한을 가지고 있어야 합니다.
이 절에서는 파일의 접근 권한을 변경합니다.

각 단계 간의 차이를 비교하기 위해 `cp -v top-words-{1,2}.sh`를 사용하여 파일을 *top-words-2.sh*로 복사합니다.

\BeginKnitrBlock{rmdtip}<div class="rmdtip">중괄호 확장(brace expansion)이나 다른 형태의 파일 확장이 어떤 결과로 이어지는지 확인하고 싶다면, 명령어를 `echo`로 바꿔서 결과를 인쇄만 해보세요.
예를 들어 `echo book_{draft,final}.md`나 `echo agent-{001..007}`과 같이 할 수 있습니다.</div>\EndKnitrBlock{rmdtip}

파일의 접근 권한을 변경하려면 `chmod` [@chmod](*change mode*의 줄임말)라는 커맨드 라인 도구를 사용해야 합니다.
이 도구는 특정 파일의 파일 모드 비트를 변경합니다.
다음 명령어는 여러분이라는 사용자에게 *top-words-2.sh*에 대한 실행 권한을 부여합니다.


``` console
cp -v top-words-{1,2}.sh
chmod u+x top-words-2.sh
```

인자 `u+x`는 세 문자로 구성됩니다. (1) `u`는 파일을 소유한 사용자(파일을 만든 여러분)를 위해 권한을 변경하고 싶음을 나타내고, (2) `+`는 권한을 추가하고 싶음을 나타내며, (3) `x`는 실행 권한을 나타냅니다.

이제 두 파일의 접근 권한을 살펴봅시다.


``` console
l top-words-{1,2}.sh
```

첫 번째 컬럼은 각 파일에 대한 접근 권한을 보여줍니다.
*top-words-2.sh*의 경우 *`-rwxrw-r--`*입니다.
첫 번째 문자 *`-`*(하이픈)는 파일 형식을 나타냅니다.
*`-`*는 일반 파일을, *`d`*는 디렉터리를 의미합니다.
그다음 세 문자 *`rwx`*는 파일을 소유한 사용자에 대한 접근 권한을 나타냅니다.
*`r`*과 *`w`*는 각각 *읽기(read)*와 *쓰기(write)*를 의미합니다.
(보시다시피 *top-words-1.sh*는 *`x`* 대신 *`-`*를 가지고 있는데, 이는 그 파일을 *실행*할 수 없음을 의미합니다.) 그다음 세 문자 *`rw-`*는 파일을 소유한 그룹의 모든 구성원에 대한 접근 권한을 나타냅니다.
마지막 세 문자 *`r--`*는 다른 모든 사용자에 대한 접근 권한을 나타냅니다.

이제 다음과 같이 파일을 실행할 수 있습니다.


``` console
./top-words-2.sh
```

만약 *top-words-1.sh*처럼 올바른 접근 권한이 없는 파일을 실행하려고 하면 다음과 같은 오류 메시지가 보일 것입니다.


``` console
./top-words-1.sh
```

### 3단계: 쉬뱅(Shebang) 정의

파일을 독립적으로 실행할 수는 있지만, 파일에 소위 쉬뱅(shebang)이라고 불리는 것을 추가해야 합니다.
*쉬뱅*은 시스템에 명령어를 해석하는 데 어떤 실행 파일을 사용해야 하는지 알려주는 명령 스크립트의 특별한 줄입니다.

*쉬뱅*이라는 이름은 해시(she)와 느낌표(bang)인 처음 두 문자 `#!`에서 유래했습니다.
이전 단계에서 했던 것처럼 이를 빠뜨리는 것은 좋지 않은데, 각 쉘마다 기본 실행 파일이 다르기 때문입니다.
책 전체에서 사용하고 있는 Z 쉘(Z shell)은 쉬뱅이 정의되지 않은 경우 기본적으로 */bin/sh* 실행 파일을 사용합니다.
이 경우에는 `bash`가 명령어를 해석하도록 하고 싶은데, 이는 `sh`보다 더 많은 기능을 제공하기 때문입니다.

다시 말하지만, 어떤 에디터를 사용하든 자유지만 저는 Docker 이미지에 설치된 `nano` [@nano]를 계속 사용하겠습니다.


``` console
cp -v top-words-{2,3}.sh
nano top-words-3.sh #! enter=FALSE
```


``` text
Enter #! literal=FALSE
```
가서 *`#!/usr/bin/env bash`*를 타이핑하고 **`Enter`**를 누르세요.
준비가 되면 **`Ctrl-X`**를 눌러 저장하고 종료합니다.


``` text
# ! #! literal=FALSE
/usr/bin/env bash #! expect_prompt=FALSE
C-X #! literal=FALSE
```

파일을 저장할 것인지 묻는 확인창에서 **`Y`**를 누릅니다.


``` text
Y #! literal=FALSE
```

*top-words-3.sh*가 어떻게 생겼는지 확인해 봅시다.




``` console
bat top-words-3.sh
```

우리가 필요한 바로 그 모습입니다. 원래의 파이프라인 앞에 쉬뱅이 붙어 있습니다.

가끔 *`#!/usr/bin/bash`*나 *`#!/usr/bin/python`*(다음 절에서 보게 될 파이썬의 경우) 형태의 쉬뱅을 가진 스크립트를 보게 될 것입니다.
대개는 잘 작동하지만, 만약 `bash`나 `python` [@python] 실행 파일이 */usr/bin*이 아닌 다른 위치에 설치되어 있다면 그 스크립트는 더 이상 작동하지 않습니다.
제가 여기서 보여드린 형태인 *`#!/usr/bin/env bash`*나 *`#!/usr/bin/env python`*을 사용하는 것이 더 좋습니다. 왜냐하면 `env` [@env] 실행 파일은 `bash`와 `python`이 어디에 설치되어 있는지 알고 있기 때문입니다.
즉, `env`를 사용하는 것이 여러분의 스크립트를 더 이식성 있게(portable) 만듭니다.


### 4단계: 고정된 입력 제거

이제 커맨드 라인에서 실행할 수 있는 유효한 커맨드 라인 도구를 갖게 되었습니다.
하지만 여기서 더 개선할 수 있습니다.
우리의 커맨드 라인 도구를 더 재사용 가능하게 만들 수 있습니다.
파일의 첫 번째 명령어는 `curl`인데, 가장 자주 쓰이는 10개 단어를 얻고자 하는 텍스트를 다운로드합니다.
즉, 데이터와 작업이 하나로 합쳐져 있습니다.

다른 전자책이나 다른 텍스트에서 상위 10개 단어를 얻고 싶다면 어떻게 될까요? 입력 데이터가 도구 자체 내에 고정되어 있습니다.
입력 데이터를 커맨드 라인 도구에서 분리하는 것이 더 낫습니다.

커맨드 라인 도구의 사용자가 텍스트를 제공한다고 가정하면, 도구는 범용적으로 적용될 수 있게 됩니다.
따라서 해결책은 스크립트에서 `curl` 명령어를 제거하는 것입니다.
*top-words-4.sh*라는 이름의 업데이트된 스크립트는 다음과 같습니다.


``` console
cp -v top-words-{3,4}.sh
sed -i '2d' top-words-4.sh
bat top-words-4.sh
```

이것이 작동하는 이유는 `tr`과 같이 표준 입력으로부터 데이터를 필요로 하는 명령어로 스크립트를 시작하면, 커맨드 라인 도구에 전달된 입력을 그대로 받기 때문입니다.
예를 들면 다음과 같습니다.


``` console
curl -sL 'https://www.gutenberg.org/files/11/11-0.txt' | ./top-words-4.sh
curl -sL 'https://www.gutenberg.org/files/12/12-0.txt' | ./top-words-4.sh
man bash | ./top-words-4.sh
```

\BeginKnitrBlock{rmdtip}<div class="rmdtip">비록 우리 스크립트에서는 그렇게 하지 않았지만, 데이터를 저장하는 경우에도 동일한 원칙이 적용됩니다.
일반적으로 스크립트가 특정 파일에 쓰도록 하는 것보다 출력 리다이렉션을 사용하여 사용자가 알아서 처리하게 하는 것이 좋습니다.
물론 오직 여러분의 프로젝트에서만 사용할 도구라면 얼마나 구체적이어야 하는지에 제한은 없습니다.</div>\EndKnitrBlock{rmdtip}


### 5단계: 인자(Argument) 추가

커맨드 라인 도구를 더욱 재사용 가능하게 만들기 위한 한 단계가 더 남았습니다: 바로 매개변수입니다.
우리의 커맨드 라인 도구에는 몇 가지 고정된 커맨드 라인 인자가 있습니다. 예를 들어 `sort`를 위한 `-nr`이나 `head`를 위한 `-n 10` 같은 것들입니다.
전자의 인자는 고정된 상태로 두는 것이 좋을 것입니다.
하지만 `head` 명령어에 대해 서로 다른 값을 허용하는 것은 매우 유용할 것입니다.
이렇게 하면 최종 사용자가 출력할 "가장 자주 사용되는 단어의 개수"를 직접 설정할 수 있습니다.
파일 *top-words-5.sh*의 모습은 다음과 같습니다.




``` console
bat top-words-5.sh
```

* 변수 *NUM_WORDS*는 Bash의 특별한 변수인 *\$1* 값으로 설정됩니다. 이는 커맨드 라인 도구에 전달된 첫 번째 커맨드 라인 인자를 담고 있습니다. 아래 표는 Bash가 제공하는 다른 특수 변수들을 나열합니다. 만약 값이 지정되지 않으면 기본값으로 "10"을 가지게 됩니다.
* *\$NUM_WORDS* 변수의 값을 *사용*하려면 앞에 달러 기호를 붙여야 한다는 점에 유의하세요. 값을 *설정*할 때는 달러 기호를 쓰지 않습니다.

`head`의 인자로 *\$1*을 직접 사용할 수도 있고 *NUM_WORDS*와 같은 추가 변수를 만드는 수고를 하지 않아도 됩니다.
하지만 스크립트가 커지고 *\$2*, *\$3*과 같은 더 많은 커맨드 라인 인자가 생길 때는 이름이 붙은 변수를 사용하는 것이 코드의 가독성을 높여줍니다.

이제 텍스트의 상위 20개 단어를 보고 싶다면 다음과 같이 커맨드 라인 도구를 호출하면 됩니다.


``` console
curl -sL "https://www.gutenberg.org/files/11/11-0.txt" > alice.txt
< alice.txt ./top-words-5.sh 20
```

만약 사용자가 숫자를 지정하지 않으면 스크립트는 상위 10개 단어를 보여줍니다.


``` console
< alice.txt ./top-words-5.sh
```

### 6단계: PATH 확장


앞선 5단계를 거쳐 마침내 재사용 가능한 커맨드 라인 도구 구축을 마쳤습니다.
하지만 매우 유용할 수 있는 단계가 하나 더 있습니다.
이 선택적인 단계에서는 여러분의 커맨드 라인 도구를 어디에서나 실행할 수 있도록 보장할 것입니다.

현재로서는 커맨드 라인 도구를 실행하고 싶을 때, 해당 도구가 있는 디렉터리로 이동하거나 2단계에서 보여드린 것처럼 전체 경로 이름을 포함해야 합니다.
커맨드 라인 도구가 가령 특정 프로젝트만을 위해 만들어진 것이라면 괜찮습니다.
하지만 도구가 여러 상황에서 적용될 수 있다면, 우분투와 함께 제공되는 도구들처럼 어디서나 실행할 수 있는 것이 유용합니다.

이를 달성하기 위해 Bash는 여러분의 커맨드 라인 도구를 어디서 찾아야 할지 알아야 합니다.
Bash는 *PATH*라 불리는 환경 변수에 저장된 디렉터리 목록을 탐색함으로써 이 작업을 수행합니다.
새로 생성된 Docker 컨테이너에서 *PATH*는 다음과 같습니다.


``` console
echo $PATH
```

디렉터리들은 콜론으로 구분됩니다.
콜론을 줄바꿈으로 *변환(translating)*하여 디렉터리 목록으로 출력할 수 있습니다.


``` console
echo $PATH | tr ':' '\n'
```

*PATH*를 영구적으로 변경하려면 홈 디렉터리에 있는 *.bashrc* 또는 *.profile* 파일을 편집해야 합니다.
모든 사용자 지정 커맨드 라인 도구를 한 디렉터리(예: *\~/tools*)에 모아둔다면 *PATH*를 한 번만 변경하면 됩니다.
그러면 이제 더 이상 *./*를 붙일 필요 없이 파일 이름만 사용할 수 있습니다.
나아가 도구가 어디에 위치해 있는지 기억할 필요도 없습니다.


``` console
cp -v top-words{-5.sh,}
export PATH="${PATH}:/data/ch04"
echo $PATH
curl "https://www.gutenberg.org/files/11/11-0.txt" |
top-words 10
```


## Python과 R로 커맨드 라인 도구 만들기

앞 절에서 우리가 만든 커맨드 라인 도구는 Bash로 작성되었습니다.
(Bash 프로그래밍 언어의 모든 기능이 사용된 것은 아니지만, 해석기는 여전히 `bash`였습니다.) 이제 아시다시피 커맨드 라인은 언어에 구애받지 않으므로 커맨드 라인 도구를 만드는 데 반드시 Bash를 사용해야 하는 것은 아닙니다.

이 절에서는 커맨드 라인 도구가 다른 프로그래밍 언어로도 만들어질 수 있음을 보여드리겠습니다.
데이터 과학 커뮤니티에서 가장 인기 있는 두 언어인 Python과 R에 집중하겠습니다.
두 언어에 대한 완전한 입문을 제공할 수는 없으므로, 여러분이 Python이나 R에 어느 정도 익숙하다고 가정하겠습니다.
Java, Go, Julia와 같은 다른 언어들도 커맨드 라인 도구를 만드는 데 있어서는 비슷한 패턴을 따릅니다.

Bash가 아닌 다른 언어로 커맨드 라인 도구를 만드는 데는 세 가지 주요 이유가 있습니다.
첫째, 커맨드 라인에서 사용하고 싶은 기존 코드가 이미 있을 수 있습니다.
둘째, 커맨드 라인 도구가 수백 줄의 Bash 코드로 구성될 정도로 복잡해질 수 있습니다.
셋째, 도구가 더 안전하고 견고해야 할 때입니다(Bash는 타입 체크와 같은 많은 기능이 부족합니다).

이전 절에서 논의한 6단계는 다른 언어로 커맨드 라인 도구를 만들 때도 대략적으로 적용됩니다.
하지만 첫 번째 단계는 커맨드 라인에서 복사해서 붙여넣는 것이 아니라, 관련 코드를 새 파일에 복사해서 붙여넣는 것이 될 것입니다.
Python과 R로 작성된 커맨드 라인 도구는 쉬뱅 뒤에 각각 `python`과 `Rscript` [@R]를 해석기로 지정해야 합니다.

Python과 R을 사용하여 커맨드 라인 도구를 만들 때 특히 주의를 기울여야 할 두 가지 측면이 더 있습니다.
첫째, 쉘 스크립트에는 자연스러운 표준 입력 처리를 Python과 R에서는 명시적으로 처리해야 합니다.
둘째, Python과 R로 작성된 커맨드 라인 도구는 더 복잡해지는 경향이 있으므로 사용자에게 더 정교한 커맨드 라인 인자를 지정할 수 있는 기능을 제공하고 싶을 수 있습니다.

### 쉘 스크립트 포팅하기

시작점으로, 방금 만든 쉘 스크립트를 Python과 R로 어떻게 포팅하는지 살펴봅시다.
다시 말해, 어떤 Python과 R 코드가 표준 입력으로부터 가장 자주 쓰이는 단어들을 우리에게 줄까요? 먼저 *top-words.py*와 *top-words.R* 두 파일을 보여드리고 쉘 코드와의 차이점을 논의하겠습니다.
Python에서 코드는 다음과 같을 것입니다.


``` console
cd /data/ch04
bat top-words.py
```

이 Python 예제는 서드파티 패키지를 사용하지 않았음에 유의하세요.
고급 텍스트 처리를 원한다면 NLTK 패키지 [@Perkins2010]를 확인해 보기를 권장합니다.
많은 수치 데이터를 다룰 예정이라면 Pandas 패키지 [@McKinney2012] 사용을 추천합니다.

그리고 R에서 코드는 다음과 같을 것입니다.


``` console
bat top-words.R
```

세 가지 구현(Bash, Python, R)이 동일한 빈도수로 동일한 상위 5개 단어를 반환하는지 확인해 봅시다.


``` console
time < alice.txt top-words 5
time < alice.txt top-words.py 5
time < alice.txt top-words.R 5
```

훌륭합니다! 물론 출력 결과물 자체가 매우 흥미진진한 것은 아닙니다.
흥미로운 점은 우리가 여러 언어로 동일한 과업을 완수할 수 있다는 사실입니다.
접근 방식 간의 차이점을 살펴봅시다.

우선 즉각적으로 명백한 것은 코드의 양 차이입니다.
이 특정 과업에 대해서는 Python과 R 모두 Bash보다 훨씬 더 많은 코드를 요구합니다.
이는 어떤 작업에는 커맨드 라인을 사용하는 것이 더 낫다는 점을 잘 보여줍니다.
다른 작업에는 프로그래밍 언어를 사용하는 것이 더 나을 것입니다.
커맨드 라인에서 더 많은 경험을 쌓을수록 언제 어떤 접근 방식을 사용해야 할지 인식하기 시작할 것입니다.
모든 것이 커맨드 라인 도구일 때는 과업을 하위 과업으로 나누어 Bash 커맨드 라인 도구와 예를 들어 Python 커맨드 라인 도구를 결합할 수도 있습니다.
당면한 과제에 가장 잘 맞는 접근 방식을 사용하면 됩니다.


### 표준 입력으로부터 스트리밍 데이터 처리하기

이전의 두 코드 조각에서 Python과 R은 모두 표준 입력 전체를 한 번에 읽었습니다.
커맨드 라인에서 대부분의 도구는 데이터를 스트리밍 방식으로 다음 도구로 파이프합니다.
`sort`와 같이 표준 출력에 데이터를 쓰기 전에 전체 데이터를 필요로 하는 도구들이 몇몇 있습니다.
이는 파이프라인이 그런 도구들에 의해 막힌다는 것을 의미합니다.
파일과 같이 입력 데이터가 유한하다면 이는 문제가 되지 않을 수 있습니다.
하지만 입력 데이터가 끊이지 않는 스트림일 때, 그런 블로킹(blocking) 커맨드 라인 도구들은 쓸모가 없습니다.

다행히 Python과 R은 스트리밍 데이터 처리를 지원합니다.
예를 들어 줄 단위로 함수를 적용할 수 있습니다.
여기 Python과 R에서 이것이 어떻게 작동하는지 보여주는 최소한의 예제 두 가지가 있습니다.

Python과 R 도구 모두 이제는 악명 높은 Fizz Buzz 문제를 해결합니다. 이 문제의 정의는 다음과 같습니다: 1부터 100까지 숫자를 출력하되, 3으로 나누어지면 "fizz"를, 5로 나누어지면 "buzz"를, 15로 나누어지면 "fizzbuzz"를 대신 출력합니다. 여기 파이썬 코드입니다[^fb].


``` console
bat fizzbuzz.py
```

그리고 여기 R 코드입니다.


``` console
bat fizzbuzz.R
```

두 도구를 테스트해 봅시다(공간을 절약하기 위해 출력을 `column`으로 파이프합니다).


``` console
seq 30 | fizzbuzz.py | column -x
seq 30 | fizzbuzz.R | column -x
```

출력이 정확해 보이네요!
이 두 도구가 실제로 스트리밍 방식으로 작동한다는 것을 증명하기는 어렵습니다.
입력 데이터를 `sample -d 100`으로 파이프한 뒤 Python이나 R 도구로 넘김으로써 이를 직접 확인할 수 있습니다.
그렇게 하면 각 줄 사이에 약간의 지연이 추가되어 도구들이 모든 입력 데이터를 기다리지 않고 줄 단위로 작동한다는 것을 더 쉽게 확인할 수 있습니다.


## 요약

이 막간 장에서 여러분만의 커맨드 라인 도구를 만드는 방법을 보여드렸습니다.
여러분의 코드를 재사용 가능한 빌딩 블록으로 바꾸는 데는 단 6단계면 충분합니다.
그것이 여러분을 훨씬 더 생산적으로 만들어 준다는 것을 알게 될 것입니다.
여러분만의 도구를 만들 기회를 계속해서 찾아보시기를 조언합니다.
다음 장에서는 데이터 과학을 위한 OSEMN 모델의 두 번째 단계인 데이터 정제를 다룹니다.


## 더 읽을거리

- 도구에 기억해야 할 옵션이 많아지고 다른 사람들과 도구를 공유하고 싶을 때 도움말 문서를 추가하는 것이 중요해집니다. `docopt`는 도움말을 제공하고 도구가 허용하는 가능한 옵션을 정의하기 위한 언어 중립적인 프레임워크입니다. Bash, Python, R을 포함한 거의 모든 언어에서 구현체를 사용할 수 있습니다.
- Bash 프로그래밍에 대해 더 알고 싶다면 Arnold Robbins와 Nelson Beebe의 *Classic Shell Programming*과 Carl Albing과 JP Vossen의 *Bash Cookbook*을 추천합니다.
- 견고하고 안전한 Bash 스크립트를 작성하는 것은 꽤 까다롭습니다. [ShellCheck](https://www.shellcheck.net/)는 여러분의 Bash 코드에서 실수와 취약점을 점검해 주는 온라인 도구입니다. 커맨드 라인 도구로도 사용 가능합니다.
- Joel Grus의 저서 *Ten Essays on Fizz Buzz*는 파이썬으로 Fizz Buzz를 해결하는 10가지 서로 다른 방식에 대한 통찰력 있고 재미있는 모음집입니다.

[^fb]: 이 코드는 [Joel Grus의 Python 스크립트](https://github.com/joelgrus/fizzbuzz/blob/master/fizzbuzz/cycle_of_15.py)를 수정한 것입니다.
